[{"title":"LLM Inference Optimization Overview - From Data to System Architecture","date":"2025-05-05T08:09:40.000Z","path":"/llm-inference-optimization-en/","text":"With the widespread application of LLMs across various industries, achieving efficient inference while maintaining model performance has become a key challenge. IntroductionMainstream LLMs are based on the decoder-only architecture of transformers, with next token prediction as their core task. During inference, the model needs to generate each token sequentially, and this autoregressive generation characteristic increases inference latency. In terms of parameter count, models can be divided into different scales, and even small models have high requirements for computational and memory resources. To address these challenges, academia and industry have proposed various optimization solutions. This article introduces several key technologies related to LLM inference acceleration. Corrections and suggestions are welcome. Main ContentInference Phase OverviewThe inference phase is the process where a model receives input and produces output. Unlike the training phase, inference doesn’t require gradient computation and parameter updates, only forward propagation calculations. During inference, due to the autoregressive generation characteristic, the model needs to generate tokens one by one. This leads to continuously increasing sequence lengths. For example: With an input length of 1000 tokens and needing to generate 100 new tokens, the actual sequence length processed is: 1000 + 1001 + … + 1100 = 106050 tokens Each new token needs to compute attention with all previous tokens In a typical decoder-only architecture, there are multiple decoder blocks, and each token must pass through these blocks during inference. Each block contains 3 main computation modules: Self-Attention, FFN, and Layer Normalization (a basic component for ensuring numerical stability, which we’ll ignore in the following discussion). image The execution phases can be divided into prefill and decode stages: Stage Characteristics Modules Prefill • Compute-intensive phase with O(n²) complexity due to full attention computation across all input tokens• Memory usage scales quadratically with sequence length due to attention matrix computation• Can leverage hardware parallelism as all tokens are processed simultaneously • Self-Attention: Computes complete attention patterns between all input tokens, generating and caching K/V representations• FFN: Processes all input tokens through feed-forward networks in parallel Decode • Linear complexity O(n) per token, but inherently sequential due to autoregressive nature• Memory growth is linear and predictable• Limited parallelization potential due to token-by-token generation • Self-Attention: Generates Q for new token only, leverages cached K/V, computes attention scores efficiently• FFN: Processes only the newly generated token through feed-forward networks Demonstration of the prefilling stage (a) and decoding stage (b) image Illustration of the memory variation through time (latency) during inference image Performance metrics during inference include: TTFT (Time-To-First-Token): Generation time for the first token, mainly measuring Prefill stage performance TPOT (Time-Per-Output-Token): Time to generate each token, mainly measuring Decode stage performance Let’s understand the inference process through a real example, query: “What are some recent practices related to Deepseek R1?” Stage Module Processing Result Prefill Self-Attention Words like “happened” and “practices” will have high attention scores with “Deepseek R1”, producing an n×n attention matrix Output the first token with highest probability FFN Will search for pretrained knowledge about Deepseek in the learned knowledge base Decode Self-Attention Use the generated new token q to understand the input kv, discover it’s asking about practices, understand the need for practice-related knowledge Output subsequent tokens with highest probability FFN Will search for practice-related knowledge in the learned knowledge base In summary, key overheads during inference: Computational cost: Prefill needs to process all inputs, input has quadratic relationship with computation Model parameter count keeps increasing Decode has low GPU computation Storage cost: KV Cache grows linearly with input sequence length, needs to store K/V for all historical tokens in memory FFN storage overhead is large, estimated to account for over 70% of parameters IO cost: decode generates only one token each time but needs to repeatedly call the model Technology OverviewThe industry has proposed optimization solutions from different stages to address these challenges: image Data LevelInput CompressionCompress input text and prune low-quality information while minimizing performance impact to improve efficiency. Specific works include: LLMLingua Series: Train small models to prune and compress original prompts image image The approach transforms compression into a token classification problem, deciding whether to keep or discard each token. The task model is trained on a dataset distilled from large models. image Other compression works in RAG scenarios: RECOMP: Compresses retrieved documents into text summaries to improve language model performance while reducing computational costs. image xRAG: Projects document embeddings directly into LLMs’ representation space through modal fusion image Conventional RAG, Rerank: Suitable for information-intensive scenarios, selecting highly relevant content to avoid garbage in garbage out image Impact of irrelevant passages on RAG effectiveness https://arxiv.org/pdf/2410.05983 Output PlanningImprove parallelism of long text output while minimizing performance impact to enhance efficiency. Specific works include: SOT: SOT proposes an approach of parallel output after understanding intent, generating an outline for the answer, then generating in parallel for each point in the outline, significantly improving linear decoding performance. However, it cannot handle scenarios well where dependencies exist between different points. Based on this, they additionally trained a router model to judge whether dependencies exist, and parallel decoding is not performed when dependencies exist. image image SGD: Takes a step further from SOT by abstracting dependency relationships into a DAG (points with dependencies have connecting lines; independent points are separate), thus further improving effectiveness. image Model LevelModel Structure Optimization Attention Optimization: The core is reducing KV Cache and kernel function computations. Adding Su Shen’s explanation: Why is reducing KV Cache size so important? As we all know, LLM inference is generally performed on GPUs, and single GPU memory is limited. One part needs to be used to store model parameters and activation values from forward computation, which depends on model size and is constant once the model is selected. Another part needs to be used to store the model’s KV Cache, which depends not only on model size but also on input length, growing dynamically during inference. When the context length is long enough, its size becomes dominant and may exceed the total memory of one card or even one machine (8 cards). The principle for deploying models on GPUs is: if it can be deployed on one card, don’t use multiple cards; if it can be deployed on one machine, don’t use multiple machines. This is because “intra-card communication bandwidth &gt; inter-card communication bandwidth &gt; inter-machine communication bandwidth”. Due to the “bucket effect”, the more devices the model deployment spans, the more it is “dragged down” by inter-device communication bandwidth. In fact, even though single H100 intra-card SRAM to HBM bandwidth has reached 3TB/s, this speed is still the bottleneck for inference with Short Context, not to mention slower inter-card and inter-machine communication. Therefore, the fundamental purpose of reducing KV Cache is to achieve inference of longer Context on fewer devices, thereby achieving faster inference speed and lower inference cost. MHA (Multi-Head Attention): The most basic multi-head attention mechanism, where each attention head has independent Q, K, V parameter matrices. Although it can fully capture information from different feature dimensions, it needs to store KV Cache for all heads, resulting in large storage overhead. MQA (Multi-Query Attention): When computing attention, shared K/V is broadcast to each attention head, then each head still uses its independent Q with shared K/V to compute attention scores. KV Cache size is reduced to 1/h of original (h is number of heads). However, sharing KV may limit the model’s ability to capture diverse features. GQA (Grouped-Query Attention): A compromise between MQA and MHA, dividing attention heads into groups with heads in the same group sharing KV. Compared to MQA it maintains better model performance while significantly reducing KV Cache compared to MHA. Representative works: DeepSeek V1, LLaMa 3.1, Qwen2. MLA (Multi-head Latent Attention): A new attention mechanism introduced by DeepSeek V2 through introducing latent variables. It significantly reduces KV cache size by compressing keys (Key) and values (Value) to a low-dimensional latent space. Compared to standard attention mechanisms, it reportedly reduces KV cache by about 93.3%. image image MOE (Mixture-of-Expert): An advanced neural architecture that replaces the traditional monolithic FFN with a dynamic routing system. The architecture consists of: A gate network that learns to route tokens to the most relevant expert networks Multiple specialized expert networks (typically 8-32) that process different aspects of the input A load balancing mechanism to ensure efficient utilization of experts This design offers several advantages: Increased model capacity without proportional increase in computation cost Dynamic specialization where different experts can focus on different types of tokens/tasks Improved inference efficiency through selective expert activation The approach originated from the 1991 paper Adaptive Mixture of Local Experts and has seen renewed interest in modern LLMs. Starting with Mistral’s Mixtral 8x7B, MOE has become a mainstream trend in 2024, with DeepSeek’s implementations showcasing increasingly sophisticated architectures across their model versions. Key challenges in MOE implementation include: Balanced token routing to prevent expert overload Ensuring expert specialization without knowledge conflicts Maintaining routing efficiency at inference time image image Model CompressionModel compression aims to reduce resource overhead by reducing model complexity (including parameter count, computation, and memory usage) while maintaining model performance as much as possible. Some representative measures include: image Quantization: Quantization reduces the precision of model weights and activations. Most models are trained with 32 or 16-bit precision, where each parameter and activation element occupies 32 or 16 bits of memory (single precision floating point). Obviously, we can try to use fewer bits to represent weights. Common methods include post-training quantization, directly converting numerical precision after model training, simple operation but may reduce accuracy; and quantization-aware training, simulating quantization effects during training to let the model adapt to low precision in advance, resulting in less accuracy loss. Benefits include significantly reducing model size and improving computation speed. Focus on activation value quantization in prefill stage; focus on weight quantization in decode stage. image Knowledge Distillation: Knowledge distillation is a compression method that transfers knowledge from large models (teacher models) to small models (student models). Common methods include post-training distillation, directly using teacher model to generate data to train student model, which can compress the model to 40-60% of original size while maintaining most performance. image Pruning: Compress model by removing unimportant connections or structures. Common methods include structured pruning (removing entire layers or heads) and unstructured pruning (removing individual weights), can reduce parameters by 30-50% with minimal performance loss. Low-rank Decomposition: Decompose large weight matrices into products of several small matrices to reduce parameter count and computation. Common methods include SVD decomposition and LoRA etc. Among them, LoRA achieves parameter-efficient fine-tuning by adding low-rank matrices beside original weights, becoming one of the mainstream model compression methods. Decoding OptimizationThe most time-consuming part of inference stage is the autoregressive generation process. Decoding optimization aims to accelerate token generation through parallelization or prediction. Some representative measures include: Speculative Decoding: An innovative decoding technique for autoregressive large models aimed at improving decoding efficiency without affecting output quality. The core idea includes using a smaller model (Draft Model) to effectively predict several subsequent tokens, then using the large model to verify these predictions in parallel. This method aims to enable the large model to generate multiple tokens in the time range usually required for a single inference. image Skip-token Decoding: Representative work SGLang, core idea is to skip predictable parts during generation by analyzing deterministic features of text structure. Instead of generating token by token, it can directly jump to the next position requiring inference at positions with high determinism, greatly improving generation efficiency. image Constrained Decoding: Representative work Outlines, Outlines converts JSON Schema into regular expressions, then builds finite state machines (FSM) based on these regular expressions, then filters tokens in real-time during generation to ensure output always conforms to predefined format requirements. This approach is particularly suitable for scenarios requiring strict output format control. image Structured Decoding: Representative work Guidance, innovation lies in dividing generation tasks into fixed structure and dynamic content categories and adopting different processing strategies. By identifying template parts in text, it can significantly reduce the amount of content that needs to be actually generated, thereby improving overall efficiency. image System LevelKV CacheKV Cache optimization is critical for LLM inference efficiency as it represents a significant memory bottleneck. The optimization focuses on two key aspects: Sparsification Compression: Approach: Strategically select and retain only the most informative tokens while pruning less important ones Implementation: Uses attention scoring to identify key tokens Example:Original sequence (dense):[T1, T2, T3, ..., T128K] // Full 128K token sequenceAfter sparsification (sparse):[T1, T512, T1024, ..., T128K] // Only ~1K tokens retained- Retains tokens with high attention scores- Maintains semantic coherence- Reduces memory footprint by &gt;90% Quantization Compression: Approach: Reduce numerical precision of stored K/V values Implementation methods: Post-training quantization (e.g., FP16 → INT8) Dynamic quantization during inference Mixed-precision storage strategies Benefits: 2-4x memory reduction with minimal accuracy impact Improved cache hit rates Better hardware utilization These optimization strategies can be combined and tuned based on specific requirements: Long-context scenarios benefit more from sparsification Latency-sensitive applications might prefer quantization Production systems often use a hybrid approach The optimization process typically follows this workflow: image PagedAttentionTraditional inference frameworks adopt static memory allocation strategy: pre-allocating fixed size memory blocks according to batch_size × max_seq_len, resulting in low memory utilization. // Traditional static allocationPre-allocated memory size = 4(batch_size) × 2048(max_seq_len) × 2(bytes/token)Actual usage:- Request1: uses 256 tokens- Request2: uses 512 tokens- Request3: uses 128 tokensResult: Large amount of memory space wasted vllm borrows virtual memory paging idea from operating systems, proposing PagedAttention technology to achieve dynamic allocation of KV Cache memory. // PagedAttention dynamic allocationMemory page size = 16KBRequest1: dynamically allocate 2 pages (32KB)Request2: dynamically allocate 4 pages (64KB)Request3: dynamically allocate 1 page (16KB)Advantage: Allocate on demand, improve memory utilization This dynamic management mechanism allows memory resources to be used more efficiently, particularly suitable for handling multi-request scenarios with varying lengths. image Prefix CacheLimitation of traditional PagedAttention: KV Cache can only be reused within single request, cannot be shared across requests, which is inefficient in multi-round dialogue scenarios. Example: // Traditional wayDialogue round 1: Prompt: \"Hello, please introduce Beijing\" → Calculate complete KV CacheDialogue round 2: Prompt: \"Hello, please introduce the Forbidden City in Beijing\" → Recalculate KV Cache (even though contains lots of repeated content) Prefix Caching optimization: Achieve cross-request reuse by caching KV Cache of system prompts and dialogue history, reducing Time To First Token (TTFT). RadixAttention proposed by SGLang achieves automatic KV Cache reuse through three key steps: Cache retentionAfter request completion:KV Cache → Retained in GPU memoryToken sequence → Stored in RadixTree Prefix matchingNew request: \"Hello, please introduce the Forbidden City in Beijing\"↓RadixTree matching↓Hit: KV Cache of \"Hello, please introduce Beijing\"↓Only need to calculate new part: \"the Forbidden City\" Cache managementStrategy: LRU (Least Recently Used)When memory is insufficient:- Identify least recently used KV Cache- Prioritize releasing this part of memory This optimization is particularly suitable for scenarios like multi-round dialogues, can significantly improve model response speed and resource utilization efficiency. OthersThere are many other optimization approaches at system level, such as tensor parallelism, pipeline parallelism, distributed inference etc. Since these optimization solutions involve relatively complex system architecture design, we won’t discuss them in detail here. Interested readers can refer to relevant technical documentation for deeper understanding. ConclusionThrough in-depth discussion of LLM inference acceleration technologies, we can see: Technical Architecture and Challenges Inference process divided into two main stages: Prefill and Decode Core challenges: Computational cost: input scale, parameter count, autoregressive nature Storage cost: KV Cache, FFN parameter storage IO cost: frequent model calls Optimization Solutions (Multi-level Technology Stack) Data level optimization: Input compression: LLMLingua, RECOMP, xRAG etc. Output planning: SOT, SGD and other parallel output technologies Model level optimization: Structure optimization: attention mechanisms (MHA, MQA, GQA, MLA), MOE architecture Model compression: quantization, knowledge distillation, pruning, low-rank decomposition Decoding optimization: speculative decoding, skip-token decoding, constrained decoding etc. System level optimization: KV Cache optimization: sparsification compression, quantization compression PagedAttention: dynamic memory management Prefix Cache: cross-request KV reuse As LLMs continue to expand their applications across various fields, inference acceleration technologies also continue to evolve. From early simple optimizations to current multi-level comprehensive optimization solutions, technology keeps breaking through. The development of these optimization technologies enables LLMs to serve practical application scenarios more efficiently, laying an important foundation for the popularization of AI applications. In the future, with the advancement of hardware technology and algorithm innovation, we expect to see more breakthrough inference acceleration solutions. References: A Survey on Efficient Inference for Large Language Models Very helpful, recommended Model Compression and Efficient Inference for Large Language Models: A Survey Mastering LLM Techniques: Inference Optimization AI Large Model Inference Process and Optimization Technologies How to make LLMs go fast Yidoo Blog Detailed Discussion on DeepSeek MoE Related Technical Development The Ultimate Trade-off Between Cache and Effect: From MHA, MQA, GQA to MLA A Survey on Model Compression for Large Language Models Feel free to share articles from this site, please credit the author and source SimonAKing.","categories":[{"name":"LLM","slug":"LLM","permalink":"https://simonaking.com/blog/categories/LLM/"}],"tags":[{"name":"LLM","slug":"LLM","permalink":"https://simonaking.com/blog/tags/LLM/"},{"name":"Inference Optimization","slug":"Inference-Optimization","permalink":"https://simonaking.com/blog/tags/Inference-Optimization/"}]},{"title":"聊聊大模型推理加速：从数据到系统的技术概要","date":"2025-03-27T08:09:40.000Z","path":"/llm-inference-optimization/","text":"随着 LLMs 在各行各业的应用，如何在保证模型性能的前提下实现高效推理已成为重点挑战之一。 前言主流的 LLMs 在算法架构上基于 transformer 的 decoder-only 架构，核心任务是 next token prediction，在推理过程中，模型需要依次生成每个 token，这种自回归生成的特点会增加推理延迟。并且从参数量上模型可分为不同规模，即使是小模型，其对计算资源和内存资源也有较高要求。 为了应对这些挑战，学术界和工业界提出了多种优化方案。本文将介绍了若干 LLMs 的推理加速相关的关键技术。如有错误或不准确之处，欢迎指正。 正文推理阶段概述推理阶段是模型接收输入并产生输出的过程。与训练阶段不同，推理阶段不需要计算梯度和更新参数，只需要完成前向传播计算。 在推理过程中，由于自回归生成的特点，模型需要逐个生成 token。这导致处理的序列长度会不断增加。例如： 输入长度为 1000 tokens，需要生成 100 个新 tokens，那么实际计算的序列长度为： 1000 + 1001 + … + 1100 = 106050 个 tokens 每个新 token 都需要与之前所有 token 计算注意力 在典型的 decoder-only 架构中，有多层 decoder block，每个 token 在推理时都要依次通过这些 block。每个 block 包含 3 个主要计算模块：Self-Attention、FFN、Layer Normalization（保证数值稳定性的基础，下文忽视）。 image 其模块的执行阶段可分为 prefill 阶段与 decode 阶段： 阶段 特点 模块 Prefill • 计算密集场景：计算复杂度为 O（n2），n*n 的矩阵运算，但可利用硬件的并行处理能力加快• 显存密集场景：占用显存随序列长度增长 • Self-Attention: 需要计算所有输入 token 之间的注意力分数，生成并存储所有 token 的 K、V 到 cache 中• FFN: 对所有输入 token 执行 FFN 计算 Decode • 计算稳定：向量计算，每个 token 的计算量为 O（n），1*n 的向量计算，延迟主要来自顺序依赖，难以并行化• 显存增长稳定 • Self-Attention: 只需为新 token 生成 Q，复用已缓存的 K、V，计算新 token 的注意力分数• FFN: 只对新生成的 token 执行 FFN 计算 Demonstration of the prefilling stage (a) and decoding stage (b) image Illustration of the memory variation through time (latency) during image 推理过程中性能指标包括： TTFT（Time-To-First-Token）：首 token 的生成时间，主要衡量 Prefill 阶段性能。 TPOT（Time-Per-Output-Token）：生成每个 token 的时间，主要衡量 Decode 阶段性能。 通过一个实际的例子来理解推理过程，query：”最近发生了哪些与 Deepseek R1 相关的实践” 阶段 模块 处理过程 结果 Prefill Self-Attention “发生”、”实践” 会与 “Deepseek R1” 产生比较高的关注度，产生 n * n 的注意力矩阵 输出第一个概率最高的 token FFN 会在大量已学习知识中，查找到关于 Deepseek 的 pretrain 知识 Decode Self-Attention 用生成的 新 token q 去理解输入的 kv ，发现问的是实践，理解需要实践的相关知识 输出后续概率最高的 token FFN 会在大量已学习知识中，找到实践的相关知识 综上，推理阶段的关键开销： 计算成本： Prefill 要处理所有输入，输入与计算量成平方关系； 模型参数量越来越大； Decode gpu 计算量低 存储成本： KV Cache 与输入序列的长度成正比，需要在显存中保存所有历史 token 的 K/V FNN 存储开销大，参数量预计占比 70% 以上 IO 成本：decode 每次只生成一个 token，但要反复调用模型 技术总览针对这些挑战，业界从不同阶段提出了优化方案： image 数据层面输入压缩在尽可能降低性能影响的前提下，压缩输入的文本，裁剪低质信息，从而提升性能，细分工作： LLMLingua Series：训练小模型对原始 prompt 进行裁剪压缩 image image 其思路是将压缩过程转化为一个词元分类问题，即决定每个词元是保留还是舍弃。任务模型是通过大模型蒸馏出数据集后，训练一个小模型来执行。 image 另一些在 rag 场景的压缩工作： RECOMP：将检索到的文档压缩成文本摘要来提高语言模型的性能，同时减少计算成本。 image xRAG：通过模态融合的方式将文档的 embedding 直接投影到 LLMs 的表示空间中 image 常规的 RAG、Rerank：适用于信息密集型场景，选择高相关的内容，避免 garbage in garbage out image 不相关段落对于 RAG 效果的影响 https://arxiv.org/pdf/2410.05983 输出规划在尽可能降低性能影响的前提下，提升长文本输出的并行度，从而提升性能，细分工作： SOT：SOT 提出一种意图理解后并行输出的思路，对答案生成大纲，然后针对大纲中的每一个点再并行生成，从而提高了线性解码的性能，但对应不同点之间存在依赖的场景，无法很好的解决。所以基于此，又额外训练了个 router model 去判断是否存在依赖，存在依赖则不进行并行解码。 image image SGD：在 SOT 的基础上更进一步，将依赖关系抽象成 DAG（有依赖的点 存在连线；没有依赖的点独立），所以可以更进一步提升效果。 image 模型层面模型结构优化 Attention 优化：核心是减少 KV Cache 以及核函数的运算， 补一下苏神的解答：为什么降低 KV Cache 的大小如此重要？众所周知，一般情况下 LLM 的推理都是在 GPU 上进行，单张 GPU 的显存是有限的，一部分我们要用来存放模型的参数和前向计算的激活值，这部分依赖于模型的体量，选定模型后它就是个常数；另外一部分我们要用来存放模型的 KV Cache，这部分不仅依赖于模型的体量，还依赖于模型的输入长度，也就是在推理过程中是动态增长的，当 Context 长度足够长时，它的大小就会占主导地位，可能超出一张卡甚至一台机（8 张卡）的总显存量。在 GPU 上部署模型的原则是：能一张卡部署的，就不要跨多张卡；能一台机部署的，就不要跨多台机。这是因为“卡内通信带宽 &gt; 卡间通信带宽 &gt; 机间通信带宽”，由于“木桶效应”，模型部署时跨的设备越多，受设备间通信带宽的的“拖累”就越大，事实上即便是单卡 H100 内 SRAM 与 HBM 的带宽已经达到了 3TB/s，但对于 Short Context 来说这个速度依然还是推理的瓶颈，更不用说更慢的卡间、机间通信了。所以，减少 KV Cache 的根本目的是实现在更少的设备上推理更长的 Context，从而实现更快的推理速度以及更低的推理成本。 MHA（Multi-Head Attention）：最基础的多头注意力机制，每个注意力头都有独立的 Q、K、V 参数矩阵。虽然可以充分捕获不同特征维度的信息，但需要存储所有头的 KV Cache，存储开销较大。 MQA（Multi-Query Attention）: 在计算注意力时，共享的 K/V 会被广播到每个注意力头，然后每个头仍然使用自己独立的 Q 与共享的 K/V 计算注意力分数。KV Cache 大小减少为原来的 1/h （h 是头数）。但共享 KV 可能会限制模型捕获多样化特征的能力。 GQA（Grouped-Query Attention）: MQA 和 MHA 的折中方案，将注意力头分成若干组，同一组内的头共享 KV。相比 MQA 能保持更好的模型性能，同时相比 MHA 显著减少了 KV Cache。代表作：DeepSeek V1、LLaMa 3.1、Qwen2。 MLA（Multi-head Latent Attention）: 是 DeepSeek V2 通过引入隐变量的一种新型的注意力机制。它通过压缩键 （Key） 和值 （Value） 到一个低维隐式空间，显著减少了 KV 缓存的大小。与标准注意力机制相比，据称可减少约 93.3% 的 KV 缓存。 image image MOE（Mixture-of-Expert）：高效的 FFN 设计，将 FFN 拆解成一个 gate network 与 多个 expert，每个 token 只分配给若干个 experts 进行计算，可以显著减少缓存、IO 开销，该思路起源于 1991 年的论文 Adaptive Mixture of Local Experts。 从 Mistral 的 Mixtral 8x7B 开始，在 24 年 moe 已成为各大模型的主流趋势，以 deepseek 为代表，三个版本的 paper 都是沿着更专业、更极致 的 moe 架构演进。其中的难点有：token 分配的问题、专家学识不精等。 image image 模型压缩模型压缩旨在通过降低模型复杂度（包括参数量、计算量和内存占用）来减少资源开销，在尽可能保持模型性能的前提下提升推理效率。其中一些代表性的措施有： image 量化：量化是降低模型权重和激活的精度，大多数模型都以 32 或 16 位精度进行训练，其中每个参数和激活元素占用 32 或 16 位内存（单精度浮点），显然，可以尝试使用更少的位来表示权重。 常见的方法有训练后量化，模型训练完直接转换数值精度，操作简单但精度可能下降；还有量化感知训练，训练时模拟量化效果，让模型提前适应低精度，精度损失更小。收益除了大幅减少模型体积外，也能提高计算速度。在 prefill 阶段 重点量化激活值量化；在 decode 阶段 重点量化权重。 image 知识蒸馏：知识蒸馏是将大模型（教师模型）的知识转移到小模型（学生模型）中的压缩方法。常见方法有训练后蒸馏，直接用教师模型生成数据训练学生模型，可以在保持大部分性能的同时将模型压缩至原来的 40-60%。 image 减枝：通过移除模型中不重要的连接或结构来压缩模型。常见方法有结构化剪枝（移除整层或整个头）和非结构化剪枝（移除单个权重），可以在性能损失较小的情况下减少 30-50% 的参数量。 低秩分解：将大的权重矩阵分解成若干个小矩阵的乘积，从而减少参数量和计算量。常见方法有 SVD 分解和 LoRA 等。其中 LoRA 通过在原始权重旁增加低秩矩阵来实现参数高效微调，已成为主流的模型压缩方法之一。 解码优化推理阶段最耗时的部分是自回归生成过程，解码优化旨在通过并行化或预测等方式来加速 token 生成。其中一些代表性的措施有： 推测解码 （Speculative Decoding）：一种用于自回归大模型的创新解码技术，旨在提高解码效率，同时不影响输出的质量。这种方法的核心思想包括使用一个较小的模型（Draft Model）来有效地预测几个后续 token，然后使用大模型并行验证这些预测。该方法旨在使大模型能够在单个推理通常所需的 a 时间范围内生成多个 token。 image 跳跃式解码：代表工作 SGLang，核心思想是通过分析文本结构的确定性特征，在生成过程中跳过可预测的部分。它不需要逐个 token 地生成，而是能够在确定性很强的位置直接跳转到下一个需要推理的位置，从而大幅提升生成效率。 image 约束性解码：代表工作 Outlines，Outlines 通过将 JSON Schema 转换成正则表达式，然后基于该正则表达式构建有限状态机（FSM， Finite State Machine），然后在生成过程中实时过滤 token，确保输出始终符合预定义的格式要求。这种方式特别适合需要严格控制输出格式的场景。 image 结构化解码：代表工作 Guidance，创新点在于将生成任务分为固定结构和动态内容两类，并采用不同的处理策略。通过识别文本中的模板部分，可以显著减少需要实际生成的内容量，从而提高整体效率。 image 系统层面KV CacheKV Cache 在 LLM 推理过程中占用了大量访存带宽，这使得 KV Cache 的压缩优化成为 LLM 推理领域的研究热点。目前主要有两种压缩技术路线： 稀疏化压缩通过减少保留的关键 token 数量来实现压缩。例子：原始输入：[T1, T2, T3, ..., T128K] // 128K tokens 的 prompt稀疏化后：[T1, T512, T1024, ..., T128K] // 仅保留 1024 个关键 tokens 量化压缩在保持 token 数量不变的情况下，降低数据精度。例子： 这两种方法各有特点，但都致力于在保证模型性能的前提下，降低内存占用并提升推理速度。稀疏化适合处理超长文本输入，而量化则是一种普适性的优化方案。 KV Cache 优化的过程： image PagedAttention传统推理框架采用静态显存分配策略：按照 batch_size × max_seq_len 预分配固定大小的显存块，这导致显存利用率低下。 // 传统静态分配预分配显存大小 = 4(batch_size) × 2048(max_seq_len) × 2(bytes/token)实际使用情况：- 请求 1: 使用 256 tokens- 请求 2: 使用 512 tokens- 请求 3: 使用 128 tokens结果：大量显存空间被浪费 vllm 借鉴操作系统的虚拟内存分页思想，提出了 PagedAttention 技术，实现 KV Cache 显存的动态分配。 // PagedAttention 动态分配显存页大小 = 16KB请求 1: 动态分配 2 页 (32KB)请求 2: 动态分配 4 页 (64KB)请求 3: 动态分配 1 页 (16KB)优势：按需分配，提高显存利用率 这种动态管理机制让显存资源得到更高效的利用，特别适合处理长度变化较大的多请求场景。 image Perfix Cache传统 PagedAttention 的局限：KV Cache 只能在单个请求内复用，无法跨请求共享，这在多轮对话场景下效率不高。 例子： // 传统方式对话轮次 1： Prompt: \"你好，请介绍下北京\" → 计算完整的 KV Cache对话轮次 2： Prompt: \"你好，请介绍下北京的故宫\" → 重新计算 KV Cache（即使包含大量重复内容） Prefix Caching 优化：通过缓存系统提示和历史对话的 KV Cache，实现跨请求复用，降低首次 Token 生成时间（TTFT）。 SGLang 提出的 RadixAttention 通过三个关键步骤实现自动 KV Cache 复用： 缓存保留请求完成后：KV Cache → 保留在 GPU 显存Token 序列 → 存入 RadixTree 前缀匹配新请求：\"你好，请介绍下北京的故宫\"↓RadixTree 匹配↓命中：\"你好，请介绍下北京\"的 KV Cache↓仅需计算新增部分：\"的故宫\" 缓存管理策略：LRU（最近最少使用）当显存不足时：- 识别最久未使用的 KV Cache- 优先释放这部分显存 这种优化特别适合多轮对话等场景，可以显著提升模型响应速度和资源利用效率。 其他系统层面还有诸多优化手段，如张量并行、流水线并行、分布式推理等。由于这些优化方案涉及较为复杂的系统架构设计，在此不做展开讨论。感兴趣的读者可以参考相关技术文档深入了解。 结束语通过对 LLMs 推理加速技术的深入探讨，我们可以看到： 技术架构与挑战 推理过程分为 Prefill 和 Decode 两个主要阶段 核心挑战： 计算成本：输入规模、参数量、自回归特性 存储成本：KV Cache、FFN 参数存储 IO 成本：频繁模型调用 优化方案（多层次技术栈） 数据层面优化： 输入压缩：LLMLingua、RECOMP、xRAG 等 输出规划：SOT、SGD 等并行输出技术 模型层面优化： 结构优化：注意力机制（MHA、MQA、GQA、MLA）、MOE 架构 模型压缩：量化、知识蒸馏、减枝、低秩分解 解码优化：推测解码、跳跃式解码、约束性解码等 系统层面优化： KV Cache 优化：稀疏化压缩、量化压缩 PagedAttention：动态显存管理 Prefix Cache：跨请求 KV 复用 随着 LLMs 在各领域的应用不断扩大，推理加速技术也在持续演进。从早期的简单优化到现在的多层次综合优化方案，技术在不断突破。这些优化技术的发展使得 LLMs 能够更高效地服务于实际应用场景，为 AI 应用的普及奠定了重要基础。未来，随着硬件技术的进步和算法的创新，我们有望看到更多突破性的推理加速方案。 参考资料： A Survey on Efficient Inference for Large Language Models 帮助很大，推荐 Model Compression and Efficient Inference for Large Language Models: A Survey Mastering LLM Techniques: Inference Optimization AI 大模型推理过程和优化技术 How to make LLMs go fast 异度部落格 详细谈谈 DeepSeek MoE 相关的技术发展 缓存与效果的极限拉扯：从 MHA、MQA、GQA 到 MLA A Survey on Model Compression for Large Language Models 欢迎转载本站文章，请注明作者和出处 SimonAKing。","categories":[{"name":"LLM","slug":"LLM","permalink":"https://simonaking.com/blog/categories/LLM/"}],"tags":[{"name":"LLM","slug":"LLM","permalink":"https://simonaking.com/blog/tags/LLM/"},{"name":"推理加速","slug":"推理加速","permalink":"https://simonaking.com/blog/tags/%E6%8E%A8%E7%90%86%E5%8A%A0%E9%80%9F/"}]},{"title":"聊聊 Rerank：从 BERT 到大模型的技术旅程","date":"2024-12-09T10:40:53.000Z","path":"/rerank/","text":"从搜索引擎到大语言模型，Rerank 技术一直在默默发挥着”最后一公里”的关键作用。 前言在 NLP 场景中，Rerank 作为一个关键环节，承担着对多路召回、多数据来源、多模态、多结构等不同类型数据的归一化和精筛作用。它能有效地整合和优化各类召回结果，对提升检索系统的整体性能至关重要。 本文将介绍 rerank 相关的技术概念、业界进展，以及对业务 产生价值的可能性。 Rerank-从 BERT 到大模型的技术旅程/overall.png 正文什么是 RerankRerank 并不是新兴的技术，其发展历史可追溯到搜索引擎，其历程可浓缩为 3 个主要阶段： Rerank-从 BERT 到大模型的技术旅程/timeline.png 一句话介绍：Rerank 是一种对初步检索结果进行重排序的优化技术，以提高问答结果的准确性。 在 RAG 应用中，如果没有 rerank 会给到模型 粗召后的文档，会出现文档与 query 深层语义相关性不足（仅表面相似）问题，导致生成质量下降。 一个 bad case： Rerank-从 BERT 到大模型的技术旅程/badcase.png Rerank-从 BERT 到大模型的技术旅程/Influence.png 不相关段落对于 RAG 效果的影响 https://arxiv.org/pdf/2410.05983 具体而言，rerank 的加持会带来： 排除无关信息：Rerank 会进一步深度理解语义，从向量的相似度、关键词的词频权重到理解复杂语义（如 cross-encoder 架构）； 有更多排序可能性：能够增加多维度的特征进行加权计算（如 文档完整性、时效性、权威性..) ; 能基于文档上下文、query 意图排序：排序后的文档 不仅是语义关联，还能提升准确反映 query 真实意图的文档权重。 举个例子：query 是某个 topic 相关的问答，如：苹果公司最新的产品发布会有哪些亮点？ 再精排后，可以再进一步过滤 低相关的 documents 或者 基于模型窗口限制、注意力缺陷（如 lost in the middle），根据 相关分数 重排 documents ，能够有效提升 RAG 应用的问答效果。 业界实践因为涉及到了精排，所以会产生额外的延迟；且 rerank 模型也需要一定的参数量，对于长尾场景可能也会有偏差。近年来的研究已经提出了多种创新方法来应对这些挑战。以下将介绍一些具有代表性的论文。 Passage Re-ranking with BERT 📄 Paper: https://arxiv.org/abs/1901.04085 该工作开创性地提出了一种基于 BERT 的 rerank 模型，证明了 预训练模型在 rerank 任务的效果，也影响了后续相关的研究工作。 Rerank-从 BERT 到大模型的技术旅程/p1.png 核心思路是将 rerank 视为 二分类任务，假设输入是 query-document pairs，会采取 point-wise 思路（二分类）将 query-document 拼接成单个序列：[CLS] query [SEP] document [SEP]，[SEP] 分割后的 token 会增加 token_type_ids 作为 llm embedding 的一部分（辅助信息 用于区分 query 与 document）。 经过 多层 self-attention，[CLS] token 能表示 query 与 document 的匹配度，最后通过一个分类层预测 [CLS] token 表示的相关性得分。 训练时，相关的数据作为正样本，不相关的数据作为负样本，使用交叉熵损失进行优化。 关键代码介绍： class SimpleBertReranker(nn.Module): def __init__(self, bert_model_name='bert-base-uncased'): super().__init__() self.bert = BertModel.from_pretrained(bert_model_name) self.classifier = nn.Linear(self.bert.config.hidden_size, 1) # 分类层 def forward(self, input_ids, attention_mask, token_type_ids): # 获取 BERT 的输出 outputs = self.bert(input_ids=input_ids, attention_mask=attention_mask, token_type_ids=token_type_ids) # 使用 [CLS] token 的表示 cls_output = outputs.pooler_output # 通过分类层得到相关性得分 score = self.classifier(cls_output) return scoretokenizer = BertTokenizer.from_pretrained('bert-base-uncased')query = \"What is the capital of France?\"document = \"Paris is the capital of France.\"# 编码输入inputs = tokenizer(query, document, return_tensors='pt', padding=True, truncation=True)# 初始化模型model = SimpleBertReranker()# 计算相关性得分with torch.no_grad(): score = model(**inputs) print(\"Relevance score:\", score.item()) Document Ranking with a Pretrained Sequence-to-Sequence Model 📄 Paper: https://arxiv.org/abs/2003.06713 该工作提出了一种不同于 BERT 模型 分类任务的方式，基于 T5 模型 将 rerank 视为生成任务。 Rerank-从 BERT 到大模型的技术旅程/p2.png Rerank-从 BERT 到大模型的技术旅程/p3.png 输入序列的格式是 Query: q Document: d Relevant: 格式，输出是 true、false 这两种 token。 在训练时，模型被微调为根据正负样本输出 “true” 或 “false” 作为目标 token；在推理阶段 通过对目标 token 进行 softmax 计算概率来进行重排。 关键代码介绍： class T5Reranker: def __init__(self): # 加载预训练的 T5 模型 self.model = load_pretrained_t5() def prepare_input(self, query, document): # 构造输入序列格式 return f\"Query: {query} Document: {document} Relevant:\" def fine_tune(self, train_data): \"\"\"训练过程 train_data: [(query, document, is_relevant), ...] \"\"\" for query, document, is_relevant in train_data: input_text = self.prepare_input(query, document) target = \"true\" if is_relevant else \"false\" self.model.train(input_text, target) def rerank(self, query, candidate_documents): \"\"\"重排序过程\"\"\" results = [] for doc in candidate_documents: # 构造输入序列 input_text = self.prepare_input(query, doc) # 获取模型输出的 logits logits = self.model.get_logits(input_text) # 只对\"true\"和\"false\" token 计算 softmax true_false_logits = logits[[\"true_token_id\", \"false_token_id\"]] probs = softmax(true_false_logits) # 使用\"true\" token 的概率作为相关性分数 relevance_score = probs[\"true_token_id\"] results.append((doc, relevance_score)) # 根据相关性分数排序 ranked_docs = sorted(results, key=lambda x: x[1], reverse=True) return ranked_docs Is ChatGPT Good at Search? Investigating Large Language Models as Re-Ranking Agents 📄 Paper: https://arxiv.org/abs/2304.09542 该工作调研了 GPT 模型（GPT-4） 在 rerank 任务上的表现，基于当时的 sota 模型（GPT4）再结合合适的方法（滑动窗口+ listwise），可使得 GPT 模型达到 SOTA 结果。 Rerank-从 BERT 到大模型的技术旅程/p4.png Rerank-从 BERT 到大模型的技术旅程/p5.png 通过图 c 的 prompt 要求 LLMs 生成相关性的段落 ID，如果超出模型窗口时 会使用 滑动窗口策略： 首先对（M-w）到 M 的段落进行排名，然后滑动窗口，对（M-w-s）到（M-s）的段落重新排名，重复此过程直到所有段落都被重新排名。 Rerank-从 BERT 到大模型的技术旅程/p6.png Large Language Models are Effective Text Rankers 📄 Paper: https://arxiv.org/abs/2306.17563 上篇工作证明了使用 LLMs 在 rerank 场景的效果，不过由于其黑盒，并且对初始段落顺序的敏感（使用 BM25 召回的顺序会优于随机顺序），仅能依靠商业大模型（开源模型失败率高），研究价值不高。 不同于基于 sota 模型做 listwise，该工作提出了 PRP（Pairwise Ranking Prompting） 一种新策略（下图 1），核心思路是 拆解问题，每个任务的难度降低，对 LLMs 的能力要求也会降低。 通过合适的评分机制 再结合高效的排序方式，能做到在 小模型上达到不错效果。 Rerank-从 BERT 到大模型的技术旅程/p7.png Rerank-从 BERT 到大模型的技术旅程/p8.png Leveraging Passage Embeddings for Efficient Listwise Reranking with Large Language Models 📄 Paper: https://arxiv.org/abs/2406.14848 上面两篇工作都是基于 LLMs 进行 rerank 任务，但 LLMs 会有幻觉以及 latency 居高不下的问题，本篇工作提出了一种 PE Rank 的技术。 仍然采用 listwise 的方式，有两种 document 的处理方式，其中一种是不会将召回的 document 给到 LLMs，而是会将 document 替换成 特殊标记，类似于 soft prompt，prompt 如下： I will provide you with {{n}} passages, each with a special token representing the passageenclosed in [].Rank the passages based on their relevance to the search query: {{query}}.Passage 1: [{{embedding}}]...Passage {{n}}: [{{embedding}}]Search Query: {{query}}Rank the {{n}} passages above based on their relevance to the search query in descending order.Only output the {{n}} unique special token in the ranking. Rerank-从 BERT 到大模型的技术旅程/p9.png 核心有两点： 在输入时通过一个训练好的 mlp 层将 token embedding 映射成 llm embedding，能够压缩文档上下文（类似于 xRag），给到模型的输入见图 3。 输出时约束了 decode ，解码空间 仅能包含文档 ID，能根治 LLMs 的幻觉问题，因为 词表空间变小了，所以也加快了生成速度。 相应的在训练时，分两阶段 输入的映射层训练，以及 decoding 时的排序学习训练。 业界进展近一年，多家组织/公司 推出了各自的 rerank 模型，一些亮点： 模型 发布时间 亮点 Cohere Rerank-3.5 2024/12/3 - 相比前代模型提升了 10% 的准确率 Jina Reranker v2 2024/06/25 - 支持跨语言重排（cross-lingual reranking） BGE Re-Ranker v2.0 2024/03/18 - 在 MTEB 重排任务上达到 SOTA 水平 这些进展表明，rerank 未来会向着更高的准确率和更低的 latency 发展，使用场景也不会局限于 文档排序。 结束语通过对 rerank 技术的深入探讨，我们可以看到： 技术演进趋势 从简单的 BERT 二分类，到 T5 生成式方法，再到利用大模型能力，rerank 技术在不断创新 业界正在探索如何平衡效果与效率，比如通过 embedding 压缩、约束解码等方式优化性能 开源社区和商业产品都在积极推进，为不同场景提供了丰富的选择 对业务的价值 提升搜索质量：通过深度语义理解，能更准确地识别用户意图，减少无关结果 优化 RAG 应用：通过精准的文档筛选和重排，显著提升大模型问答的准确性 支持多样化场景： 产品分析：更准确地发现用户反馈，包括应用商店评论、社交媒体讨论等 信息转化：提高相关信息的发现效率，降低噪音 对话应用：提供更精准的知识库匹配 … 回顾 rerank 的发展历程，从 BERT 二分类到基于 LLM 策略的工作，技术在不断突破；从单一的搜索场景到如今的 RAG 应用，价值在持续提升。随着 AI 应用的普及，rerank 作为连接召回和生成的关键环节，在提升问答质量方面发挥着重要的作用。 欢迎转载本站文章，请注明作者和出处 SimonAKing。","categories":[{"name":"LLM","slug":"LLM","permalink":"https://simonaking.com/blog/categories/LLM/"}],"tags":[{"name":"LLM","slug":"LLM","permalink":"https://simonaking.com/blog/tags/LLM/"},{"name":"Rerank","slug":"Rerank","permalink":"https://simonaking.com/blog/tags/Rerank/"}]},{"title":"Mac Mini 换机指南","date":"2023-05-22T07:30:40.000Z","path":"/mac-mini/","text":"记录我的 Mac Mini 开发环境配置过程，分享一些实用的工具和经验 前言自从工作后，我的学习与办公环境全面迁移到了 MacOS，而旧的 Windows 机逐渐沦为游戏机（虽然没多少时间玩）。由于手头只有公司发放的笔记本，使用时难免有诸多限制。今年 Apple 发布新设备后，我就一直心心念念想入手一台。考虑到自己没有移动办公需求，加上家里有闲置的显示器，最终选择了一台性能强劲的 Mac Mini。 购买建议：对于此类重大消费决策，建议不要被社交媒体（小红书、知乎、抖音、Bilibili）的种草内容过度影响。应该根据自己的实际需求做出选择。 我的设备配置如下： 显示器：联想创新 MiniLED 屏幕（22 年购入，支持 1000 尼特亮度） 键盘：Magic Keyboard 触控板：Magic Trackpad 主机：Mac Mini 2（M2 Pro、32GB RAM、1TB SSD） 桌面配件： 屏幕支架 屏幕挂灯 桌垫 Mini 支架 音响 装饰玩具 image 购入新机后的第一步 当然是环境迁移啦，因为手动设备是公司电脑，出于安全考虑 不要用迁移助手，应手动迁移。 正文系统环境配置系统设置 Apple ID 登录并同步设置 声音 提醒声音设置为 Breeze 通用 修改设备名称 更新系统到最新版本 关闭所有共享功能 隔空投送与接力设置为”没有人”或”仅当前用户” 外观 始终显示滚动条 点击滚动条时跳转到点击位置 控制中心 仅保留 WiFi、蓝牙、声音的快速访问 隐私与安全性 关闭定位服务 显示器 调整至合适的缩放率（在保证清晰度的前提下最大化显示内容） 墙纸 根据个人喜好设置 锁定屏幕 屏保时间：10 分钟 关闭显示器：20 分钟 取消登录密码要求 桌面与程序坞 调整大小和放大效果 最小化效果：神奇效果 打开应用时弹跳 连按窗口标题栏：缩放 最小化窗口至应用图标 自动隐藏和显示程序坞 菜单栏：自动隐藏，最多显示 10 个项目 启用最近使用的应用程序 文档打开偏好：全屏视图 关闭台前调度 调度中心设置： 根据使用情况重新排列 应用切换不自动切换空间 启用程序分组 显示器使用独立空间 禁用所有触发角 设备设置键盘设置： 将重复速率调至最快 重复前延迟调至最短 启用键盘导航 Fn 键无操作 快捷键： 仅保留调度中心为 Option + Esc 其他全部取消 触控板设置： 启用三指拖动功能 根据个人习惯调整手势 Finder 设置 自定义工具栏 显示所有文件扩展名 显示状态栏 设置默认视图偏好 软件安装与配置浏览器Chrome： 必备扩展： Bitwarden（密码管理） 关闭超时 配置 PIN 码登录 Cubox（稍后读） 沉浸式翻译 Ad blocker Arc： 快捷键配置： C + D：复制链接 C + T：快捷栏 Tab：命令模式 输入法 仅保留 ABC 与搜狗输入法 登录并同步设置 开启所有模糊音 使用 Boundary 主题 配置 F15 为切换上一个输入法 配置 ABC 输入法 效率工具 Ice（窗口管理） brew install jordanbaird-ice Snipaste（截图工具） Manico（应用快速启动） Hammerspoon（自动化工具） brew install hammerspoon --cask# 配置示例 option +s 打开软件的设置：hs.hotkey.bind({ \"alt\" }, \"s\", function() hs.eventtap.keyStroke({ \"cmd\" }, \",\")end) PasteNow（剪贴板管理） AltTab（窗口切换） Flux（护眼工具） Keycastr（按键显示） brew install --cask keycastr Applite（应用管理） brew install --cask applite Input Source Pro（输入法管理） 开发工具 VSCode Cursor Goland Warp Postman Ideavimrc 配置： 点击显/隐源文件 \" ==================================================\" 配置篇\" ==================================================\" 语法高亮syntax on\" 关闭自动折行set nowrap\" 横向滚动一次 40 个字符,set sidescroll=40\" 垂直滚动时，光标距离顶部/底部的位置（单位：行）set scrolloff=5\" 水平滚动时，光标距离行首或行尾的位置（单位：字符）。该配置在不折行时比较有用set sidescrolloff=15\" 不创建备份文件set noback\" 搜索时，高亮显示匹配结果\" set hlsearch\" 输入搜索模式时，每输入一个字符，就自动跳到第一个匹配的结果set incsearch\" 搜索时忽略大小写set ignorecase\" 如果同时打开了 ignorecase，那么对于只有一个大写字母的搜索词，将大小写敏感\" 其他情况都是大小写不敏感。比如，搜索 Test 时，将不匹配 test；搜索 test 时，将匹配 Testset smartcase\" 不与 Vi 兼容（采用 Vim 自己的操作命令）set nocompatible\" 在状态栏显示光标的当前位置（位于哪一行哪一列）set ruler\" 显示光标所在的当前行的行号，其他行都为相对于该行的相对行号set relativenumber\" 显示行号set number\" 光标所在的当前行高亮set cursorline\" 是否显示状态栏。0 表示不显示，1 表示只在多窗口时显示，2 表示显示set laststatus=2\" 命令模式下，在底部显示，当前键入的指令set showcmd\" 光标遇到圆括号、方括号、大括号时，自动高亮对应的另一个圆括号、方括号和大括号set showmatch\" 在底部显示，当前处于命令模式还是插入模式set showmode\" Vim 需要记住多少次历史操作set history=1000\" 与系统共用剪切板set clipboard+=unnamedset clipboard+=ideaput\" 打开文件监视。如果在编辑过程中文件发生外部改变（比如被别的编辑器编辑了），就会发出提示set autoread\" 支持使用鼠标set mouse=a\" Tab 转为多少个空格set softtabstop=2\" 按下回车键后，下一行的缩进会自动跟上一行的缩进保持一致set autoindent\" 出错时，不要发出响声set noerrorbells\" 允许退格键在以下场景下正常执行set backspace=indent,eol,start\" ==================================================\" 插件篇\" ==================================================\" {action}s{surround symbol} {target symbol}set surround\" {action}ae -&gt; {action}entire-contentset textobj-entire\" auto switch input modelset keep-english-in-normal\" ==================================================\" 映射篇\" ==================================================\" 禁用 esc 键\" inoremap &lt;esc&gt; &lt;nop&gt;\" 禁用方向键\"noremap &lt;up&gt; &lt;nop&gt;\"noremap &lt;down&gt; &lt;nop&gt;\"noremap &lt;left&gt; &lt;nop&gt;\"noremap &lt;right&gt; &lt;nop&gt;\" j k 映射成 gj gknnoremap k gknnoremap j gj\" 进入 insert model 快捷键inoremap jk &lt;Esc&gt;inoremap jj &lt;Esc&gt;\" L 移动到行尾noremap L $\" H 移动到行首noremap H ^\" 设置 x c d action 的寄存器不与系统进行交互nnoremap x \"xxxnoremap x \"xxnnoremap X \"xXxnoremap X \"xXnnoremap c \"ccxnoremap c \"ccnnoremap C \"cCxnoremap C \"cCnnoremap d \"ddvnoremap d \"ddvnoremap D \"dDnnoremap D \"dD\" 移动时 自动定位到屏幕中心noremap j jzznoremap k kzznoremap G Gzznoremap { {zznoremap } }zznoremap [{ [{zznoremap ]} ]}zz\" 使用 Ctrl + j/k 可以滚动屏幕\" nnoremap &lt;C-K&gt; :action EditorScrollUp&lt;CR&gt;\" nnoremap &lt;C-J&gt; :action EditorScrollDown&lt;CR&gt;\" shift+arrow selectionnmap &lt;S-Up&gt; v&lt;Up&gt;nmap &lt;S-Down&gt; v&lt;Down&gt;nmap &lt;S-Left&gt; v&lt;Left&gt;nmap &lt;S-Right&gt; v&lt;Right&gt;vmap &lt;S-Up&gt; &lt;Up&gt;vmap &lt;S-Down&gt; &lt;Down&gt;vmap &lt;S-Left&gt; &lt;Left&gt;vmap &lt;S-Right&gt; &lt;Right&gt;imap &lt;S-Up&gt; &lt;Esc&gt;v&lt;Up&gt;imap &lt;S-Down&gt; &lt;Esc&gt;v&lt;Down&gt;imap &lt;S-Left&gt; &lt;Esc&gt;v&lt;Left&gt;imap &lt;S-Right&gt; &lt;Esc&gt;v&lt;Right&gt;\" ==================================================\" Leader 键篇\" ==================================================let mapleader=' '\" 多窗口操作\" 清除窗口nnoremap &lt;Leader&gt;wq &lt;C-W&gt;c\" 光标窗口切换nnoremap &lt;Leader&gt;ww &lt;C-W&gt;wnnoremap &lt;Leader&gt;wj &lt;C-W&gt;jnnoremap &lt;Leader&gt;wk &lt;C-W&gt;knnoremap &lt;Leader&gt;wh &lt;C-W&gt;hnnoremap &lt;Leader&gt;wl &lt;C-W&gt;l\" 纵向新增窗口nnoremap &lt;Leader&gt;ws &lt;C-W&gt;s\" 横向新增窗口nnoremap &lt;Leader&gt;we &lt;C-W&gt;vnnoremap &lt;Leader&gt;` :action SplitVertically&lt;CR&gt;\" v 列选择nnoremap &lt;Leader&gt;v &lt;C-V&gt;\" hl 前进后退nnoremap &lt;Leader&gt;h :action Back&lt;CR&gt;nnoremap &lt;Leader&gt;l :action Forward&lt;CR&gt;\" H 替换文本nnoremap &lt;Leader&gt;H :action Replace&lt;CR&gt;\" jk 错误定位nnoremap &lt;Leader&gt;k :action GotoPreviousError&lt;CR&gt;nnoremap &lt;Leader&gt;j :action GotoNextError&lt;CR&gt;\" 最近文件, 最近位置 列表显示nnoremap &lt;Leader&gt;e :action RecentFiles&lt;CR&gt;nnoremap &lt;Leader&gt;E :action RecentLocations&lt;CR&gt;\" 书签操作nnoremap &lt;Leader&gt;q :action ToggleBookmark&lt;CR&gt;nnoremap &lt;Leader&gt;Q :action ShowBookmarks&lt;CR&gt;\" 注释与重命名nnoremap &lt;Leader&gt;r :action CommentByLineComment&lt;CR&gt;nnoremap &lt;Leader&gt;R :action RenameElement&lt;CR&gt;\" 跳转到定位nnoremap &lt;Leader&gt;d :action GotoDeclaration&lt;CR&gt;\" 查看使用案例nnoremap &lt;Leader&gt;D :action FindUsages&lt;CR&gt;\" 展示错误信息nnoremap &lt;Leader&gt;a :action ShowErrorDescription&lt;CR&gt;\" 展示文件内的大纲nnoremap &lt;Leader&gt;o :action FileStructurePopup&lt;CR&gt;\" 使用 ESLint 格式化代码nnoremap &lt;Leader&gt;t :action Javascript.Linters.EsLint.Fix&lt;CR&gt;\" 格式化代码nnoremap &lt;Leader&gt;T :action ReformatCode&lt;CR&gt;\" 展示文件路径 可以快速打 Finder 中打开nnoremap &lt;Leader&gt;F :action ShowFilePath&lt;CR&gt;\" 切换断点nnoremap &lt;Leader&gt;b :action ToggleLineBreakpoint&lt;CR&gt;\" 聚焦项目栏nnoremap &lt;Leader&gt;\\ :action SelectInProjectView&lt;CR&gt;\" 显示隐藏 Todo Listnnoremap &lt;Leader&gt;A :action ActivateTODOToolWindow&lt;CR&gt;\" 显示隐藏 Git Panelnnoremap &lt;Leader&gt;g :action ActivateVersionControlToolWindow&lt;CR&gt;\" 隐藏激活面板nnoremap &lt;Leader&gt;z :action HideActiveWindow&lt;CR&gt;\" 应用建议nnoremap &lt;Leader&gt;s :action ShowIntentionActions&lt;CR&gt;\" 数字加减nnoremap &lt;Leader&gt;- &lt;C-x&gt;nnoremap &lt;Leader&gt;= &lt;C-a&gt;\" 主题列表nnoremap &lt;Leader&gt;1 :action ChangeLaf&lt;CR&gt;\" Reload .ideavimrcnnoremap &lt;Leader&gt;S :source ~/.ideavimrc&lt;CR&gt; 常用软件 微信 飞书 Telegram 网易云音乐 编辑器配置Vim/Neovim： 安装 # 安装 Vim（可选）brew install vim# 安装 Neovimbrew install neovim# 安装 LazyVim（可选）git clone https://github.com/LazyVim/starter ~/.config/nvimrm -rf ~/.config/nvim/.git Vim 配置 点击显/隐源文件 \" ==================================================\" 配置篇\" ==================================================\" 语法高亮syntax on\" 关闭自动折行set nowrap\" 横向滚动一次 40 个字符set sidescroll=40\" 垂直滚动时，光标距离顶部/底部的位置（单位：行）set scrolloff=5\" 水平滚动时，光标距离行首或行尾的位置（单位：字符）set sidescrolloff=15\" 搜索时，高亮显示匹配结果\" set hlsearch\" 输入搜索模式时，每输入一个字符，就自动跳到第一个匹配的结果set incsearch\" 搜索时忽略大小写set ignorecase\" 如果同时打开了 ignorecase，那么对于只有一个大写字母的搜索词，将大小写敏感set smartcase\" 不与 Vi 兼容（采用 Vim 自己的操作命令）set nocompatible\" 显示行号和当前位置set rulerset relativenumberset numberset cursorlineset laststatus=2set showcmdset showmatchset showmode\" 历史记录和剪贴板set history=1000set clipboard+=unnamed\" 其他设置set autoreadset mouse=set softtabstop=2set autoindentset noerrorbellsset backspace=indent,eol,start 编程语言环境 Rust 环境 # 安装 rustupbrew install rustup# 初始化rustup-init# 验证安装rustc -V Python 环境 brew install pyenvecho 'export PYENV_ROOT=\"$HOME/.pyenv\"' &gt;&gt; ~/.zshrcecho 'command -v pyenv &gt;/dev/null || export PATH=\"$PYENV_ROOT/bin:$PATH\"' &gt;&gt; ~/.zshrcecho 'eval \"$(pyenv init -)\"' &gt;&gt; ~/.zshrcpyenv install 2.7.9pyenv install 3.11 Go 环境 bash &lt; &lt;(curl -s -S -L https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer)source ~/.gvm/scripts/gvmgvm listallgvm install go1.20.4gvm use go1.20.4 --default Java 环境 curl -s \"https://get.sdkman.io\" | bashsource \"~/.sdkman/bin/sdkman-init.sh\"sdk install java 命令行工具增强 zoxide（目录快速跳转） brew install zoxide# 在 .zshrc 中添加eval \"$(zoxide init zsh --cmd cd)\" fd（文件查找） brew install fd fzf（模糊查找） brew install fzf$(brew --prefix)/opt/fzf/install bat（文件查看） brew install bat dust（磁盘空间分析） brew install dust eza（ls 替代） brew install eza bottom（系统监控） brew install bottom broot（文件浏览） brew install broot difftastic（代码比较） brew install difftasticgit config --global diff.external difft jq（JSON 处理） brew install jq httpie（HTTP 客户端） brew install httpie the_silver_searcher（代码搜索） brew install the_silver_searcher ouch（解压缩工具） brew install ouch Shell 配置ZSH 插件： 必备插件 # zsh-autosuggestionsgit clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions# fast-syntax-highlightinggit clone https://github.com/zdharma-continuum/fast-syntax-highlighting.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/plugins/fast-syntax-highlighting# you-should-usegit clone https://github.com/MichaelAquilina/zsh-you-should-use.git $ZSH_CUSTOM/plugins/you-should-use# git-opengit clone https://github.com/paulirish/git-open.git $ZSH_CUSTOM/plugins/git-open# zsh-vi-modegit clone https://github.com/jeffreytse/zsh-vi-mode $ZSH/custom/plugins/zsh-vi-mode# zsh-completionsgit clone https://github.com/zsh-users/zsh-completions ${ZSH_CUSTOM:=~/.oh-my-zsh/custom}/plugins/zsh-completions# history-substring-searchgit clone https://github.com/zsh-users/zsh-history-substring-search ${ZSH_CUSTOM:=~/.oh-my-zsh/custom}/plugins/zsh-history-substring-search# fzf-tabgit clone https://github.com/Aloxaf/fzf-tab ${ZSH_CUSTOM:=~/.oh-my-zsh/custom}/plugins/fzf-tab 插件配置 plugins=( zsh-autosuggestions fast-syntax-highlighting command-not-found you-should-use git-open vi-mode zsh-vi-mode sudo zsh-completions history-substring-search fzf-tab) ZSH 配置： 点击显/隐源文件 # 用户设置DEFAULT_USER=majinexport USER=majin# 基础配置export ZSH=\"$HOME/.oh-my-zsh\"export LANGUAGE=en_US.UTF-8export EDITOR='code'# 历史记录HIST_STAMPS=\"yyyy-mm-dd\"HISTFILE=~/.zsh_historySAVEHIST=10000000# 环境变量export PATH=/usr/bin:$PATHexport PNPM_HOME=\"$HOME/Library/pnpm\"export PATH=\"$PNPM_HOME:$PATH\"export GOPATH=$HOME/goexport PATH=$PATH:$GOPATH/bin# 代理设置export https_proxy=http://127.0.0.1:7897 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:7897# Shell 选项setopt no_beepsetopt LOCAL_OPTIONSsetopt LOCAL_TRAPSsetopt no_flow_controlsetopt transient_rpromptsetopt HIST_REDUCE_BLANKS# 历史记录选项setopt EXTENDED_HISTORYsetopt INC_APPEND_HISTORYsetopt SHARE_HISTORYsetopt HIST_EXPIRE_DUPS_FIRSTsetopt HIST_IGNORE_DUPSsetopt HIST_IGNORE_ALL_DUPSsetopt HIST_FIND_NO_DUPSsetopt HIST_IGNORE_SPACEsetopt HIST_SAVE_NO_DUPSsetopt HIST_VERIFYsetopt APPEND_HISTORYsetopt HIST_NO_STORE# 其他选项setopt prompt_substsetopt CORRECTsetopt complete_in_wordsetopt IGNORE_EOF# VI 模式设置ZVM_VI_INSERT_ESCAPE_BINDKEY=jj# 按键绑定bindkey \"^[[A\" history-substring-search-upbindkey \"^[[B\" history-substring-search-downbindkey '\\e[A' history-substring-search-upbindkey '\\e[B' history-substring-search-downbindkey '\\eOA' history-substring-search-upbindkey '\\eOB' history-substring-search-down# FZF 配置export FZF_PREVIEW_COMMAND=\"([[ -f {} ]] &amp;&amp; (bat --style=numbers --color=always {} || cat {})) || ([[ -d {} ]] &amp;&amp; (tree -C {} | less)) || echo {} 2&gt; /dev/null | head -200\"export FZF_DEFAULT_OPTS=\"--multi --cycle --inline-info --ansi --border --layout=default --height 80% --no-reverse --preview-window=:hidden --bind '?:toggle-preview'\"export FZF_DEFAULT_COMMAND=\"ag --ignore-dir .git --ignore-dir .idea --ignore-dir .vscode --ignore-dir node_modules --ignore-dir pkg --ignore-dir bin --ignore-dir github.com --ignore-dir dist -g ''\"export FZF_CTRL_T_COMMAND=\"$FZF_DEFAULT_OPTS\"export FZF_CTRL_R_OPTS=\"$FZF_DEFAULT_OPTS\"# FZF-TAB 样式zstyle ':fzf-tab:complete:kill:argument-rest' fzf-flags '--preview-window=down:3:wrap'zstyle ':fzf-tab:complete:kill:argument-rest' fzf-preview 'ps --pid=$word -o cmd --no-headers -w -w'zstyle ':fzf-tab:complete:kill:*' popup-pad 0 3zstyle ':fzf-tab:complete:cd:*' fzf-preview 'eza -1 --color=always $realpath'zstyle ':fzf-tab:complete:cd:*' popup-pad 30 0zstyle \":fzf-tab:*\" fzf-flags --color=bg+:23zstyle ':fzf-tab:*' fzf-command ftb-tmux-popupzstyle ':fzf-tab:*' switch-group ',' '.'zstyle ':fzf-tab:*' fzf-preview '([[ -f $realpath ]] &amp;&amp; (bat --style=numbers --color=always $realpath || cat $realpath)) || ([[ -d $realpath ]] &amp;&amp; (tree -C $realpath | less)) || echo $realpath 2&gt; /dev/null | head -200'# 补全样式zstyle ':completion:*' list-colors ${(s.:.)LS_COLORS}zstyle \":completion:*:git-checkout:*\" sort falsezstyle ':completion:*' file-sort modificationzstyle ':completion:files' sort falsezstyle ':completion:*:eza' sort false# 别名设置alias cat='bat --paging=never'alias du='dust'alias vim='nvim'alias ls=\"eza\"alias mkdir='mkdir -pv'alias cp='cp -i'alias rm='rm -i'alias mv='mv -i'alias cls='clear'alias extract='ouch'alias ss=\"br\"alias diff=\"difft\"alias bi=\"brew install\"alias bs=\"brew search\"alias python='python3'alias gs='git status'alias gc='git checkout'alias log=\"git log --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit --date=relative --graph --decorate\"alias ..='cd ..'alias ...='cd ../..'alias ....='cd ../../..'alias .....='cd ../../../..'alias ~=\"cd ~\"alias -- -=\"cd -\"alias config='code ~/.zshrc'alias reload='source ~/.zshrc'alias nc='rm -rf node_modules &amp;&amp; rm -rf {package-lock.json,yarn.lock,pnpm-lock.yaml}'alias kp=\"kill-port\"# 文件类型关联alias -s {html,css,js}=codealias -s git=\"git clone --depth 1\"# 自定义函数function copy() { pbcopy &lt; $1}# 工具初始化eval \"$(zoxide init zsh --cmd cd)\"source $HOME/.config/broot/launcher/bash/breval \"$(fnm env --use-on-cd)\"[ -f ~/.fzf.zsh ] &amp;&amp; source ~/.fzf.zshexport PATH=\"/opt/homebrew/bin:$PATH\" 字体配置 编程字体 brew install font-robotobrew install font-fira-codebrew install font-jetbrains-monobrew install font-source-code-pro Nerd Font brew tap homebrew/cask-fontsbrew install font-jetbrains-mono-nerd-font font-fira-code-nerd-font 系统优化管理员权限配置管理员权限配置： # 编辑 sudoers 文件sudo vim /etc/sudoers# 修改配置%admin ALL = (ALL) NOPASSWD: ALL 系统调优系统调优： # 默认保存到本地而非 iClouddefaults write NSGlobalDomain NSDocumentSaveNewDocumentsToCloud -bool false# 显示隐藏文件defaults write com.apple.Finder AppleShowAllFiles -bool true# 扩展保存面板defaults write NSGlobalDomain NSNavPanelExpandedStateForSaveMode -bool truedefaults write NSGlobalDomain PMPrintingExpandedStateForPrint -bool true# 显示控制字符defaults write NSGlobalDomain NSTextShowsControlCharacters -bool true# 清理\"打开方式\"菜单/System/Library/Frameworks/CoreServices.framework/Frameworks/LaunchServices.framework/Support/lsregister -kill -r -domain local -domain system -domain user# 禁用自动启动照片应用defaults -currentHost write com.apple.ImageCapture disableHotPlug -bool true 按键映射按键映射： 将 Capslock 映射为 F15： 创建文件：~/Library/LaunchAgents/com.tomotoes.CapslockF15.plist&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt;&lt;plist version=\"1.0\"&gt; &lt;dict&gt; &lt;key&gt;Label&lt;/key&gt; &lt;string&gt;com.tomotoes.CapslockF15&lt;/string&gt; &lt;key&gt;ProgramArguments&lt;/key&gt; &lt;array&gt; &lt;string&gt;/usr/bin/hidutil&lt;/string&gt; &lt;string&gt;property&lt;/string&gt; &lt;string&gt;--set&lt;/string&gt; &lt;string&gt;{\"UserKeyMapping\":[{\"HIDKeyboardModifierMappingSrc\":0x700000039,\"HIDKeyboardModifierMappingDst\":0x70000006A}]}&lt;/string&gt; &lt;/array&gt; &lt;key&gt;RunAtLoad&lt;/key&gt; &lt;true/&gt; &lt;/dict&gt;&lt;/plist&gt; 结语参考： Mac Setup for Web Development New Mac Setup 2021 Setting up a Brand New Mac for Development Awesome Alternatives in Rust 本文详细记录了我从公司 MacBook 迁移到个人 Mac Mini 的全过程。无论你是刚入手 Mac，还是想优化现有的开发环境，相信这篇文章都能为你提供有价值的参考。 欢迎转载本站文章，请注明作者和出处 SimonAKing。","categories":[{"name":"设备","slug":"设备","permalink":"https://simonaking.com/blog/categories/%E8%AE%BE%E5%A4%87/"}],"tags":[{"name":"MacOS","slug":"MacOS","permalink":"https://simonaking.com/blog/tags/MacOS/"},{"name":"设备","slug":"设备","permalink":"https://simonaking.com/blog/tags/%E8%AE%BE%E5%A4%87/"}]},{"title":"我的 Newsletter 精选清单","date":"2022-12-03T07:30:40.000Z","path":"/newsletter/","text":"Newsletter 是一类去平台化的信息源，能让自己重新掌握信息消费的主动权。 前言作为我重要的输入源，Newsletter 已伴随我多年。不知不觉中，我已积累了一些自认为的高质信息源，这些信息大致可以分为技术主题与科技人文主题两大类。 在这篇文章中，我将分享这些信息源与其订阅方式，希望能对你有所帮助。 如果你也有推荐的 newsletter，欢迎补充到 issue 中。同时也可以看看 我的 newsletter - 思考的价值 是不是你想要的菜~（暂无精力更新） 正文为了更好地使用 Newsletter 资源，这里有一些实用的建议： 追踪更新：当我新增订阅时会同步更新该仓库，为了更方便获取更新，建议开启 GitHub 仓库的 Watch 功能。 邮箱管理：建议新申请一个专门的邮箱用来消费信息，这样可以避免信息混淆，保持收件箱的整洁。 邮件客户端：关于邮件客户端的选择可以很自由。虽然市场上已经有一些专门为了阅读体验设计的产品，但在尝试多个之后，我依然选择回归 Gmail，它的功能足够满足需求。 平台通知：对于文中提到的平台或仓库，建议将其通知设置为邮件通知，以便统一管理和阅读。 RSS 转换：对于文中提到的 RSS 链接，可以使用 FollowIt 服务将其转换为邮件更新形式，实现统一的阅读体验。 AI 相关 AHEAD OF AI a16z Latent Space 技术向 BestBlogs JavaScript Weekly Golang Weekly Node Weekly Hacker Newsletter StackShare Weekly Web Tools Fronted Focus React Status React newsletter ByteByteGo PyCoder’s Weekly Bytes newsletter ES.next News Hacker News Digest Smashing Magazine InfoQ C# Digest Console newsletter Haskell Weekly CSS Weekly CSS LAYOUT NEWS Elixir Weekly This Week in Rust Sidebar Thoughtworks Ping Programming Digest Fullstack Bulletin The New Stack Perf.email by Calibre Stack overflow WDRL by Anselm Hannemann Web.dev Mads Brodt Mozilla Medium Daily Digest The Awesome JavaScript Weekly The Awesome Node.js Weekly The Awesome .NET Weekly The Awesome Go Weekly The Awesome Java Weekly The Awesome Rust Weekly The Awesome Swift Weekly The Awesome Python Weekly The Awesome Kotlin Weekly The Awesome Android Weekly The Awesome C++ Weekly The Awesome React Weekly The Awesome Scala Weekly Tech Lead Digest 微咸 Devops Builtin dayily.dev Architecture Weekly Found Pan Tiger Weekly joshwcomeau 前端食堂 前端技术栈周刊 iOS-Weekly FE news 开发者简报 Bytes by Alfred Android Weekly Android Weekly Found Pan Tiger Weekly Serverless Status Python Weekly Data Science Weekly Graphics Programming weekly Awesome Self Hosted Weekly 机器文摘 WebRTC Weekly developer tip Weekend Reading Pony Foo Weekly JAMstacked codrops JSter Pointer Kotlin Weekly Unzip.dev Changelog Better Dev Link Shift Security Left VSCode.Email architecture notes Unreadit frontend Alyssa X lobsters-daily prateeksurana Webweekly 奇舞周刊 newsletter of codedump 的网络日志 VimTricks lcomplete 面向信仰编程 鸟窝 DEV Community Digest - 将 dev 社区的动态更新设置为邮件通知。 headllines/github-daily headllines/hackernews-daily - Watch 仓库，将 github 的通知设置为邮件方式。 Latest and Greatest 科技人文向 垠的备忘录 YC’s Newsletter 湾区日报 - 已停止更新 Product Hunt Daily Steve 说每周通讯 Founder Weekly DEX 周刊 Daniel Miessler The sunday digest Quora Digest 语雀 Platform Thinking+ tinyprojects 好工具周刊 GeekPlux Lab Design Scenes Weekly 产品鸭 DecoHack 周刊 独立开发变现周刊 龙爪槐守望者 地心引力 在诗外 The Quibbler Manjusaka 碎碎念 MonoGoto 可乐周报 啰里啰唆 Chasing Rabbbits prototypr Dense Discovery Workspace Chinese Characteristics Jiayuan Thoughts 生活奇旅 Dine News 察说花园 The 3-2-1 Newsletter 光明王 草稿拾遗 一人杂志 太隐 唯理通讯 维舟 Juicing Today 逆流 Upstream BLUE·周刊 Sustainable Curiosity 播客相对论 创投止观舍 漫无目的 知更鸟文档 本夜朽舎 显济的闲言碎语 Shyrism.News zerotomarketing No-Code Shots Unreadit - tech Unreadit Indie Makers 阮一峰 陈皓 老胡周刊 潮流周刊 BMPI.dev - 暂时无法订阅 导航站 &amp; 个人分享 Tony Dinh’s Newsletter hedwig NEWSLETTEREST AlleyRead 小报童精选 Design Newsletters geekplux 老师的 newsletter 中文 Newsletter 导航 咖啡吧导航 Newsletter-list Email-newsletter-RSS awesome-newsletters 竹白专栏检索 竹白百科 结束语Newsletter 的价值在于它能让我们跳出算法推荐的信息茧房，主动获取高质量的信息源。希望这份清单能帮助你找到适合自己的信息源，构建属于自己的信息消费体系。 欢迎转载本站文章，请注明作者和出处 SimonAKing。","categories":[{"name":"知识管理","slug":"知识管理","permalink":"https://simonaking.com/blog/categories/%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"Newsletter","slug":"Newsletter","permalink":"https://simonaking.com/blog/tags/Newsletter/"},{"name":"知识管理","slug":"知识管理","permalink":"https://simonaking.com/blog/tags/%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/"}]},{"title":"浅谈搭建平台-画布篇","date":"2022-11-10T17:40:53.000Z","path":"/canvas/","text":"搭建平台本身也是一款软件，它更注重于“复用与组合”，而非实际的业务逻辑。 前言近些年搭建平台变得很是流行，它提供了一种全新的开发方式，同时大幅降低了使用者的门槛，解决了企业的两大痛点：开发效率与人员转型。 搭建平台由编辑器（画布+设置器）和生成器组成，本文将重点介绍画布，分为架构设计与画布设计两个章节来展开。 正文什么是搭建平台在介绍搭建平台之前，有一个无法绕过的主题，那就是 NCLC（No Code &amp; Low Code）。NCLC 作为建站产品背后的核心概念，推动了一波又一波的技术浪潮。 近些年围绕 NCLC 踊跃出了不同形态的产品，如项目管理 Meego、低代码系统 Retool、在线文档 Notion 等，甚至还有人将 NCLC 细分为了 12 个发展赛道。 image 图片来源：https://pinver.medium.com/decoding-the-no-code-low-code-startup-universe-and-its-players-4b5e0221d58b 其中业界内发展最为迅猛、最有代表性的产品形态莫过于 建站类。 关于建站类，相信大家都能说出一些耳熟能详的产品，如早期的 Dreamweaver、获取上亿投资的 SaaS Webflow 以及 国内的各个大厂的搭建平台等。 搭建平台之所以如此流行，原因不外乎于解决了企业的两大痛点：开发效率与人员转型。 开发效率： 搭建平台本身也是一款软件，与常见的 IDE 相比，都是为提高生产力服务；不同的是，它更注重于“复用与组合”，而非实际的业务逻辑。通俗来说，用组件拖拽与配置 代替了 传统的编程开发。 想象一下，我们需要开发一款海报形态的活动页面，必不可少的需要堆图片、堆动效，如果走传统的编程可能会花费数天。而如果走搭建，只需生成一次物料，拖拽并配置物料 就搞定了。 简而言之，搭建平台提供了一种全新的开发方式。面向特定场景下，开发的复杂度可以很好地被掩盖。如 电商活动、营销宣传、中后台等。 人员转型： 在日新月异的市场中，数字化转型获得了很多企业的一致认可，其中 NCLC 作为人员数字化背后的核心概念，允许企业员工在没有编程经验的情况下构建应用。 在搭建平台的用户中，除了研发同学，更常见的用户是没有编程技能的运营同学，ta 们通过搭建的方式生成所需的活动页面，在没有研发参与的情况下，真正按照自己的想法去实现。 搭建平台大幅降低了使用者的门槛，避免浪费过多的开发资源，进一步提升了 企业中的流程效率。 相信大家对搭建平台已经有一定的了解了，那么搭建平台由哪些概念组成呢？ 衍生概念在发展的过程中，搭建平台 衍生出了众多的概念，让人望而却步，但核心可以用一句话来概括： 搭建平台 = 编辑器（画布+设置器）+ 生成器，而这些实体的数据源是物料，实体间遵循的通信协议是 UIDL。 编辑器与生成器独立通过 UIDL 解耦，做到 搭建的页面类型 只与使用的物料相关。 编辑器 只负责前端技术栈物料的渲染，生产出 UIDL 规范。 生成器 消费 UIDL，再根据约定好的模板项目，生产出页面。 该设计属于典型的分层架构，将系统分成若干个水平层，每一层都有清晰的角色和分工，不需要知道其他层的细节，层与层之间通过接口 &amp; 协议通信。 因为篇幅原因，本文的重心是 画布，分为架构设计与画布设计 两个章节来展开，设置器、生成器 可期待后续系列。 image-20221111122204604 架构设计该 part 介绍了 搭建平台中 核心的架构设计。 IOC 架构各个功能模块之间会以 IOC 架构进行依赖耦合，具体来说 每个模块都需定义使用规范，统一在入口进行模块之间的注入绑定。 这意味着模块之间的依赖关系由容器在运行期决定。该设计优势在于功能模块之间的依赖以规范为主，不关心具体的实现；并且功能模块之间可以独立迭代，利于后续扩展。 举个例子： 每一种类型的终端会有独立的物料区、生成器的模板，以及相同的画布功能模块，在使用 IOC 架构之后，功能模块会以 底层基座 加扩展模块的方式进行聚合，如 TV 端画布与 移动端画布的明显差别在于画布分辨率、组件的选中态（TV 端存在焦点的概念），而这些差别 与 画布是附加的关系。 如此设计的好处是当出现新的终端时，可以快速适配。 总的来说，IOC 架构是一种可模块和可扩展的设计方案，让整个系统更加可插件化。 延伸阅读：InversifyJS 的最佳实践。 编辑渲染分层用户搭建时需要在组件上渲染出各种交互态，这些状态不能直接与组件本身耦合。搭建平台会把画布进一步分为 渲染层与编辑层，彼此之间通过通信协议进行解耦。 image.png 编辑层本质上是画布中真实渲染的元素；渲染层则是在编辑层之上的一层蒙版，其中蒙版是由 与真实元素 相同大小定位的虚拟元素组成的。 当用户编辑页面时，会直接操作到编辑层的元素，而后续的交互 会在渲染层上进行。 举例：当用户选中组件时，被选中的组件位于编辑层；选中组件后会出现 8 个锚点，这些锚点是在渲染层中挂载的。 这种设计带来的优势非常明显： 可提效页面预览 预览页面时只需移除掉 画布编辑器的蒙版即可，真正的秒级预览。 便于画布的交互体验 组件的提示线、锚点只在渲染层中产出，不会影响编辑层的真实组件；并且当拖拽组件时 只需增删相应的渲染层组件即可。 真正的解耦设计 可枚举出画布编辑的规范与画布渲染的规范，梳理每一个行为与其所需的输入信息，让每一个行为都有足够详细的描述，真正做到分层解耦。 画布编辑规范主要用于梳理 画布上的编辑动作，大概形态如下： interface ComponentAddAction {}interface ComponentDragAction {}... 画布渲染规范用于梳理 画布上的渲染动作，大概形态如下： interface ComponentFocusRenderer {}interface ComponentMirrorRenderer {}... 业界中更激进的做法是将编辑与渲染通过 iframe 分层，具体来说是 渲染层是一个独立的路由，内嵌到编辑器中，编辑层会在渲染层之上建立一个等大小的蒙版。用户在操作画布时，蒙版会首先捕获用户的操作，再通过 iframe 的同源协议进行交互行为的通信，渲染层接收消息后实时做到响应。 通过 iframe 实现编辑渲染分层的好处有： 天然的沙盒化 因为 iframe 的天然隔离性，画布渲染器中的所有逻辑、样式不会影响编辑器本身。 利于多人编辑 单人编辑时使用 iframe 进行通信，而多人编辑时可将 iframe 通信切换成 WebSocket 通信，设计时有异曲同工之妙。 需要注意的是，如果想保障 编辑层与渲染层 相应组件之间的定位、大小相同，需要在 resize、scroll 事件中进行渲染层的重新渲染。 下文以画布代称编辑层与渲染层，不再做区分。 事件体系事件体系是进一步解耦的设计方案，编辑器中会建设一套完善的事件体系，对应着每个编辑动作、渲染动作、全局动作的生命周期或者具体的回调动作。 每个功能模块都可消费相应的事件。 image.png 如此设计的好处是利于扩展，当添加新 feature 时，可以很容易地通过挂载事件来做到。 针对事件体系，举两个典型案例： 当 页面加载时 会触发 init 事件，平台上的不同功能模块消费该事件：侧边栏加载物料、画布渲染 Schema、物料管理 加载基础依赖等。 当 拖拽组件到画布时 会触发 dragEnd 事件，平台上的不同功能模块消费该事件：物料管理加载拖拽的物料，设置器解析渲染拖拽物料的设置规范、画布移除拖拽镜像等。 规范设计在平台实践时，切记两点： 围绕落地场景来设计产品思路，不可盲目堆功能。 规范先行，规范是贯穿编辑器的核心概念。 下文介绍两个重点规范：UIDL 规范 与 物料规范。 UIDL 规范 UIDL：用于描述 搭建页面时的所有与 UI 相关的可结构化信息。 UIDL 最初是由 teleporthq 公司提出： All user interfaces serve the same purpose: allow for an interaction between a human and a machine.Functionally speaking, the vocabulary of human-machine interaction is well defined. No matter the medium or the technology used behind it, a user interface will likely be built with a dozen atomic visual elements such as: titles, paragraphs, inputs, images, videos, links, buttons, etc., and a couple of meaningful compositions of these elements such as lists, tables, forms and menus.However, over time the number of channels has increased dramatically (web, mobile, tablets, tv, AR/VR) and the number of technologies used for each of those channels as well. This has resulted in an increased human time cost of building a user interface and distributing it to each channel while providing no extra value for the end user.This is why we have decided to search for a solution which would allow us to focus more on the what and worry less about the how.Like others before us, we decided to work on a universal format that could describe all the possible scenarios for a given user interface. This format allows us to:generate the same user interface with various tools and frameworkstransition from one code output to another without effortenable efficient and advanced programmatic manipulationWe have named our universal format \"User Interface Definition Language\" (UIDL). It is represented by a human-readable JSON document, a format supported natively by many programming languages. 摘录自：https://docs.teleporthq.io/guides/what-is-this.html#uidl 一般而言，UIDL 可由四部分组成： UIDL 元信息 项目元信息 页面 Schema 规范 使用的物料以及物料的配置 interface ComponentProps { id: string [key: string]: any}interface Schema { id: string type: MaterialId name: string children: Schema[] props: ComponentProp}interface UIDL { meta: { version: string // UIDL 元信息 } project: { // 项目元信息 id: string title: string version: string author: User url: string } schema: Schema // 页面 Schema 规范 materials: { // 使用的物料及其配置 components: Array&lt;Component&gt; }} 物料规范 物料：用于描述 搭建页面时所需的组件等一系列可丰富页面功能、样式的实体。 一个物料有多种属性，每一个属性都可成为分类的条件。 终端划分：移动端 Web、小程序、TV 端… 形态划分：组件、插件、动作 功能划分：基础组件、容器组件、玩法组件… 其中终端、业务线 是物料外在的属性，形态、功能 是物料内在的属性。 我们在确定一个具体物料时，会首先通过物料的外在属性过滤出当前页面上可用的物料，然后再通过物料的内在属性 明确应该使用的物料，所以在设计物料标识时也应尽可能的体现出关键的属性。 画布设计该 part 介绍了画布中的核心难点 以及 对应的实现方案。 为了让大家更好地理解文章脉络，我们举一个页面生产的案例： 有个男人叫小帅（请自行脑补），他接到了某活动的需求，需要产出一个宣传页面，页面的大概样子如下： image.png 于是他开始打开某搭建平台，首先从物料区拖拽了三个组件：图片、文本、按钮，并按照设计格式放置好。 然后他开始进行各个组件的配置，图片组件上传设计图，文本组件配置介绍文案，按钮组件配置跳转链接。 配置完成后，他开始了活动发布，等待发布完成后，得到了一个可投放的页面链接，到此 任务完成。 来自一个真实的案例： image 根据小帅的操作过程，我们不难得到以下关键流程： 生成页面 = (1)添加组件 - (2)拖拽组件 - (3)选择组件 - (3)配置组件（设置器）- (4)活动发布（生成器）。 因为文章篇幅，设置器、生成器 本文暂不展开，可期待后续系列。 其中前三个核心环节均是在画布中完成的，那么这些核心环节的背后发生了什么呢？ 添加组件添加组件的核心 有两点： 组件的产物加载到搭建平台 生成组件的 Schema Node，并在拖拽结束时 插入到 UIDL（下一章节） Schema 生成 当添加组件时，第一步是生成 组件的 Schema Node，为后续 UIDL 服务，生成时会解析当前组件设置器的规范，伪代码如下： genSchema(component: ComponentMaterial): Schema { const children: Schema[] = [] // TODO: 应该由 设置器中的 props 填充 const props = {} // TODO: 应该由 设置器中的默认样式填充 const styles: React.CSSProperties = SchemaService.defaultStyles return { id: this.genComponentId(), type: component.id, name: component.name, props, children, styles } } 加载物料 用户第一次进入搭建平台时，是不可能直接加载所有物料资源的，物料一般是在使用时加载，这是因为物料是可扩展，加载所有物料 会导致搭建体验下降。 所以编辑器需要一种异步的物料加载方式，有利于渲染单页面资源 最优化。 打包规范 很明显，物料的加载方式是需要与打包类型 紧密配合的。 在 Web 的模块化发展中，出现了四种使用较广泛的类型：AMD、CJS、UMD、ESM，其中 UMD 是在 AMD、CJS 上层的兼容方案，就不展开了。 下面简单梳理了下各种模块化的优劣势与适用场景。 image-20221111131525099 现代前端模块化的发展趋势逐渐以 ESM 为主流，相比 AMD、CJS 有标准化组织支持，所以物料打包规范建议以 ESM 为目标。 加载物料 随着前端模块化的发展，模块加载方式也出现了一些更加成熟的解决方案，梳理如下： image-20221111131550407 综合来说，使用 systemJS 加载模块是个更好的选择，对现代打包工具有较好的支持，有一套规范可以实现复杂的依赖引用，而且还支持各种模块的规范。 依赖分析 除了加载物料本身还远远不够，物料在实现时会依赖很多通用的基础库、框架，如 按钮组件在 Web 端会依赖 React，具体依赖大概可分为以下三种类型： 基础框架、库：React、React-DOM 等 特定组件下所需的 框架、库：如 xg-player 依赖的其他组件：如 按钮列表组件 需要 按钮组件 这三种类型的依赖，如果每一个物料都打包的话，无疑会造成很大的物料体积冗余，从而进一步影响拖拽体验，所以需要根据不同类型做不同的打包优化处理。 基础框架、库：会作为公共依赖存在，物料打包时不会打包进该产物，该产物会直接内置在 搭建平台侧。注意 这些公共依赖 需要在物料侧统一版本。 特定组件下所需的 框架：会一起打包进物料，不进行处理。 依赖的其他组件：物料打包时，会检查当前物料依赖的其他物料，并声明在物料信息的某一字段中（如 dependencies），物料在加载时 会先加载 依赖所需的物料。注意 物料加载方式是深度优先的，会存在多层依赖的场景。 沙箱化 每个物料作为单独的可执行单元，运行在同一 runtime 中，为了避免互相相互影响，沙箱化机制是必不可少的，我们可以参考以下微前端的常见沙箱化手段。 根据 Web 的技术特性，沙箱可分为逻辑隔离与样式隔离。 逻辑隔离 逻辑隔离常见的方案有 Eval、Function 方案，其中 Eval 的安全性、性能与 Function 相比差距较大。 业界中常见的微前端框架 逻辑隔离是 通过代理 全局对象 实现，大概的逻辑如下： const varBox = {};const fakeWindow = new Proxy(window, { get(target, key) { // 敏感调用检查 return varBox[key] || window[key] }, set(target, key, value) { // 敏感调用检查 varBox[key] = value; return true; }})const fn = new Function('window', code);fn(fakeWindow); 样式隔离 样式隔离根据开发的层面也有不同的解决方案。 在开发层，可以尝试使用 style-components 或者 css-module 方案，打包出具有唯一样式的组件。 在构建层可以使用 Shadow Dom 包一层 或者在所有样式外 加一层组件类名。 let elementRef = document.querySelect('#sub-app');let shadow = elementRef.attachShadow({mode: 'open'}); 结束语 到此，添加组件已完成，回顾一下： 组件的 UIDL 已经生成完毕 组件的资源已经被加载到了搭建平台。 拖拽组件拖拽组件属于画布中的核心难点，该 part 将尽可能覆盖拖拽背后的技术难点。 拖拽库 在介绍拖拽之前，必不可少要做的是 拖拽事件的监听与拖拽信息的收集，业界中有很多库都做了或多或少的事情，如 Github 的 draggable topic。那么拖拽库又做了什么呢？ 组件在拖拽时，会根据时间周期分为三个阶段，每个阶段都应该提供不同的信息供外部消费： 拖拽开始 - 注册事件：MouseDown 是否已拖拽，需提供 拖拽的判定距离，不能太小不然会误判。 触发拖拽开始的回调 拖拽中 - 注册事件：MouseMove、Scroll 拖拽的方向 拖拽的距离 拖拽的位置 触发拖拽中的回调 拖拽到边界时容器应随之滚动 应只针对于非固定布局的元素 拖拽时应显示拖拽中的光标 拖拽结束 - 注册时间：MouseUp 拖拽的位置 触发拖拽结束的回调 在拖拽组件时 预期可提供不同阶段的回调函数，再结合该引擎使用，做到底层隔离，聚焦业务逻辑。 你可能好奇 为什么要使用 MouseDown + MouseMove + MouseUp 模拟拖拽事件，而不使用 DOM 原生的 Drag 事件？ 画布组件拖拽中需要实时拿到当前的位置、拖拽方向，即需要注册 MouseMove 事件，如此一来不如使用以上三个 Mouse 事件模拟更加方便。 镜像组件 组件从拖拽开始到拖拽结束 会有一个拖拽中的镜像组件，可以从以下两点提升搭建的体验。 这样做的好处是：镜像组件能前置加载组件资源 ，拖拽时也能给用户实时的反馈。 实现伪代码如下： let componentMap = {}let mirror = { move: xxx, destory:xxx }// 鼠标摁下 加载物料，生成镜像onMouseDown = (e) =&gt; { const schema = genSchema(e) const schema = loadComponent(schema) mirror = renderMirror(schema)}// 根据拖拽的位置移动镜像onMouseMove = (e) =&gt; { mirror.move(e)}// 拖拽结束销毁镜像onMouseUp = (e) =&gt; { mirror.destory()}// 加载组件资源loadComponent = (schema) =&gt; { if(componentMap[schema.type]) return componentMap[schema.type] = systemjs.loadModule(schema.url)}// 根据已经获取的组件资源 渲染镜像renderMirror = (schema) =&gt; { const mirrorEl = document.createElement('div') document.body.appendChild(this.mirrorEl) const Mirror = componentMap[schema.type] ReactDOM.render(&lt;Mirror /&gt;, this.mirrorEl)} 在鼠标点击时加载物料资源 或者 复用已缓存的物料资源 在拖拽开始时渲染相应的组件 拖拽中 实时同步位置，拖拽结束卸载组件 组件锚点 组件锚点 属于 拖拽组件中绕不开的一个概念。 用知名绘图工具 draw.io 举例，选中组件后，会在组件周围出现 8 个锚点。 image 组件在拖拽时 可根据其锚点进行 参考线的显示，并且在选中组件时 也可拖拽锚点进行组件的缩放。 组件锚点 一般分为 4 个、6 个、8 个，常见为 8 个，以组件左上角（X*Y）二维坐标举例： image.png 实现逻辑是生成 8 个相应位置的锚点，再贴在原生节点上，具体实现如下： const pointList = ['t', 'r', 'b', 'l', 'lt', 'rt', 'lb', 'rb']const selectedComponent // 选中的组件const pointStyle = { width: 5px; height: 5px; border-radius: 5px; cursor: point.split('').reverse().map(m =&gt; this.directionKey[m]).join('') + '-resize',}const genPointStyle = point =&gt; { let { left, top } = selectComponent.style if(point === 'lt') { return ({...pointStyle,left,top}) } // 其他点的处理逻辑...} {pointList.map(p =&gt; ( &lt;div key={p} style={getPointStyle(p)}/&gt; ))} 锚点拖拽 锚点在拖拽时可以随意缩放组件本身的大小，从而 达到快捷设置组件尺寸的目的。 重点来了，组件本身的位置大小，在 2D 坐标系中由四个属性即可描述完整：Width、Height、Left、Top，简称为 Rect，该概念贯穿全文。 image.png 并且需要注意的是，组件的 8 个锚点在拖拽时 都是以 对点（左&lt;-&gt;右） 为固定的，所以拖拽不同的锚点，达到的效果是不相同的。 左上锚点：可更改组件的 Width、Height、Left、Top 中上锚点：可更改组件的 Height、Top 右上锚点：可更改组件的 Width、Height、Top 左中锚点：可更改组件的 Width、Left 右中锚点：可更改组件的 Width 左下锚点：可更改组件的 Width、Height、Left 中下锚点：可更改组件的 Height 右下锚点：可更改组件的 Width、Height 举例说明：假设鼠标摁下的端点坐标为 (x1,y1)，鼠标移动时取任一时间切片的坐标为(x2,y2)，锚点拖拽具体的实现逻辑如下：： 在鼠标点击时 记录点击的坐标(x1,y1) 在鼠标移动时，拿到鼠标移动时的坐标(x2,y2) 由两个坐标 相减的绝对值 得到拖拽的距离 根据以上的规则 与 拖拽的距离，重新设置 组件的 Width、Height、Left、Top 伪代码如下： let component // 当前拖拽的组件let startPoint // 起点const onMouseDown = e =&gt; { startPoint = new Point(e) }const onMouseMove = (e,point) =&gt; { const distanceX = e.x - startPoint.x const distanceY = e.y - startPoint.y if(point === 'LT') { component.height -= distanceY component.width -= distanceX component.left += distanceX component.top += distanceY } // 其他点处理...} 智能吸附 智能吸附属于组件拖拽时的辅助功能，提升页面的搭建效率。 智能吸附一般可分为三种：位置吸附、距离吸附与尺寸吸附。 位置吸附 位置吸附在很多编辑场景中都能见得到，如设计工具、搭建平台、绘图工具等。 主要原理是，用户在拖拽某一组件时，如果检测到 拖拽中的组件位置 与 画布中其他组件的位置 小于吸附的阈值，则会智能吸附，从而使得 用户搭建页面更加准确。 吸附的阈值一般为 1~5 px 常见为 3 px，如果阈值太大 则卡顿感会很明显。 智能吸附的原理很简单，当检测到 拖拽中组件与其他组件的 不同锚点 X 坐标或 Y 坐标之间的差绝对值小于阈值时，就会将拖拽中组件的 Rect 中的 Left/Top 直接设置为 被吸附组件的锚点坐标。 并且当吸附后组件之间会显示参考线，参考线一般根据锚点位置分为 2 种类型 6 条参考线，分别是： X 轴参考线 - Left、Height 是变量，Width 一般为 较小值，Top 一般等于吸附位置的 Top Y 轴参考线：Top、Width 是变量，Height 一般为 较小值，Left 一般等于吸附位置的 Left image.png 参考线的显示与锚点显示的大概逻辑相同，也是通过已知的定位大小 与 较高的图层 渲染在画布上。 伪代码如下： let draggingComponent // 拖拽中的组件let allComponents // 画布中的所有组件// 垂直参考线样式 width: 1px;height: 100%; z-index: 9e3; display:nonelet verticalLineconst onMouseDown = e =&gt; { draggingComponent = getComponentByMousePosition(e) allComponents = getAllComponents() // 得到画布中的所有组件 注册鼠标移动、鼠标抬起事件}const Diff = 3const isNearly = (a,b) =&gt; Math.abs(a-b) &lt; Diffconst onMouseMove = (e) =&gt; { allComponent.forEach(c =&gt; { const {left,top} = c.getBoundingClientRect() if(isNearly(e.left,left)){ draggingComponent.style.left = left verticalLine.style.left = left verticalLine.style.display = 'block' } // 同理针对 top、top + top/2 、其他点... })} 距离吸附 很多设计工具除了 位置吸附外，也提供了距离吸附。 用户在拖拽组件时，画布会实时检测 组件之间是否已存在 一定误差范围内的相同边距，如果存在 则设置组件的位置，已达到 边距与已存在的边距一致。 该功能在排版 边距相同的组件时会很有效。 功能要点如下： 因为搭建页面时，画布的组件只能分为两种：拖拽中的组件 与 静态放置的组件。 静态放置的相邻组件之间是可以计算出边距的，所以编辑器中可存在一个代表 包含了画布上所有相邻组件的边距状态。 当拖拽组件时，会拿到拖拽组件与相邻组件之间的边距，如果该边距 命中了 已知的边距大小，则进行组件之间的边距渲染。 为了防止 边距吸附引起的噪音过大，组件之间的边距计算，需组件在拖拽组件视图内，如下： 垂直视图内判定：以下条件需全部满足 拖拽组件的 Right &gt;= 兄弟组件的 Left 拖拽组件的 Left &lt;= 兄弟组件的 Right 水平视图内判定： 拖拽组件的 Bottom &gt;= 兄弟组件的 Top 拖拽组件的 Top &lt;= 兄弟组件的 Bottom 组件在拖拽时，参考边距由：父组件、没有与拖拽组件相交的兄弟组件、参考线组成。 垂直参考距离：下侧组件的 Top - 相邻上侧组件的 Bottom 水平参考距离：右侧组件的 Left - 相邻左侧组件的 Right 拖拽中已知的距离： 上侧距离：拖拽组件的 Top - 相邻上侧组件的 Bottom 下侧距离：相邻下侧组件的 Top - 拖拽组件的 Bottom 左侧距离：拖拽组件的 Left - 相邻左侧组件的 Right 右侧距离：拖拽组件的 Right - 相邻右侧组件的 Left 在计算时会将父组件模拟成四个组件，具体逻辑如下： image.png 基于以上要点，梳理逻辑如下： image.png 最后渲染的流程等价于 画布上显示各种 高亮提示，因为已经得到了具体的 rect 信息，实现手段很多样 就不展开了，比如悬浮一个 div。 尺寸吸附 当锚点拖拽时，也可提供 缩放组件时的尺寸吸附。 当缩放组件的高宽存在一定误差内相同的组件高宽时，就会自动设置。 达到智能吸附的效果，便于设置相同大小的组件。 功能要点如下： 画布缩放时存在 8 种类型，需要根据不同类型与变化的值 计算出 当前缩放的边。 如拖拽 topLeft 锚点时，只有 Height 发生了变化，那么就寻找存在一定误差的 Height。 并且 Height 的吸附提示 只显示在 Left 侧。 参考的组件为所有兄弟组件，如果存在多个一定误差内的组件，则取最小误差的，并且把所有最小误差的组件都渲染出 吸附提示。 吸附提示较简单，分为高度提示 与 宽度提示。 组件插入 组件插入时，需要根据对应的布局类型与图层关系，将 组件 对应的 Schema Node 信息插入到 UIDL 中，而画布会根据 UIDL 响应式进行渲染。 通俗理解，画布等价于 UIDL 树结构动态渲染的工程，即 canvas = render(UIDL)，伪代码如下： type Props = { id: ComponentId key?: string}const DynamicComponent: React.FC&lt;Props&gt; = ({ id }) =&gt; { const [schema, version] = useSchema(id) const moduleMap = useSelector((state: RootState) =&gt; state.material.moduleMap) const { children = [], type, props, name } = schema const Module = moduleMap[type] return ( &lt;Module key={id} {...props}&gt; {children.map(child =&gt; ( &lt;DynamicComponent key={child.id} id={child.id} /&gt; ))} &lt;/Module&gt; )} 在插入完成后，还可发起 事件通知，进行后置的操作，如：选中组件、销毁镜像、设置器更新等。 插入提示 组件在拖拽时会实时计算鼠标下的 DOM 节点是否为画布中的组件，如果是画布组件需给出可插入提示，从而提升搭建体验。 实时计算 DOM 节点，可通过 document.elementsFromPoint 方法，该方法会返回鼠标下的所有 DOM 节点，后续可深度遍历 查找出具有特征标识的 画布组件。 根据组件插入的方式 可知，插入动作分为 插入目标组件中 与 插入目标组件周围，这两种插入动作的提示重心是完全不同的。 插入目标组件中，提示重心在于目标组件可包含。 插入目标组件周围，提示重心在于插入的位置。 关于提示的实现，可通过增加上层绝对定位的 DOM 节点，这里不具体展开了。 结束语 至此，组件已经成功被插入到画布中，回顾一下： 使用 or 自研 拖拽库，作为底层能力，不同阶段的信息供外部消费。 在拖拽时有 镜像组件、多种智能吸附的效果 来保障搭建的效率与体验。 组件插入时，利用 UIDL 响应式渲染的特性，在画布中呈现最新的组件。 选择组件该 part 将重点介绍 组件选择后的核心机制，与可交互的快捷功能。 事件分发 在组件选择后，有一个无法绕过的主题，那就是事件分发。 由于画布中的组件是动态加载来的，如果想为组件绑定事件，需要在组件开发时进行内部的 props 消费，如把 onClick 透传到组件根节点上，但针对组件产物 进行事件绑定，这显然是不合理的。 所以如果想绑定事件，只能从 DOM 层出发，解放方案有二： 组件节点声明 组件的关键信息，并且在 Wapper 中为每个组件绑定事件。 优势： 事件触发更准确 劣势： 需要绑定 组件个数 * N 个事件 绑定全局的事件，再根据点击的位置找到相应的元素，进行分发。 优势： 节省内存 劣势： 需要一套完善的组件查找机制 为了实现的复杂度，选择方案一即可。 回归到事件分发的本身，事件分发是为了绑定画布组件的事件出现，编辑器可以提供一个 EventProvider ，该功能希望能做到不侵入原有组件、不影响组件功能、样式，并且还可为组件绑定各种事件。 可借助 display:contents 可以实现该功能，如果大家对该属性感兴趣，也可以看下 iCSS 前端趣闻 的一篇文章：冷知识！使用 display: contents 实现幽灵节点？ 具体逻辑如下： function withEventProvider&lt;P&gt;( Component: React.ComponentType&lt;P&gt;): React.ComponentType&lt;P&gt; { const Wrapped: React.ComponentType&lt;P&gt; = props =&gt; { return ( &lt;div style={{ display: 'contents' }} onClick={e =&gt; { console.log(e, props) }}&gt; &lt;Component {...props} /&gt; &lt;/div&gt; ) } const name = Component.displayName ?? Component.name ?? 'Unknown' Wrapped.displayName = `withEventProvider(${name})` return Wrapped} 快捷操作 用户在选中组件后可进行以下快捷操作，希望提高搭建效率。 删除组件 用户在选中组件之后，可以使用快捷键或者右键菜单进行删除组件。 具体逻辑为：删除目标组件在 Schema 中的相应节点，删除之后画布重新渲染即可。 复制粘贴 用户在选中组件之后，可以使用快捷键或者右键菜单进行进行复制组件。 预期操作途径：选中组件 X -&gt; Ctrl C -&gt; 选中画布、组件 Y -&gt; Ctrl V 需要注意的点如下： 在画布状态中需维护 已复制的组件 schema，并且复制的组件状态只是单个变量，非数组。 当 X、Y 组件是同一组件时，需设置两个组件偏移量，不然很容易出现重叠的情况。 插入组件时 应重置 复制组件的 Left、Top ，不然会出现偏移不符合目标容器的情况。 具体逻辑类似于组件插入。 剪切组件 用户在选中组件之后，可以使用快捷键或者右键菜单进行进行剪切组件。 剪切操作本质上是 复制粘贴操作 与 删除操作的组合，在用户复制组件后 需将复制的组件从画布中删除，剪切操作与复制操作中使用的是同一画布状态。 文本编辑 在很多搭建平台、设计工具中，文本内容可以进行双击编辑，使用起来符合直觉。 组件在开发时可为编辑的文本 wrapper 增加声明属性，如 data-edit=”propKey” const Text: React.FC&lt;Props&gt; = ({ id, styles = {}, content = '请输入文字' }) =&gt; { return ( &lt;div id={id} className={s.text} style={styles} data-edit='content'&gt; {content} &lt;/div&gt; )} 组件在挂载到画布之后，会为所有声明了 data-edit 的 DOM 节点设置 contentEditable。 用户在选中某一组件后，会判断当前位置是否存在 可编辑的文本，如存在 会在失去组件焦点后 同步设置组件的文本，已达到更新输入后的内容。 组件旋转 组件旋转功能常见于设计工具或 自由度较高的建站平台中，活动页搭建平台中使用的场景较少。 旋转功能的具体原理简单来说是，拿到 鼠标点击时坐标与鼠标移动时坐标 针对组件中心点 各自对应的角度，将其相减就是旋转的角度。 组件多选 用户可通过拖拽鼠标完成多个组件的选择，实现针对多个组件的同时操作，提升效率。 选择区域 用户在画布上拖拽鼠标时 需实时高亮已选择的区域，该功能属于组件多选的基本能力。 假设鼠标摁下的端点坐标为 (x1,y1)，鼠标移动时取任一时间切片的坐标为(x2,y2)，从视频中可以分析出以下三点： 选择区域 是以 (x1,y1) 为不动点 区域的宽 是 x2 与 x1 之间的距离，区域的高是 y2 与 y1 之间的距离 区域的左上坐标为 (min(x1,x2),min(y1,y2)) 具体设计思路如下： let startPoint = nullconst area = { width: 0, height: 0, x: 0, y: 0}const onMouseDown = e =&gt; { // 记录端点 startPoint = new Point(e) 注册鼠标移动、鼠标抬起事件}const onMouseMove = e =&gt; { area.width = Math.abs(e.x - startPoint.x) area.height = Math.abs(e.y - startPoint.y) area.x = Math.min(e.x, startPoint.x) area.y = Math.min(e.y, startPoint.y)}&lt;Area style={area} /&gt; 当鼠标抬起后 选择区域会缩小成 区域中组件组合形成的最小矩形。 分析要点如下： 选择轮廓区域中的组件 需被完全包含 选择轮廓区域的宽高 由边界组件的位置限定 选择轮廓区域的位置 等于边界组件的位置 具体设计思路如下： // 得到画布中的所有组件const components = getAllComponentInCanvas()// 得到选择区域中的组件const componentsInArea = components.filter(c =&gt; isInArea(c,area))// 得到多个组件之间的边界type Boundary = {left:number,right:number,top:number,bottom:number}const boundary:Boundary = getComponentsBoundary(componentsInArea)const outlineArea = { width: boundary.right - boundary.left , height: ...,x:boundary.left,y: boundary.bottom }&lt;Area style={outlineArea} /&gt; 同时操作 在选择多个组件后，用户可同时对选择的组件进行 移动 &amp; 拉伸操作。 常见的设计工具中为了提升移动性能，减少终端算力，会在拖拽开始前 生成选择轮廓的 DOM 节点，再把选择的多个组件插入其中，这样多个组件拖拽时 实质上是在拖拽最外层的 选择轮廓节点。在拖拽完成后，会隐藏 外层轮廓节点，再为每个组件重新计算最终的移动位置。 不过对于搭建平台来说，因为多选的组件个数不会太多，同时一起移动 也不会太多负向影响。 具体移动的逻辑可参考镜像组件，会为选择的每个组件都生成镜像组件再移动。 需要注意的是 移动时的智能吸附 以及 组件插入 是根据选择轮廓的外层位置来判定的，可理解为 组件多选后 同时移动不再根据单个组件判定 而是根据整体轮廓来判定。 同时拉伸与移动同理，都是根据单个组件拉伸的规则，同时操作在多个组件上。 结束语 至此，我们可以在选择组件后进行操作了，回顾一下： 使用事件分发机制，感知到当前用户操作的组件。 通过快捷操作，文本编辑、组件旋转、增删组件的方式 提升搭建的效率。 可选择多个组件进行同时的移动编辑。 结束语本文根据一个常见的搭建页面案例，梳理了搭建平台的核心实体-画布的技术难点。 当然对于一个成熟的编辑器而言，除了画布外，还有 设置器 与 生成器，不过碍于篇幅，敬请期待后续文章。 欢迎转载本站文章，请注明作者和出处 SimonAKing。","categories":[{"name":"前端","slug":"前端","permalink":"https://simonaking.com/blog/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://simonaking.com/blog/tags/%E5%89%8D%E7%AB%AF/"},{"name":"NCLC","slug":"NCLC","permalink":"https://simonaking.com/blog/tags/NCLC/"}]},{"title":"漫谈编程语言","date":"2021-01-30T10:54:28.000Z","path":"/talking-about-programming-language/","text":"编程语言，一种特殊的语言。 前言本文来自于 我在公司内部的一次分享。 主要简述了编程语言的阵营，语义的表达形式，不同的思维范式，以及常见规范和执行机制。 正文编程语言三种阵营学术派 You are a poet and a mathematician. Programming is your poetry 语言代表：Haskell Lisp Scala Closure 学术阵营认为编程语言是一种思想的表达。 这些语言往往是从上向下去设计，从一个纯粹的理想角度对语言建模，它们充斥着各种概念: 函数式，类型系统，模式匹配… 它们痛斥操作系统，编译器带来的各种缺陷，所以在设计时 很少去考虑，甚至有的学术派语言 完全找不到相应概念的映射(Lisp)。 虽然它们的结构精妙 概念完美，但从实用角度上 完全不占优势。 主要原因有二： 如果想熟悉学术派编程语言，就必须要先掌握它们背后的设计思想。 就比如想掌握 Haskell，范畴论那套东西你绕不开，因为 Haskell 的基本组成单位就是 Functor。 大部分学术派语言都认为编程的世界应该是“纯”的，它们反感副作用的出现，它们会为副作用的数据提供各种建模，让它们符合“纯”的定义。 有一个典型的例子，使用 Maybe 处理异常： divBy :: Integral a =&gt; a -&gt; [a] -&gt; Maybe [a]divBy _ [] = Just []divBy _ (0:_) = NothingdivBy numerator (denom:xs) = case divBy numerator xs of Nothing -&gt; Nothing Just results -&gt; Just ((numerator `div` denom) : results) 但是操作系统就是一个副作用的产物。 用垠神的话来说：没有副作用的语言，就像一个没有无线电，没有光的世界，所有的数据都必须通过实在的导线传递，这许多纷繁的电缆，必须被正确的连接和组织，才能达到需要的效果。 不过 它们对现代编程语言的发展做出了很大贡献，现代编程语言中的大多数特性都是来自这个阵营。 就比如 React 提倡的 State 数据不可变模型，reducer 的纯函数特性。 Rust 中的错误处理特性，Kotlin 中的高阶类型等等。 低层派 You are a hacker. You make hardware dance to your tune 语言代表: C C++ Rust Assembly 计算机科学的先驱 Alan Perlis 给低层语言（low-level languages）下的定义是： “A programming language is low level when its programs require attention to the irrelevant.” 如果用一门语言编写的程序需要处理不相关的东西，那这就是一门低层语言。 低层阵营认为编程语言是运行在冯诺依曼机器上的机器码。 这些语言没有学术派语言”那些华丽的外衣”，它们是命令式语言与一点 操作系统/编译器抽象的结合。 虽然从编程角度来说很原始，但它们有最贴近魔法的能力，它们可直接操控内存，手动回收垃圾，从语法角度去进行编译优化，将操作系统/编译器的概念映射得淋漓尽致。 并且它们也是高级语言以及各种基础设施的缔造者。 不过为了有效地编程，必须时刻记住硬件和软件的概念，在往往会让开发者痛苦不堪。 最典型的 烫烫烫错误： img 应用派 You are a maker. You build things for people to use 语言代表: JavaScript Python C# Swift Kotlin PHP 应用阵营认为编程语言是构建应用的一种工具。 这些语言往往是最贴近应用业务的，它们倾向于在特定环境下组合各种功能 模块，而不必太关心底层。 甚至有的应用级开发者，不需要懂操作系统，算法就可以设计出一款精美的应用。 因为在互联网的红利推动下，有很多基础设施已经被实现，所以应用级的开发者 很少在乎底层，这是件可怕的事。 就比如: Java 里的 Int 是 4 个 byte；但是 Go 里的 Int 却和机器的 32bit 还是 64bit 有关；到了 JS 里，压根就没有“整数”的概念，都是“number”。 现代的大部分应用都离不开这些语言，有趣的是，有些语言的最初设计很不规范，幸好它们的社区是最开发繁荣的。 编程语言与语义学编程语言与语言密不可分，都是表达思想的一种工具。 谈起语言 就离不开语义，在编程语言中 语义最明显的表现就是 命名 以及 编程范式(下一章节)了。 正反例子举一些的例子: JavaScript - 命名错误问题 // 返回两数之和function sub(a，b) { return a + b } Python - API 设计问题 # 返回 列表中 出现次数最多的数字# 短短两行代码，做的事情全都隐藏起来了 为了简约 反而给开发者增加了心智负担def most_frequent(lst): return max(set(lst)，key = lst.count)most_frequent([1,2,1,2,3,2,1,4,2]) # 2 Kotlin - 正面例子 // 根据条件 划分数组data class Person(val name: String，val age: Int)fun main() { val members = listOf( Person(\"Ben\"，85), Person(\"Mel\"，7), Person(\"Lou\"，15), Person(\"Sam\"，22), Person(\"Ash\"，10), ) val (kids，adults) = members.partition { it.age &lt; 18 }} 语义设计可以看出，一个优秀的名称设计是有多么的重要，这里可以细谈一下，名称设计一般分为： 内部变量命名 表示数据 表示状态 函数命名 特定领域命名(不涉及，因为一般都有规范，就比如 React 组件必须大写-骆驼峰) 命名内部数据变量的时候，用名词堆叠 再符合个命名规范就可以了。 比如: const page_count = 5const should_update = trueconst firstName = 'Gustavo'const friends = ['Kate'，'John'] 命名状态变量的时候，一般都是特定动词(has/should/can/is/…)+名词。 比如: const hasPagination = postCount &gt; 10const shouldDisplayPagination = postCount &gt; 10 函数命名时，也是有一定规律的。 函数: 动词+名词堆叠+[副词] 而动词 完全可以把它枚举出来，这样大部分场景下，都可以拿来就用。 addBalance getAccount filterActivityList patchEmails deleteUserByIdremoveItem [generate/gen]TagList fillTableHeader createFolder forEachFileList parseNodeTree updateUserInfoextractUserInfo showTable hideIframe useDebounce toBase64 isSuccess canWrite requestModule loadScript fetchGalleryData setLanguage sendMessage querySelector findElement combineList importResource searchService renderComponent readFile onChange handleInput verifyFormData changeSettings cloneJSON appendSlice insertColumn saveConfig execCommand unloadPage destoryConnection openProgram 单个动词，一般都是 名词.动词，就比如 AST.parse()。 中文编程 文言文编程语言 吾有一數。曰三。名之曰「甲」。為是「甲」遍。 吾有一言。曰「「問天地好在。」」。書之。云云。 东北编程语言 易网页 编程范式不同的编程范式 代表了 coding 时 不同的思考维度，下面将简述目前最流行的三种范式。 结构式 everything is command. 结构式编程是最符合冯诺依曼体系的范式，它告诉计算机如何去做事情。 它将逻辑划分成一个个语句，使用最淳朴的方式(循环，分支,顺序)排列起来，然后顺序执行。 FizzBuzz程序的结构式实现： Write a short program that prints each number from 1 to 100 on a new line. For each multiple of 3，print “Fizz” instead of the number. For each multiple of 5，print “Buzz” instead of the number. For numbers which are multiples of both 3 and 5，print “FizzBuzz” instead of the number. package mainimport ( \"fmt\")func main() { for i := 1; i &lt;= 100; i++ { divBy3 := i%3 == 0 divBy5 := i%5 == 0 if divBy3 &amp;&amp; divBy5 { fmt.Println(\"FizzBuzz\") } else if divBy3 { fmt.Println(\"Fizz\") } else if divBy5 { fmt.Println(\"Buzz\") } else { fmt.Println(i) } }} 很淳朴不是嘛。 面向对象 everything is object. 相信很多同学都学过有关面向对象的语言，在我们上课的时候，老师就常提起 面向对象的三大概念: 封装 继承 多态。 其实这个概念一直是错误的。 封装是一个很笼统的概念，函数就是一种封装；并且多态可以理解为向上转型，Python TypeScript 中的 ducking typing 就可以多态；目前看来只有继承是 OOP 的特性。 但 OOP 的主要概念真的是如此吗? 显然不是的。 OOP 主要是提供了一种模块化思想，面向对象范式只是语法层面的思想体现。 它在面向结构式上抽象，根据功能业务 对编程世界进行建模，把代码变成一个个以类为主的组成单元。 有趣的是 大行其道微服务，这两年兴起的微前端，以及底层的微内核 都是这种模块化思想。 在语法上 OOP 由于不支持 函数第一成员的特性，所有的逻辑都只能封装到类的方法中，调用逻辑时只能名词.动词()，这也是面向对象语言 给人造成繁琐的原因。 (其实我还想说，这也是为什么设计模式 这种常见概念能大行其道的原因) class Point{ var x:Int = 0 var y:Int = 0 operator fun plus(p: Point) { x += p.x y += p.y }}fun main(args: Array&lt;String&gt;) { val p = Point() p.x = 8 p.y = 10 val p1 = Point() p1.x = 2 p1.y = 3 val p2 = p + p1 println(\"Point(x = ${p.x}，y = ${p.y})\")} 函数式 everything is lambda. 函数式编程是最符合人思维的范式，它告诉计算机 我们想要什么(声明式编程)。 一提到函数式，纯函数，无状态，数据不可变，副作用，惰性执行等等相关概念都不可避免。 我简述下： 无状态: 不管何时运行，运行多少次，只要给定相同的输入，那输出结果一定是一致的，完全不依赖外部数据。 数据不可变: 顾名思义，数据不可变化，如果想修改数据，那就创建一个新的数据。 副作用: 指的是 函数修改了外部的状态，可以看出 如果保存了数据不可变型，那么函数自然而然就没有副作用了。 纯函数: 如果一个函数保障了 无状态 数据不可变特性，那这个函数就是一个纯函数。 不依赖外部数据，不修改内部数据。 举例: const person = { name: 'SimonAKing' }// 修改了内部数据const changeName = (person，newName) =&gt; person.name = NewName// 依赖了外部数据const joinName = (text) =&gt; person.name + text 可以看出 函数式本身具备了一种防御性编程的规范。 而函数式编程的主要提供了什么？ 答: 逻辑的组合映射 以及 行为上的分治思想(MapReduce)。 逻辑的组合映射，函数式编程语言提供了很多有关组合映射的工具函数：map、flatMap、foldl、foldr、reduce、filter、compose、partial、curring .. 当然在熟悉它们之前，你需要了解下 各种 Functor: 基本的 Mappable 函子、Pointed 函子、Maybe 函子、Monad 函子等 以及 一些范畴论的知识。 一个简朴的函子: class Box { constructor(value) { this.value = value } map (fn) { return new Box(fn(this.value)) }}const value = new Box(1).map(v =&gt; v + 1).map(v =&gt; v * 2) 行为上的分治思想： 给出快排的两种实现，大家可以体会下： 结构式: class QuickSort { private static void exch(int pos1,int pos2,List data){ int tmp=data[pos1]; data[pos1]=data[pos2]; data[pos2]=tmp; } private static void partition (int lo,int hi，List a){ if (lo&lt;0||hi&lt;0||lo&gt;=hi-1){ return; } int midValue=a[lo]; int i=lo+1;int j=hi; while (true){ while(i&lt;hi&amp;&amp;a[i]&lt;midValue){ i++; } while(j&gt;lo&amp;&amp;a[j]&gt;midValue){ j--; } if (i&gt;=j) break; exch(i,j,a); } exch(i,lo,a); partition(lo,i-1,a); partition(i+1,hi,a); } public static List sort(List a){ int low=0; int hight=a.size()-1; partition(low，hight，a); return a; }} 函数化: const quickSort = a =&gt; { if (!a.length) { return [] } return [ ...quickSort(a.filter(e =&gt; e &lt; a[0])), ...a.filter(e =&gt; e === a[0]), ...quickSort(a.filter(e =&gt; e &gt; a[0]))]} 就像章节开始所说的那样：结构式编程是最符合冯诺依曼体系的范式，它告诉计算机如何去做事情；函数式编程是最符合人思维的范式，它告诉计算机 我们想要什么。 具体选哪种范式，还是要根据场景来结合。 如果你的场景适合业务领域建模，很容易找到不同的模型以及模型间关系的话，那么 OOP 显然是最优的。 如果你的场景 主要是对数据的加工，就比如对一数组先排序再筛选 然后映射得到结果的话，FP 就很自然。 编程规范SOLID 原则 S：单一职责原则 一个模块只能做一件事。 O：开闭原则 增加新功能时，模块应该是支持扩展的，而不是提倡修改，多态的最佳实践。 L：里氏替换原则 子类必须可以替换它的超类，向下转型的最佳实践。 I：接口隔离原则 接口设计时应该衡量细粒化，而不是设计一个笼统的接口。 D：依赖反转原则 高级模块不应该依赖于低级模块。两者都应该依赖于抽象。 抽象不应该依赖于细节。细节应该依赖于抽象。 注入实现了相同接口的逻辑。 防御性编程防御性编程往往是从编程角度去提升工程质量，减少 Bug。 刚刚提到函数式语言的思想就很实用。 拒绝写副作用代码 不要与外部状态相互关联，尽量将所需数据全部输入。 比如典型的副作用 JS-API: sort，reverse，splice，最好能不用就不用。 不要共享引用 如果说 null 的设计是一亿美金的失误，那么 堆上对象共享引用 的设计可以算上得百亿美金的失误。 如果遇到共享引用的变量情况，请不要碰它。 尽量写纯函数 尽量将数据流统一化 统一语言规范，使用相同的 lint 工具，相同的语法规范 容错处理，正视程序出现的每一个异常 API 接口设计时 对输入尽可能的保持严谨，对输出保持开发 不要相信网络请求，每一次网络请求都有可能失败 抽象化原则 DRY - Don’t Repeat Yourself 尽量在项目中减少重复的代码。 KISS - Keep It Simple &amp; Stupid 代码应该保持简单易懂。 YAGNI - You Ain’t Gonna Need It 不要进行过度化设计，会延缓开发效率。 编程语言如何执行编译型语言编译型语言是将源代码经过词法分析，语法分析，生成 AST，然后在转成中间代码的形式，经过优化器优化后 再生成目标机器的机器码。 优化涉及到的一些点： 去掉无意义的数据 (无法运行到的代码，没有利用的数据) 内联函数，尾递归优化 解语法糖 … 代表语言: C，C++，Go 解释型语言解释型语言，不能直接生成机器码，而是先翻译成中间代码，再有解释器对中间代码进行解释运行。 代表语言: Python，Lua 解释编译型语言由于即时编译技术(JIT)的存在，可以将热点代码直接编译成字节码 来提高程序执行的效率，越来越多的语言开始使用，就比如最近推出的 Ruby3。 JavaScript 也是一个很好的例子。 V8 运行 JS 的过程 源代码(source code) 通过解析器(parser) 解析后 生成抽象语法树(AST)。 抽象语法树 通过 解释器(interpreter-Ignition) 生成了字节码(bytecode)，此字节码作为基准执行模型，字节码等同于 25%-50% 机器码大小。 并且 此时抽象语法树被彻底清除掉了，释放其内存空间。 生成后的字节码 直接被 解释器执行 (解释执行)。 在代码不断的运行过程中，解释器收集到了很多可以优化代码的信息，比如变量的类型，哪些函数执行的频率较高。 V8 引擎的编译器(compiler-TruboFan) 会根据这些信息和字节码 来编译出经过优化的机器代码。 一些常见的优化规则： 函数只是声明未被调用，那么该函数不会生成到 AST 函数如果只被调用一次，字节码则直接被解释执行了 如果函数被调用多次，可能会被标记为热点函数，会被编译成机器代码 随着不断执行，会有越来越多的代码被标记为热点代码，然后被编译成机器码。 所以 JS 运行的过程 正是一个从解释执行到编译执行的过程。 注意在某些情况下，优化后的机器代码可能会被逆向还原成字节码。 const sum = (a,b) =&gt; a + bsum(1,2)// 假设调用了多次 sum 函数// sum 函数在编译器优化后的机器码 将是 int 类型的参数sum('1'，'2')// 此时 参数的类型发生变化，V8 将会发生 deoptimization 的过程// 机器码不知道如何处理 string 类型参数，也就是回退到字节码，由解释器解释执行// 所以 coding 时，热点函数不要随便改变类型 未来编程语言设想 完全不涉及编译器的概念 语义设计优秀，写代码就像写诗一样 无 GC 强类型系统，支持强大类型建模 各领域都有对应的丰富生态 优雅错误处理，强行让开发者正视逻辑错误，可是忽视潜在错误 强大的工具链，具有比较统一的编程风格，lint 工具，包管理器 可以完全利用多核的能力 可以面向 GPU 编程 支持多种编程范式 跨平台，无需虚拟机，可编译成机器码 在语法层面提供并发原语 推荐阅读 3 tribes of programming 编程的宗派 思考的价值-PL 思考的价值-Coding 前端 DSL 实践指南（上）—— 内部 DSL Learn Advanced TypeScript Types Java 即时编译器原理解析及实践 函数式编程进阶：杰克船长的黑珍珠号 编程的智慧 结束语欢迎转载本站文章，请注明作者和出处 SimonAKing。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://simonaking.com/blog/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://simonaking.com/blog/tags/%E9%9A%8F%E7%AC%94/"},{"name":"编程语言","slug":"编程语言","permalink":"https://simonaking.com/blog/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"总结","slug":"总结","permalink":"https://simonaking.com/blog/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"前端架构发展史","date":"2021-01-22T14:21:04.000Z","path":"/history-of-front-end-architecture/","text":"前端改革 30 年，从一片荒芜到微前端兴起。 前言本文主要简述前端系统级架构的演讲历史，不涉及应用级架构: MVC，MVMM… 正文前置术语 应用：指的是一个整体的应用，可由多个模块组成。 模块：指的是整体应用下 被划分的子应用。 无架构在 1990 年，Tim Berners-Lee 在他的 NeXT 电脑上部署了第一套“主机-网站-浏览器”构成的 Web 系统，这标志着前端的开始。 在最初，前端是一片荒芜的，经过浏览器大战，W3C 标准化的过程 前端才慢慢成长了起来。 在此时期，诞生了 CSS、JavaScript、DHTML 等重要技术。前端也从最开始的纯静态页面，逐步存在于 PHP、ASP、JSP 这些模板技术中。 由于前端涉及到的功能简单，只需操作 DOM，并不需要代码管理与模块支持。 所以 最初的前端只是 MVC 架构中的 View，如下面的模板，没有架构可言。 &lt;html&gt; &lt;head&gt;&lt;title&gt;Car {{ $car-&gt;id }}&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;Car {{ $car-&gt;id }}&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;Make: {{ $car-&gt;make }}&lt;/li&gt; &lt;li&gt;Model: {{ $car-&gt;model }}&lt;/li&gt; &lt;li&gt;Produced on: {{ $car-&gt;produced_on }}&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 前后端分离架构在 1999 年，IE 浏览器支持了 XMLHttpRequest 接口，允许 JavaScript 异步发出 HTTP 请求，这为以后的前端发展 埋下了重要伏笔。 2005 年，在 Google 广泛应用 Ajax 通信 获得一系列产品成功后，这种不需要刷新页面就可以与服务器通信的技术 开始被开发者所重视。 但 Ajax 带来的不仅是一种可异步通信的技术，而是开发模式上的解耦。 前端不再是后端的模板，前端也可以实时地获取数据，动态地渲染内容。 在此时期，前端逐步从纯内容展示的静态网页 向 具备数据交互的动态网页转变，前端开发变得复杂起来。 与此同时，互联网带来的商业价值 推动了其他技术的产生，这其中就包括了 大名鼎鼎的 V8 。 在 V8 开源的第二年，Nodejs 出现了，让 JS 可以 run everywhere。 也正是因为它把前端快速带进了刀耕火种时代，其中最受益的就是工程化的兴起。 构建工具：gulp webpack 包管理：npm yarn 排名第一的包生态 除此之外，标准化组织 W3C 也在 08 年发布 HTML5 正式草案。 随着资本的重视，工程化的兴起，开源社区的努力，开发模式的创新，整个前端开发 开始呈现野蛮增长现象。 从 2010 年 10 月出现的 Backbone 开始，Knockout、Anjular、Ember、Meteor、Vue 相继出现，前端开发颇有一副 不管 MVC 、MVVM 还是 全栈开发，我全都要的气势。 在此期间，有一股潮流慢慢被大家所认可，就是单页面应用。 但单页面应用代表的不只是工程技术化的产物，而重要的是一种网页 应用化的思想。 而随着单页面应用的流行，移动端的兴起，前后端分离的架构也成为了行业的标准实践。 由此，前端不再是后端 MVC 中的 V，而是单独的一层。 前端开始进入前后端分离时代。 微前端架构微前端的概念由 ThoughtWorks 于 2016 年的一期技术雷达提出, 摘自技术雷达: 我们已经从引入微服务架构中获得了明显的好处，微服务架构可以让团队裁剪出独立部署的交付物以及可维护的服务。不幸的是，我们还看到许多团队在后端服务之上创建了前端单体——一个单一，庞大和杂乱无绪的浏览器应用。我们首选的（经过验证的）方法是将基于浏览器的代码拆分成微前端。在这种方法中，Web 应用程序被分解为多个特性，每个特性都由不同的前后端团队拥有。这确保每个特性都独立于其他特性开发，测试和部署。这样可以使用多种技术来重新组合特性——有时候是页面，有时候是组件——最终整合成一个内聚的用户体验。 “微”是一个很神奇的概念，底层的微内核设计，大行其道的微服务概念，以及本章的微前端主题。 微 实质上代表的概念是模块化，而模块化具有的思想是: 单一职责、关注分离，分而治之，这些思想 在软件工程中体可谓是金玉良言。 在我看来 微前端的出现 是一种趋势，是 WEB2.0 时代应用复杂性的一种体现，也标志着前端从刀耕火种的时代跨入了工业化时代。 在一些小型应用中，往往几个 单页面就足以支撑起整个应用。 而在一些中大型的应用中，业务的复杂性、工程的庞大性 都难以控制，如果继续使用传统的开发模式，不仅应用的状态难以管理，打包出来的应用难以优化，就连协作开发都存在很大的耦合性。 微前端 使用去中心化的思想可以有效分解大型应用的复杂度，将大型应用划分成一个个独立的模块，根据功能、业务场景来进行自由编排，这些模块通过统一的入口注册组合，通过约定的方式来进行通信，各个模块可以做到并行开发，独立部署，而且技术栈也随之解耦。 Application 但是微前端并不是提升研发效率的银弹，需要根据具体场景来衡量是否使用，而架构就是权衡的艺术，微前端为我们提供了一种系统级的维度。 使用场景适合场景 聚合型的应用 这种应用主要存在 业务场景多样且业务之间依赖性很低的场景。 就比如 Top 运营系统，每一个模块都可以单独抽成一个应用进行开发 且 满足单一职责原则，替换掉某一模块时也不会影响全局应用。 逻辑重复型的应用 这种应用的特征是，子模块之间存在很多共同的业务逻辑，重复建设严重。 就比如 电商系统，在 PC 端，H5 终端 都会有商品推荐，购买商品这些基本的功能，属于业务逻辑基本相同，UI 相差较大。 微前端可以将子模块之间相同的业务逻辑 提取到主应用，然后各个子模块通过约定的方式进行通信，这样子模块的维护性会得到提升。 需保留老模块的应用 在现代的前端开发时，由于技术栈日新月异，如何处理遗留模块 是一个无论绕过的问题。 如果旧模块可以继续使用，并且重写需要花很多时间力气的话，那么使用微前端 整合进现有应用是一个很好的方案。 需数据隔离的应用 数据隔离指的是 状态隔离，样式隔离。 如果一个应用的单个页面存在多种模块时，数据冲突 不能忽视，比如模块中的全局变量，事件，通用样式 很可能造成问题。 这种问题通常需要”沙箱化”来解决，而微前端提供了很好的实践。 “沙箱化”还能提供应用的容错性，当一个子模块出现错误时，不会影响到全局应用，真正做到弹性应用。 技术栈灵活的应用 使用微前端在系统级层面进行模块地抽象组合，磨平了不同技术栈带来的差异,做到模块之间技术栈的隔离。 在同一应用下 每个团队可以根据自身需求，选择最合适自己的技术栈。 需要敏捷化开发的应用 因为微服务提供了 模块级的组件化架构，完全可以做到多个模块之间并行开发，独立部署，无论模块的需求如何增长，都不会影响到全局应用。 并且天然的增量构建，有利于持续部署。在团队协作开发层面也是一种很好的实践。 无法可持续迭代的应用 这种应用一般都是巨石型应用，存在的问题很明显: 随着业务需求的迭代，代码量级越来越大，开发效率越来越低，新业务的接入成本随之变高。 这种场景只能从技术维度来进行切入,需将巨石应用划分模块来处理臃肿。 不适合场景 应用之间存在很强的业务依赖 或者 拆分的粒度很难掌握，如果强行使用微前端规范，很可能起到相反的作用。 小型应用，没必要过度设计。 对性能有要求的应用，微前端因为多加了一层抽象，如果不是从工程化进行模块组合的话，极有可能为页面增加很多无意义的网络请求,内存消耗，影响最终的用户体验。 基础设施较弱的应用。 结束语下篇文章将讲述微前端的实践原理，敬请关注。 欢迎转载本站文章，请注明作者和出处 SimonAKing。","categories":[{"name":"前端","slug":"前端","permalink":"https://simonaking.com/blog/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://simonaking.com/blog/tags/%E5%89%8D%E7%AB%AF/"},{"name":"架构","slug":"架构","permalink":"https://simonaking.com/blog/tags/%E6%9E%B6%E6%9E%84/"},{"name":"随笔","slug":"随笔","permalink":"https://simonaking.com/blog/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"思考的价值","date":"2021-01-16T06:43:29.000Z","path":"/thinking/","text":"论如何科学地提升自己。 前言在互联网时代，知识从未像如此一般廉价，但是再好的知识若是没有产生价值，那也只不过是一种信息噪音罢了。 在我看来，只要能让人产生思考的文字、图片、媒体资源 就是有价值的，有分享价值的。 所以，我创建了一个思考的价值微信群，立志于分享高质量信息 以及 与志同道合的同学 交流各种观点、产生思考，从而达到沉淀自己、提升自己。 正文输出由于使用微信群的方式，很多时候 有价值的信息都会被时间掩埋，并且当卸载微信或者换手机时，聊天记录也会丢失。 基于这些痛点，我创建了个站点：https://thinking.simonaking.com/ 站点里的内容 皆来自于 思考的价值 微信群，它记录了 自从建群以来 每天有价值的信息。 站点导航: 具体的分享领域 讨论过的事物 某一周分享的汇总 如果你对输出的内容很感兴趣，随时欢迎加群一起交流。 目前思考的价值里面的群友不多，但都是想提升自己 有明确方向的同学。 最近我变成了打工人，所以 群里信息分享的密度不会如之前那么大。 须知在加群之前请先仔细阅读以下条目： 如果你觉得不舒服或者因为其他原因，可以随时退群。 在我看来 这是双向选择的事情，我完全理解。 群里的信息 大部分都是以 我的视角来分享的，存在的问题很明显： 信息不会照顾到每一个同学。所以 当你碰到好玩或者有价值的信息时，可以随时分享。 信息是不应该有限制的，而成长也是不应该给自己树立边界的。 关于闲聊 只要不涉及到国家时政以及违法法律、性低俗的主题，都可以随时在群里发起一个 Thread 来讨论。 此群可以当作一个信息流来看待，你可以选择不分享，做一个潜水运动员。 如果你有不同的观点，或者分享一些感触很深的信息时 请不要有心理负担，不要在乎没人回复。 思考的价值站点的 Talk 页面，会记录群里一些有价值的讨论。但请放心 所有人都是以字母代称出现，不会涉及任何人的隐私、微信昵称。 如果你对分享的内容完全不感兴趣 或者 不想提升自己，只是想找个地方闲聊一些低级趣味的主题，此群不适合你也不欢迎你。 入口如果你也想加群学习交流，欢迎添加我的微信：simonaking 或者扫描下方的二维码。 并且如果认识 有相同意向的同学, 可以随时拉她/他进群 :) wechat 结束语欢迎转载本站文章，请注明作者和出处 SimonAKing。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://simonaking.com/blog/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://simonaking.com/blog/tags/%E9%9A%8F%E7%AC%94/"},{"name":"成长","slug":"成长","permalink":"https://simonaking.com/blog/tags/%E6%88%90%E9%95%BF/"}]},{"title":"React 的 7 种代码异味[译]","date":"2020-11-15T02:57:51.000Z","path":"/7-code-smells-in-react-components/","text":"教你如何更好地写 React。 前言原文链接：7 code smells in your React components 作者信息：Anton Gunnarsson 翻译许可： Agree 正文自从使用 React 后，我见过越来越多可值得优化的点，比如： 大量的 props props 的不兼容性 props 复制为 state 返回 JSX 的函数 state 的多个状态 useState 过多 复杂的 useEffect 在本文中，我想分享几个技巧，这些技巧将改善你的 React 代码。 大量的 props如果需要把大量的 props 传递到一个组件中，那么很有可能 该组件可再进一步拆分。 问题来了，“大量” 具体是多少呢？答案是 看情况。 假设你正在开发 一个包含 20 个或更多 props 的组件时，你想再添加一些 props 完善其他功能，这时有两点可以参考 是否应拆分组件： 该组件是否做了多件事？ 像函数一样，一个组件应该只做好一件事，所以考虑下 将组件拆分成多个小组件是否会更好。 例如，该组件存在 props 的不兼容性 或 返回 JSX 的函数。 该组件是否可被合成？ 开发中，组合是一种很好的模式但经常被忽视。 如果你的组件中存在将不相干逻辑塞到一起的情况，是时候考虑使用组合了。 假设我们有一个表单组件来处理某组织的用户信息: &lt;ApplicationForm user={userData} organization={organizationData} categories={categoriesData} locations={locationsData} onSubmit={handleSubmit} onCancel={handleCancel} .../&gt; 通过该组件的 props ，我们可看到它们都与组件提供的功能密切相关。 该组件看起来并无大碍，但如果将其中的一些 props 分担到子组件，那么数据流就会更清晰。 &lt;ApplicationForm onSubmit={handleSubmit} onCancel={handleCancel}&gt; &lt;ApplicationUserForm user={userData} /&gt; &lt;ApplicationOrganizationForm organization={organizationData} /&gt; &lt;ApplicationCategoryForm categories={categoriesData} /&gt; &lt;ApplicationLocationsForm locations={locationsData} /&gt;&lt;/ApplicationForm&gt; 现在，我们已经看到该表单组件只处理提交和取消动作，其他范围内的事情，都交给了对应的子组件。 是否传递了很多有关配置的 props 在某些情况下，将多个有关配置的 props 组合成一个 options 是个不错的实践。 假设我们有一个可显示某种表格的组件： &lt;Grid data={gridData} pagination={false} autoSize={true} enableSort={true} sortOrder=\"desc\" disableSelection={true} infiniteScroll={true} .../&gt; 我们可以很清楚地看出，该组件除了 data 外其余的 props 都是与配置有关的。 如果将多个配置 props 合成为一个 options ，就可更好地控制组件的选项，规范性也得到提升。 const options = { pagination: false, autoSize: true, enableSort: true, sortOrder: 'desc', disableSelection: true, infiniteScroll: true, ...}&lt;Grid data={gridData} options={options}/&gt; props 的不兼容性避免组件之间传递不兼容的 props。 假设你的组件库中有一个 &lt;Input /&gt; 组件，而该组件开始时仅用于处理文本，但过了一段时间后，你将它用于电话号码处理。 你的实现可能如下： function Input({ value, isPhoneNumberInput, autoCapitalize }) { if (autoCapitalize) capitalize(value) return &lt;input value={value} type={isPhoneNumberInput ? 'tel' : 'text'} /&gt;} 问题在于，isPhoneNumberInput 与 autoCapitalize 之间并不存在关联，将一个手机号首字母大写是没有任何意义的。 在这种情况下，我们可以将其分割成多个小组件，来明确具体的职责，如果有共享逻辑，可以将其放到 hooks 中。 function TextInput({ value, autoCapitalize }) { if (autoCapitalize) capitalize(value) useSharedInputLogic() return &lt;input value={value} type=\"text\" /&gt;}function PhoneNumberInput({ value }) { useSharedInputLogic() return &lt;input value={value} type=\"tel\" /&gt;} 虽然上面例子有点勉强，可当发现组件的props存在不兼容性时，是时候考虑拆分组件了。 props 复制为 state如何更好地将 props 作为 state 的初始值。 有如下组件： function Button({ text }) { const [buttonText] = useState(text) return &lt;button&gt;{buttonText}&lt;/button&gt;} 该组件将 text 作为 useState 的初始值，可能会导致意想不到的行为。 实际上该组件已经关掉了 props 的更新通知，如果 text 在上层被更新，它将仍呈现 接受到 text 的第一次值，这更容易使组件出错。 一个更实际场景是，我们想基于 props 通过大量计算来得到新的 state。 在下面的例子中，slowlyFormatText 函数用于格式化 text，注意 需要很长时间才能完成。 function Button({ text }) { const [formattedText] = useState(() =&gt; slowlyFormatText(text)) return &lt;button&gt;{formattedText}&lt;/button&gt;} 解决此问题 最好的方案是 使用 useMemo 代替 useState。 function Button({ text }) { const formattedText = useMemo(() =&gt; slowlyFormatText(text), [text]) return &lt;button&gt;{formattedText}&lt;/button&gt;} 现在 slowFormatFormat 仅在 text 更改时运行，并且没有阻断 上层组件更新。 进一步阅读：Writing resilient components by Dan Abramov。 返回 JSX 的函数不要从组件内部的函数中返回 JSX。 这种模式虽然很少出现，但我还是时不时碰到。 仅举一个例子来说明: function Component() { const topSection = () =&gt; { return ( &lt;header&gt; &lt;h1&gt;Component header&lt;/h1&gt; &lt;/header&gt; ) } const middleSection = () =&gt; { return ( &lt;main&gt; &lt;p&gt;Some text&lt;/p&gt; &lt;/main&gt; ) } const bottomSection = () =&gt; { return ( &lt;footer&gt; &lt;p&gt;Some footer text&lt;/p&gt; &lt;/footer&gt; ) } return ( &lt;div&gt; {topSection()} {middleSection()} {bottomSection()} &lt;/div&gt; )} 该例子虽然看起来没什么问题，但其实这会破坏代码的整体性，使维护变得困难。 要么把函数返回的 JSX 直接内联到组件内，要么将其拆分成一个组件。 有一点需要注意，如果你创建了一个新组件，不必将其移动到新文件中的。 如果多个组件紧密耦合，将它们保存在同一个文件中是有意义的。 state 的多个状态避免使用多个布尔值来表示组件状态。 当编写一个组件并多次迭代后，很容易出现这样一种情况，即内部有多个布尔值来表示 该组件处于哪种状态。 比如下面的例子： function Component() { const [isLoading, setIsLoading] = useState(false) const [isFinished, setIsFinished] = useState(false) const [hasError, setHasError] = useState(false) const fetchSomething = () =&gt; { setIsLoading(true) fetch(url) .then(() =&gt; { setIsLoading(false) setIsFinished(true) }) .catch(() =&gt; { setHasError(true) }) } if (isLoading) return &lt;Loader /&gt; if (hasError) return &lt;Error /&gt; if (isFinished) return &lt;Success /&gt; return &lt;button onClick={fetchSomething} /&gt;} 当按钮被点击时，我们将 isLoading 设置为 true，并通过 fetch 执行网络请求。 如果请求成功，我们将 isLoading 设置为 false，isFinished 设置为 true，如果有错误，将 hasError 设置为 true。 虽然这在技术上是可行的，但很难推断出组件处于什么状态，而且不容易维护。 并且有可能最终处于“不可能的状态”，比如我们不小心同时将 isLoading 和 isFinished 设置为 true。 解决此问题一劳永逸的方案是 使用枚举来管理状态。 在其他语言中，枚举是一种定义变量的方式，该变量只允许设置为预定义的常量值集合，虽然在JavaScript 中不存在枚举，但我们可以使用字符串作为枚举： function Component() { const [state, setState] = useState('idle') const fetchSomething = () =&gt; { setState('loading') fetch(url) .then(() =&gt; { setState('finished') }) .catch(() =&gt; { setState('error') }) } if (state === 'loading') return &lt;Loader /&gt; if (state === 'error') return &lt;Error /&gt; if (state === 'finished') return &lt;Success /&gt; return &lt;button onClick={fetchSomething} /&gt;} 通过这种方式，完全杜绝了出现 不可能状态的情况，并更利用扩展。 如果你使用 TypeScript 开发的话，则可以从定义时就实现枚举： const [state, setState] = useState&lt;'idle' | 'loading' | 'error' | 'finished'&gt;('idle') useState 过多避免在同一个组件中使用太多的 useState。 一个包含许多 useState 的组件可能会做多件事情，可以考虑是否要拆分它。 当然也存在一些复杂的场景，我们需要在组件中管理一些复杂的状态。 下面是自动输入组件的例子： function AutocompleteInput() { const [isOpen, setIsOpen] = useState(false) const [inputValue, setInputValue] = useState('') const [items, setItems] = useState([]) const [selectedItem, setSelectedItem] = useState(null) const [activeIndex, setActiveIndex] = useState(-1) const reset = () =&gt; { setIsOpen(false) setInputValue('') setItems([]) setSelectedItem(null) setActiveIndex(-1) } const selectItem = (item) =&gt; { setIsOpen(false) setInputValue(item.name) setSelectedItem(item) } ...} 我们有一个 reset 函数，可以重置所有状态，还有一个 selectItem 函数，可更新一些状态。 这些函数都离不开 useState 定义的状态。如果功能继续迭代，那么函数就会越来越多，状态也会随之增加，数据流就会变得模糊不清。 在这种情况下，使用 useReducer 来代替 过多的 useState 是一个不错的选择。 const initialState = { isOpen: false, inputValue: \"\", items: [], selectedItem: null, activeIndex: -1}function reducer(state, action) { switch (action.type) { case \"reset\": return { ...initialState } case \"selectItem\": return { ...state, isOpen: false, inputValue: action.payload.name, selectedItem: action.payload } default: throw Error() }}function AutocompleteInput() { const [state, dispatch] = useReducer(reducer, initialState) const reset = () =&gt; { dispatch({ type: 'reset' }) } const selectItem = (item) =&gt; { dispatch({ type: 'selectItem', payload: item }) } ...} 通过使用 reducer，我们封装了管理状态的逻辑，并将复杂的逻辑移出了组件，这使得组件更容易维护。 进一步阅读：state reducer pattern by Kent C. Dodds。 复杂的 useEffect避免在 useEffect 中做太多事情，它们使代码易于出错，并且难以推理。 下面的例子中 犯了一个很大的错误： function Post({ id, unlisted }) { ... useEffect(() =&gt; { fetch(`/posts/${id}`).then(/* do something */) setVisibility(unlisted) }, [id, unlisted]) ...} 当 unlisted 改变时，即使 id 没有变，也会调用 fetch。 正确的写法应该是 将多个依赖分离： function Post({ id, unlisted }) { ... useEffect(() =&gt; { // when id changes fetch the post fetch(`/posts/${id}`).then(/* ... */) }, [id]) useEffect(() =&gt; { // when unlisted changes update visibility setVisibility(unlisted) }, [unlisted]) ...} 结束语以上就是我分享的全部。请记住，这些绝不是规则，而是表明某些东西可能是“错误的”。 如果你也发现了其他的问题模式，欢迎发表评论，或者在 Twitter 上联系我。 欢迎转载本站文章，请注明作者和出处 SimonAKing。","categories":[{"name":"前端","slug":"前端","permalink":"https://simonaking.com/blog/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"译文","slug":"译文","permalink":"https://simonaking.com/blog/tags/%E8%AF%91%E6%96%87/"},{"name":"前端","slug":"前端","permalink":"https://simonaking.com/blog/tags/%E5%89%8D%E7%AB%AF/"},{"name":"React","slug":"React","permalink":"https://simonaking.com/blog/tags/React/"}]},{"title":"拯救者 Y9KK 换机指南","date":"2020-05-27T05:18:58.000Z","path":"/Y9KK/","text":"AMD！YES！R7K！NO！Y9KK! YES! 前言我的第一个笔记本也是我现在 正在使用的笔记本，是 16 年花了五千大洋购入的华硕的暗影战神。 当时很年轻没有做功课，只是想买台笔电打打DNF，写写代码这样。 在逛了秦皇岛的几条街后，感觉笔记本都差不多，也不知道什么配置，就草草下单了。 现在看来，这台笔电在当时就是个坑： 4G 内存，DDR3 1T 机械硬盘 intel 4 代 双核标压 N 卡 980，2G 显存 5200 毫安的电池 2.7kg 的重量 买完之后，打两局LOL就烫手，打开个Chrome内存基本就没了… 幸好后来在大学这两年，我相继买入了内存条+固态，才勉强维持得了生活。 前不久因为找到了实习工作，所以多年一直蠢蠢欲动 换电脑的想法 也随之强烈起来。 我是非常想换Macbook Pro的，可惜那两万多的价钱对学生党太不友好了。 所以想了想还是先买台Windows笔电过渡，MBP等以后再说。 正文笔电选择经过数个小时的挑选，我最后锁定了如下的五款笔电： 联想 Y9000X 一款走极客风格的笔电，我当时看到它的时候就差点下单了。 后续想了想，就算自己没有游戏需求，GPU也同样很重要的。 在计算机方面，除了深度学习方面的框架，我也曾看到过不少使用GPU作为加速计算的项目。 另外 9K 的价格换了一块 4K 屏，总感觉怪怪的，笔记本真的需要 4K 屏吗？ 联想小新 Pro（15.6） 性价比很强！但是 CPU 是 intel 低压，主频只有 1.1 赫兹。 并且只有 13.1 寸屏才提供 16：10、2k 屏的特性，有点遗憾。 联想 R7000(已购) 暗影骑士氢 性价比也很高，但是比起 R7000 来说，CPU 不但打不过，价钱还高了近 1000。 机械革命 17.3 寸 144hz 高色域大屏 + 自带机械键盘 确实很吸引人，但感觉花大价钱买个“纯”游戏本，总觉得有点浪费。 由经过了数轮筛选 + 参数对比，结合着自己当下的需求，我最终选择了联想 R7000。 理由很简单：在 5.5k 这个价位，R7000 无疑是性价比最高的，并且配置上 AMD 4800H （8 核 12 线程）的 CPU，可以说吊打一切，关于这点 我查了很多外网上面的权威网站，可以说目前移动端 AMD 4800H 没有敌手。 除了强大的 CPU 心脏，它的内存也是一大亮点：16G-3200MHZ，市面上都很少见速度这么高的内存，而众所周知 计算机的瓶颈就在于 IO，这让我很喜欢。 如果要说不足之处，最显而易见的就是显卡了。 R7000 搭载了 1650 显卡，60hz 高色域屏，这个显卡有点拉，但是我平时就打打守望，1650 显卡也足够我用了。 另外，因为是游戏本的缘故，R7000 净重达到了 2kg 以上，呃，练武之人标配。 电池方面 也中规中矩，60Wh 不过可以自己手动换电池。 当然了，R7000 在本身提供了 512SSD 的同时，也留出了添加固态/机械硬盘的地方。 其余最大的坑就是抽奖机制了，以下硬件均为混搭： 内存*2 三星 海力士 西部数码 屏幕 京东方 龙腾 因为硬件混搭，网上有很多“一等奖”、“二等奖”的说法，但如果验机没有大问题的话，其实不必在意硬件的差别。 如何验机硬件篇开机前 查看是否出现 包装损坏严重或机器已经被拆封。 检查外观是否出现划痕、指纹、掉漆。 液晶屏是否有划伤、磨损、指纹。 检查摄像头的物理拨片。 检查键盘是否出现问题。 检查触摸板按压是否出现问题。 D 面底脚是否有磨损。 配件是否齐全。 轻轻摇晃笔记本电脑，听是否有异响。 查看螺丝是否有拆卸的痕迹。 开机后 检查（联保凭证、说明书）的序列号是否与机身序列号、（BIOS 中的序列号 (AIDA64 -&gt; 计算机 -&gt; 系统概述 -&gt; DMI -&gt; 主板序列号)、Windows 系统 -&gt; 关于 -&gt; 序列号。相同。 查看在不通电源的情况，是否能开机，如果开机成功，那就意味着买到了二手货。 在黑暗情况下，反复开机，检查屏幕是否漏光，如不严重就算正常。 使用软件或纯色图检查屏幕坏点。 一般来说，有 1-3 个坏点算正常，太多了就不正常了。 摄像头是否正常。 是否可以正常播放声音 仔细听是否有杂音、破音等异响。。 软件篇先不联网，不激活系统，不激活 Office，用默认管理员开机，不然就无法享受七天无理由退货了。 进入 BIOS 查看信息是否一致。 查看接口是否正常。 系统硬件管理器各部件驱动是否正常，是否有未识别硬件。 卡硬工具箱 的各种工具。 图吧工具箱 的各种工具。 其实4,5点是重点，它们几乎整合了市面上所有知名的测评软件，非常推荐。 系统设置重装系统如果 windows 2004 专业版在买完之后已经推送，那么我很乐意做第一个吃螃蟹的人。 否则 就安装 windows 1909 专业版。 后续：现已推送 2004。 硬盘分区 C 盘 400G (系统/软件) D 盘 112G (文档/冷数据) 我现在这台使用了近 4 年的笔电，实际花费存储空间也就不到256G。 所以说，512G 够我用一段时间了。 细节设置 色彩校正 输入法改为双拼 先过一遍 windows 设置 使用 Dism++ 更深入地修改系统功能 管理员权限 开机免输入密码 电源管理合上盖子操作 高性能模式设置 桌面，开始页面图标设置 关闭 Windows Defender Bios 更新 驱动更新 暂时就想到这么多，先跳过。 软件安装我估计这是本篇文章中最花费时间的章节，因为我本身就是一个收集癖，还喜欢折腾各种效率的软件，这几年积累了不少，所以说，以下都是我的藏家宝。 Chrome 书签，设置都会同步，而插件方面，大部分单机插件都会自动同步下载，其中一些需要配置文件的插件需要手动同步，比如: stylus,crxMouse,vimium 等。 plugin 呃，这就是我 chrome 上的所有插件，还挺多吧。 网易云音乐，平时就听个响。 阿里邮箱 Telegram Typora，所见即所得的 markdown 编辑器 Xmind8 脑图软件，有时会用到 微软 TODO，一款强大的跨平台 TODO 软件，用了很多年了 Postman 接口调试软件 Everything 搜索软件，强大得不用解释 Wallpaper Engine 第一人称射击游戏，懂得都懂… SpaceSniffer 可视化查看硬盘空间分布的软件 Scrcpy/ScrcpyGui 自己写的控制手机的软件 火绒 - 杀毒软件 卡硬工具箱 图吧工具箱 EarTrumpet 强化版声音管理软件，可单独设置某软件的声音 OBS Studio 知名推流软件, 我用来录屏 WGesture 超级厉害的手势软件，可谓是一大效率神器 Ditto 历史剪切板 Snipaste 截图工具 Seer 快速查看文档神器，就好比 Mac 上对文件的空格键 TranslucentTB 任务栏透明软件 Bandzip 解压缩工具 FileMenu Tools 可直接右键复制文件路径 QTTabBar 一款强大的标签化资源管理器, 效率神器 MacType windows 下字体渲染优化软件 PotPlayer windows 下播放视频软件 Git 版本控制软件 Terminus，一款 Shell 终端的可视化软件，又好看又能打 WSL Notepads APP 可替代原生的 windows 记事本 *pn 小飞机 Stream 暴雪游戏平台 WeGame FDM 下载文件神器 VSCode 轻量级编辑器，可借助Settings Sync插件，来同步配置。 xshell / xftp Gradle - better maven 字体 - Roboto/FairCode/source-code-pro/JetBrainsMono 到货后续京东方是 6.1 日正式开售，所以等到下周才能收到货了。 呐，先留个坑~ 6.2 日上午到货了，我抽到的配置是双三星 + 龙腾屏，然而我是真没想到屏幕会翻车。 昨天测试屏幕下来，有不少明显的问题： 拖影严重，效果不及我的老笔电。 这是 R7000 与我老笔电的对比图： asus1 legion 漏光严重，四面皆漏光。 legion-light 屏幕泛黄，不通透，调了一晚上色温，最后头都大了，效果也一般。 屏幕仔细看有竖条阴影，横条阴影。 屏幕坏点也不少。 说实话，我是真不想退货瞎折腾，可是屏幕是最重要的外设之一，内存固态可以次一点，反正性能早就过剩了，可屏幕真忍不了。 并且，网上反复换货依旧是龙腾屏的例子也有很多，所以我直接选择退了。 现在系统已激活，本以为京东方不会同意我退货的申请，结果却同意了。 如果后续厂家同意退货就退了，不同意的话就换到京东方屏幕为止。 哎，下次，再也不会买抽奖制的产品了，同样的价钱不同的体验，心累。 最终选择遇见又经过长时间的挑选后，我最终再次锁定了拯救者系列中的Y9000K型号，在这期间我几乎摸遍了市面上的所有笔电，它们都有让我不能接受的缺点，我曾一度想做等等党，可是无意间看到了它，拯救者系列中的旗舰机皇-Y9000K。 我记得第一次见到它 是在一个炎炎夏日的中午，那时的我很燥，感叹到市场上竟没有一款让我心动的笔电。 当无意间看到它的宣传图时，我扫了一遍，找下让我吐槽的点，咦，这个有点不对劲，再仔细盯了几秒后，卧槽，可以啊。 y9000k-poster 网上找了所有的翻车信息后，对我来说 都是一些无关痛痒的缺点。 我突然意识到，我想买的笔电，它来了。 Y9KK，冲冲冲~ 得到由于在当时Y9000K只卖了第一批 Z 码，市面上除了黄牛基本没货。 要等到官方货源 只能 618 抢购，除此之外 别无他法，所以煎熬的狙击开始了。 我分别在淘宝，官网，京东都预约好了商品，并订了 8 个闹钟，做好了法事（内心）。 而在 618 之前官方暴露得知，全国Y9KK丐版只有 600 台，这让我心中一沉，简直是第二个yoga 14s啊，如果抢不到，就只能等到今年下半场的厂商战争了。 不过万幸的是，我在京东居然抢到了有赠品的丐版！我抢到了！ 当时的场景可以说秒没，到0：00后直接显示没货… 而我第一次点击时，也直接提示当地没货，第二次点击才得到货单，谢天谢地。 呃，我今年的欧气全压在这了。 食用到货开机后，第一眼给我的观感是鲜艳，因为Y9KK采用的是广色域屏，让你觉得它的屏幕色彩都能溢出来。 我也是第一次知道 Windows 的红色警告可以这么红，麦克雷的胡子原来是褐色，一直使用的 Solarized Light 主题原来是这种偏黄色… 质感方面 因为全机身金属，可以说 B 格与触感同时拉满。 散热方面 使用的是 VC 液冷，双烤能达到 45w+90w，不算高 但也足够用了。 接口方面 除了常见的接口，还赠了一个雷电三。 … 具体可以去 b 站看一下评测视频，我就不罗嗦了… 总之，给我的感受是真香，可以称得上愉快的购物体验。 评价在我看来，它的优缺点都很鲜明。 优点我就不过多介绍了，上面吹得够可以了，主要说下缺点。 性价比一般。 2020 年 10875H 卖 1w+？怕不是要被 AMD 干死，市面上的 4800H 完全可以与 10875H 一较高下，但价钱却便宜很多。最近 Y7000P 也出了 10875H，价格降到了 8K+… 没货，没货，没货。 品控一般，群里翻车的真的不少，不过我除了一个屏幕坏点外，什么也没遇到。 结束语如果你也有购买笔电的需求，可以随时与我联系，一起讨论~ 欢迎转载本站文章，请注明作者和出处 SimonAKing。","categories":[{"name":"设备","slug":"设备","permalink":"https://simonaking.com/blog/categories/%E8%AE%BE%E5%A4%87/"}],"tags":[{"name":"设备","slug":"设备","permalink":"https://simonaking.com/blog/tags/%E8%AE%BE%E5%A4%87/"},{"name":"Windows","slug":"Windows","permalink":"https://simonaking.com/blog/tags/Windows/"}]},{"title":"30s 源码刨析系列之函数篇","date":"2020-03-01T03:43:52.000Z","path":"/30s-javascript-function/","text":"由浅入深、逐个击破 30SecondsOfCode 中函数系列所有源码片段，带你领略源码之美。 前言本系列是对名库 30SecondsOfCode 的深入刨析。 本篇是其中的函数篇，可以在极短的时间内培养你的函数式思维。 内容根据源码的难易等级进行排版，目录如下： 新手级 普通级 专家级 正文新手级checkPropconst checkProp = (predicate, prop) =&gt; obj =&gt; !!predicate(obj[prop]);const lengthIs4 = checkProp(l =&gt; l === 4, 'length');lengthIs4([]); // falselengthIs4([1, 2, 3, 4]); // truelengthIs4(new Set([1, 2, 3, 4])); // false (Set uses Size, not length)const session = { user: {} };const validUserSession = checkProp(u =&gt; u.active &amp;&amp; !u.disabled, 'user');validUserSession(session); // falsesession.user.active = true;validUserSession(session); // trueconst noLength = checkProp(l =&gt; l === undefined, 'length');noLength([]); // falsenoLength({}); // truenoLength(new Set()); // true 作用：检查参数是否存在给定的属性。 解析：给定一个检查函数，和所需检查的属性名，返回一个函数。可通过调用 返回的函数，去判定 传入的对象参数是否符合检查函数。 functionNameconst functionName = fn =&gt; (console.debug(fn.name), fn);functionName(Math.max); // max (logged in debug channel of console) 作用：打印函数名。 解析：使用console.debugAPI 和函数的name属性，把 函数类型参数的名字 打印到控制台的 debug channel 中。 negateconst negate = func =&gt; (...args) =&gt; !func(...args);[1, 2, 3, 4, 5, 6].filter(negate(n =&gt; n % 2 === 0)); // [ 1, 3, 5 ] 作用：反转 谓词函数（返回类型为布尔的函数）的返回结果。 解析：假设有一谓词函数为func = args =&gt; bool，我们想要反转其结果，便可对它的调用方式进行进一步的抽象，把反转结果的逻辑放置抽象中。 在本函数中，只需要一个 逻辑非运算符!func(...args)。 而扩展运算符...是对参数的抽象，代表的是传入的所有参数，我们要将所有参数一个不差地传递，不可破环 谓词函数的“纯洁性”。 unaryconst unary = fn =&gt; val =&gt; fn(val);['6', '8', '10'].map(unary(parseInt)); // [6, 8, 10] 作用：参数函数调用时 只接受 参数函数的第一个参数，忽略其他参数。 解析：包装一个函数，并不做任何处理：wrap = fn =&gt; (...args) =&gt; fn(...args) 很显然，如果想对传入的参数进行处理，只需对args动刀，而本例直接使用了单独的一个变量，忽略了其他参数。 普通级aryconst ary = (fn, n) =&gt; (...args) =&gt; fn(...args.slice(0, n));const firstTwoMax = ary(Math.max, 2);[[2, 6, 'a'], [6, 4, 8], [10]].map(x =&gt; firstTwoMax(...x)); // [6, 6, 1 作用：参数函数调用时 只接受 参数函数的前 n 个参数，忽略其他参数。 解析：和上列逻辑如出一辙，只不过处理参数的逻辑换成了...args.slice(0, n)，只要前 n 个。 attemptconst attempt = (fn, ...args) =&gt; { try { return fn(...args); } catch (e) { return e instanceof Error ? e : new Error(e); }};var elements = attempt(function(selector) { return document.querySelectorAll(selector);}, '&gt;_&gt;');if (elements instanceof Error) elements = []; // elements = [] 作用：对 参数函数 进行异常捕获，如果有异常则抛出。 解析：对 参数函数 进行进一步封装，本例封装的逻辑是try catch，即捕获参数函数的异常。 很久之前，我看到过一个关于java8的 attempt 片段，里面还增加了重试逻辑。 js 实现代码如下: const attempt = (fn, ...args, count, bound) =&gt; { try { return fn(...args); } catch (e) { if(count == bound){ return e instanceof Error ? e : new Error(e); } return attempt(fn, ...args, count + 1, bound) }}; bindconst bind = (fn, context, ...boundArgs) =&gt; (...args) =&gt; fn.apply(context, [...boundArgs, ...args]);function greet(greeting, punctuation) { return greeting + ' ' + this.user + punctuation;}const freddy = { user: 'fred' };const freddyBound = bind(greet, freddy);console.log(freddyBound('hi', '!')); // 'hi fred!' 作用：原生 API-bind的另一种实现。 fn.bind(context,...args) =&gt; bind(fn,context,...args) MDN 关于 bind 的解释： bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。 解析：首先，使用了apply将给定的 上下文参数 应用于 参数函数。 其次，利用 apply 只接受数组作为参数的规定，将最初传入的参数，和后续传入的参数按顺序合并在一个数组中传递进去。 bindKeyconst bindKey = (context, fn, ...boundArgs) =&gt; (...args) =&gt; context[fn].apply(context, [...boundArgs, ...args]);const freddy = { user: 'fred', greet: function(greeting, punctuation) { return greeting + ' ' + this.user + punctuation; }};const freddyBound = bindKey(freddy, 'greet');console.log(freddyBound('hi', '!')); // 'hi fred!' 作用：把上列中的fn换成了context[fn]。 解析：我们原来的 参数函数 变成了一个 上下文参数的一个属性，而将这个属性依附于上下文对象就成了一个函数context[fn]。 可以说，这个一个调用方式特殊的bind。 callconst call = (key, ...args) =&gt; context =&gt; context[key](...args);Promise.resolve([1, 2, 3]) .then(call('map', x =&gt; 2 * x)) .then(console.log); // [ 2, 4, 6 ]const map = call.bind(null, 'map');Promise.resolve([1, 2, 3]) .then(map(x =&gt; 2 * x)) .then(console.log); // [ 2, 4, 6 ] 作用：动态改变函数执行的上下文。 解析：给定一个属性参数，再给定一组调用参数，返回一个接受上下文对象的函数，并最终组合调用。 其实这里面暗含了一个约束，很显然，context[key]必须是一个函数。 这个片段本质是对上下文的抽象。举个例子： const filterMen = call('filter', person =&gt; person.sex === 'man')filterMen([{sex:'woman',...},{sex:'man',...},...])// 如果有其他 上下文对象，本例中也就是数组 需要相同的 逻辑过滤呢？ chainAsyncconst chainAsync = fns =&gt; { let curr = 0; const last = fns[fns.length - 1]; const next = () =&gt; { const fn = fns[curr++]; fn === last ? fn() : fn(next); }; next();};chainAsync([ next =&gt; { console.log('0 seconds'); setTimeout(next, 1000); }, next =&gt; { console.log('1 second'); setTimeout(next, 1000); }, () =&gt; { console.log('2 second'); }]); 作用：将 函数数组转换为有决策权的链式函数调用。 我为什么称之有决策权的链式函数调用呢？ 因为每个函数都会接受一个 next 方法参数，它代表的就是调用链中的下一个函数，所以什么时候调用下一个函数，要不要调用，决策权在你。 解析：其实这个片段很简单。 首先，fns 类型一个函数数组，其中除了最后一个函数都有隐含的约束，可以选择接受 next 参数。 而 next 参数的含义就是调用链中的下一个函数，说白了 就是数组中的下一个成员。 而最后一个函数是无参函数。 片段中复杂点在于：利用闭包存储了两个关键变量。 第一个是 调用链中的函数游标:curr；第二个是结束标志，最后一个函数:last。 每次链式向下调用前，都会进行一些逻辑处理： const next = () =&gt; { const fn = fns[curr++]; fn === last ? fn() : fn(next);}; 先取出当前游标所在函数，再把游标指向下一个函数。 然后，判断是否是最后一个函数，是则直接调用，结束；反之，传入 next 调用。 如果，你是一个后端开发者，可以把其理解为中间件的工作模式。 collectIntoconst collectInto = fn =&gt; (...args) =&gt; fn(args);const Pall = collectInto(Promise.all.bind(Promise));let p1 = Promise.resolve(1);let p2 = Promise.resolve(2);let p3 = new Promise(resolve =&gt; setTimeout(resolve, 2000, 3));Pall(p1, p2, p3).then(console.log); // [1, 2, 3] (after about 2 seconds) 作用：将接受数组的函数更改为接受可变参数。 分析：利用了扩展运算符的性质，...args代表的是所有参数组成的数组，然后将这数组传递进去调用。 可别小看了这一片段，调用方式的改变会决定很多上层逻辑。 平常我们大概率都会，建立一个数组，收集所需的异步函数。 在本例中，很明显的看到 从参数为数组类型的约束 中解放了出来。 composeconst compose = (...fns) =&gt; fns.reduce((f, g) =&gt; (...args) =&gt; f(g(...args)));const substract3 = x =&gt; x - 3;const add5 = x =&gt; x + 5;const multiply = (x, y) =&gt; x * y;const multiplyAndAdd5AndSubstract3 = compose( substract3, add5, multiply);multiplyAndAdd5AndSubstract3(5, 2); // 12 作用：将传入的多个[异步]函数以组合的方式 调用。 先将参数传入最后一个[异步]函数，然后将得到的结果，传入倒数第二个[异步]函数，以此类推。 compose可以说是函数式编程的经典片段。 它的具体意义可以说是逻辑分层。像洋葱一样，一层一层地处理数据。 解析：fns 代表的是 传入的多个函数 组成的数组。 利用reduce方法实现函数的“洋葱”包裹。 因为这种逻辑语义表示效果不好，就直接上上面例子的代码流程了。 reduce 第一次循环:f: substract3;g: add5;返回结果：(...args) =&gt; substract3(add5(...args));reduce 第二次循环：f: (...args) =&gt; substract3(add5(...args));g: multiply;返回结果：(...args1) =&gt; ((...args2) =&gt; substract3(add5(...args2)))(multiply(...args1))优化后:(...args) =&gt; substract3(add5(multiply(...args)));循环下去，以此类推...最后的返回的形式：(...args) =&gt; 第一个函数(第二个函数(第三个函数(...最后一个函数(...args)))) PS: 说实话，我并不喜欢 compose，在上例中就可以很明显的看到缺点。 把很多函数组合起来，第一是缺少语义化，与之对应的例子就是 Promise 的 then 调用链，语义鲜明； 第二是无法添加函数与函数之间的抽象逻辑，只能一次写好。 第三是各个函数之间存在隐含的参数约束，很可怕的。 composeRightconst composeRight = (...fns) =&gt; fns.reduce((f, g) =&gt; (...args) =&gt; g(f(...args)));const add = (x, y) =&gt; x + y;const square = x =&gt; x * x;const substract3 = x =&gt; x - 3;const addAndSquare = composeRight(add, square,substract3);addAndSquareAndSubstract3(1, 2); // 6 作用：将传入的多个[异步]函数以组合的方式 调用。 先将参数传入第一个[异步]函数，然后将得到的结果，传入第二个[异步]函数，以此类推。 convergeconst converge = (converger, fns) =&gt; (...args) =&gt; converger(...fns.map(fn =&gt; fn.apply(null, args)));const average = converge((a, b) =&gt; a / b, [ arr =&gt; arr.reduce((a, v) =&gt; a + v, 0), arr =&gt; arr.length]);average([1, 2, 3, 4, 5, 6, 7]); // 4 作用：将 函数数组的返回结果 传递到converger函数，进一步处理，可用作分析统计。 解析: 使用map 和apply将参数数据传递给每个处理函数，并将处理后的结果交给converger函数。 curryconst curry = (fn, arity = fn.length, ...args) =&gt; arity &lt;= args.length ? fn(...args) : curry.bind(null, fn, arity, ...args);curry(Math.pow)(2)(10); // 1024curry(Math.min, 3)(10)(50)(2); // 2 作用：函数柯里化。 柯里化不管在是函数式思维的理解，还是现实面试中，都非常的重要。 维基百科上 柯里化的解释： 把接受多个参数)的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数 解析：这个bind用得真是神了，借助它积累每次传进来的参数，等到参数足够时，再调用。 debounceconst debounce = (fn, ms = 0) =&gt; { let timeoutId; return function(...args) { clearTimeout(timeoutId); timeoutId = setTimeout(() =&gt; fn.apply(this, args), ms); };};window.addEventListener( 'resize', debounce(() =&gt; { console.log(window.innerWidth); console.log(window.innerHeight); }, 250)); // Will log the window dimensions at most every 250ms 作用：函数防抖。 什么是防抖和节流？有什么区别？如何实现？ 一文中关于防抖解释： 触发高频事件后 n 秒内函数只会执行一次，如果 n 秒内高频事件再次被触发，则重新计算时间。 同样，防抖也是面试必考的点。 解析: 传入需防抖的函数，和防抖的时间间隔，返回一个已防抖化的函数。 主要借助setTimeout和function + apply保存上下文完成。 每次调用函数前，都执行一遍clearTimeout，保证重新计算调用时间。 无论是调用多么频繁的函数都会在指定时间的间隔后只运行一次。 deferconst defer = (fn, ...args) =&gt; setTimeout(fn, 1, ...args);// Example A:defer(console.log, 'a'), console.log('b'); // logs 'b' then 'a'// Example B:document.querySelector('#someElement').innerHTML = 'Hello';longRunningFunction(); // Browser will not update the HTML until this has finisheddefer(longRunningFunction); // Browser will update the HTML then run the function 作用：推迟调用函数，直到清除当前调用堆栈。 可适用于推迟 cpu 密集型计算，以免阻塞渲染引擎工作。 分析：使用setTimeout（超时时间为 1ms）将 函数参数 添加到浏览器事件队列末尾。 因为 JavaScript 是单线程执行，先是主线程执行完毕，然后在读取事件队列中的代码执行。 如果主线程有运行时间太长的函数，会阻塞页面渲染，所以将其放置到事件队列。 delayconst delay = (fn, wait, ...args) =&gt; setTimeout(fn, wait, ...args);delay( function(text) { console.log(text); }, 1000, 'later'); // Logs 'later' after one second. 作用：延迟函数执行。 是的，它和defer非常像，但使用场景却是不一样。 defer 的目的是将占据主线程时间长的函数推迟到事件队列。 而 delay 只是字面意思，延迟执行。 解析：对 setTimeout 进行语义化封装。 flipconst flip = fn =&gt; (first, ...rest) =&gt; fn(...rest, first);let a = { name: 'John Smith' };let b = {};const mergeFrom = flip(Object.assign);let mergePerson = mergeFrom.bind(null, a);mergePerson(b); // == bb = {};Object.assign(b, a); // == b 作用：对 参数函数 的输入数据进行进一步处理，将数据的第一个参数与其余参数位置对调。 解析：主要利用 扩展运算符的性质，对参数的位置进行调整。 如果你不了解这一语言特性，可参考阮一峰老师的ES6 入门。 hzconst hz = (fn, iterations = 100) =&gt; { const before = performance.now(); for (let i = 0; i &lt; iterations; i++) fn(); return (1000 * iterations) / (performance.now() - before);};// 10,000 element arrayconst numbers = Array(10000) .fill() .map((_, i) =&gt; i);// Test functions with the same goal: sum up the elements in the arrayconst sumReduce = () =&gt; numbers.reduce((acc, n) =&gt; acc + n, 0);const sumForLoop = () =&gt; { let sum = 0; for (let i = 0; i &lt; numbers.length; i++) sum += numbers[i]; return sum;};// `sumForLoop` is nearly 10 times fasterMath.round(hz(sumReduce)); // 572Math.round(hz(sumForLoop)); // 4784 作用：返回函数每秒执行一次的次数。 hz 是赫兹的单位（频率的单位）定义为每秒一个周期。 解析：通过两次使用performance.now获取iterations次迭代前后的毫秒差。 然后将毫秒转换为秒并除以经过的时间，可以得到每秒的函数执行次数。 PS: 此处，并没有太好的个人理解，翻译自官方。 onceconst once = fn =&gt; { let called = false; return function(...args) { if (called) return; called = true; return fn.apply(this, args); };};const startApp = function(event) { console.log(this, event); // document.body, MouseEvent};document.body.addEventListener('click', once(startApp)); // only runs `startApp` once upon click 作用：确保一个函数只被调用一次。 分析：因为 JavaScript 是单线程执行环境，不需要考虑并发环境，直接一个内部变量存到闭包中，每次调用前判断，并在第一次调用时，修改其值，让后续调用全部失效。 给你看一下 Go 的 once，官方是通过atomic库实现的： package syncimport ( \"sync/atomic\")type Once struct { m Mutex done uint32}func (o *Once) Do(f func()) { if atomic.LoadUint32(&amp;o.done) == 1 { return } o.m.Lock() defer o.m.Unlock() if o.done == 0 { defer atomic.StoreUint32(&amp;o.done, 1) f() }} overconst over = (...fns) =&gt; (...args) =&gt; fns.map(fn =&gt; fn.apply(null, args));const minMax = over(Math.min, Math.max);minMax(1, 2, 3, 4, 5); // [1,5] 作用：利用函数数组，对接下来的输入数据进行处理，得到每个函数处理后的结果数组。 解析：使用map和apply将输入的数据传递到每个函数中进行处理。 overArgsconst overArgs = (fn, transforms) =&gt; (...args) =&gt; fn(...args.map((val, i) =&gt; transforms[i](val)));const square = n =&gt; n * n;const double = n =&gt; n * 2;const fn = overArgs((x, y) =&gt; [x, y], [square, double]);fn(9, 3); // [81, 6] 作用：利用 transforms 函数数组，分别处理相应位置的输入数据，并把结果传递进给定函数。 解析：transforms 函数数组 和参数必须位置对应，这个约束有点强啊。 partialconst partial = (fn, ...partials) =&gt; (...args) =&gt; fn(...partials, ...args);const greet = (greeting, name) =&gt; greeting + ' ' + name + '!';const greetHello = partial(greet, 'Hello');greetHello('John'); // 'Hello John!' 作用：将调用函数的数据分为两次输入，并按正序调用。 解析：两次使用扩展运算符（…），保存不同时期的数据，最后调用。 partialRightconst partialRight = (fn, ...partials) =&gt; (...args) =&gt; fn(...args, ...partials);const greet = (greeting, name) =&gt; greeting + ' ' + name + '!';const greetJohn = partialRight(greet, 'John');greetJohn('Hello'); // 'Hello John!' 作用：将调用函数的数据分为两次输入，并按反序调用。 解析：两次使用扩展运算符（…），保存不同时期的数据，最后调用。 pipeAsyncFunctionsconst pipeAsyncFunctions = (...fns) =&gt; arg =&gt; fns.reduce((p, f) =&gt; p.then(f), Promise.resolve(arg));const sum = pipeAsyncFunctions( x =&gt; x + 1, x =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve(x + 2), 1000)), x =&gt; x + 3, async x =&gt; (await x) + 4);(async () =&gt; { console.log(await sum(5)); // 15 (after one second)})(); 作用：将传入的多个[异步]函数按照正序 依次调用。 解析：结合reduce和Promise.then，将数据按照正序传递到每个[异步]函数,进行处理，处理的结果又传给下一个[异步]函数，以此类推。 promisifyconst promisify = func =&gt; (...args) =&gt; new Promise((resolve, reject) =&gt; func(...args, (err, result) =&gt; (err ? reject(err) : resolve(result))) );const delay = promisify((d, cb) =&gt; setTimeout(cb, d));delay(2000).then(() =&gt; console.log('Hi!')); // // Promise resolves after 2s 作用：将回调函数改为Promise方式处理结果。 在 Node8+ ，你可以使用util.promisify 解析：首先接受给定的回调函数，然后直接在 Promise 中调用该函数。 因为回调函数的结果按照规范永远是最后一个参数，我们只需要在函数调用时，把最后一个参数换成 Promise 的方式，即：如果回调函数出现错误则 reject，反之 resolve。 注意：被 promisify 的函数必须接受回调参数且后续会调用。 reargconst rearg = (fn, indexes) =&gt; (...args) =&gt; fn(...indexes.map(i =&gt; args[i]));var rearged = rearg( function(a, b, c) { return [a, b, c]; }, [2, 0, 1]);rearged('b', 'c', 'a'); // ['a', 'b', 'c'] 作用：根据指定的索引重新排列传入的参数。 解析：利用map结合扩展运算符，重新排列传入的参数，并将转换后的参数传递给 fn。 runPromisesInSeriesconst runPromisesInSeries = ps =&gt; ps.reduce((p, next) =&gt; p.then(next), Promise.resolve());const delay = d =&gt; new Promise(r =&gt; setTimeout(r, d));runPromisesInSeries([() =&gt; delay(1000), () =&gt; delay(2000)]);// Executes each promise sequentially, taking a total of 3 seconds to complete 作用：按照正序 运行给定的多个返回类型为 Promise 函数。 解析：使用reduce创建一个 Promise 链，每次运行完一个传入的 Promise，都会返回最外部的Promise.then，从而进行下一次调用。 sleepconst sleep = ms =&gt; new Promise(resolve =&gt; setTimeout(resolve, ms));async function sleepyWork() { console.log(\"I'm going to sleep for 1 second.\"); await sleep(1000); console.log('I woke up after 1 second.');} 作用: 延迟异步函数的执行。 解析：创建一个接受毫秒数的函数，并结合setTimeout，在给定的毫秒数后，返回一个resolve状态的 Promise。 使用场景：利用异步函数的“同步”机制(await)，使其在异步函数中达到“睡眠”的效果。 spreadOverconst spreadOver = fn =&gt; argsArr =&gt; fn(...argsArr);const arrayMax = spreadOver(Math.max);arrayMax([1, 2, 3]); // 3 作用：将接受可变参数的函数更改为接受数组。 如果你认真读了文章，就会发现这是collectInto函数的反模式。 分析：利用了扩展运算符的性质，将传递进来的数组解构再交给处理函数。 timesconst times = (n, fn, context = undefined) =&gt; { let i = 0; while (fn.call(context, i) !== false &amp;&amp; ++i &lt; n) {}};var output = '';times(5, i =&gt; (output += i));console.log(output); // 01234 作用：将给定的函数，迭代执行 n 次。 分析：使用Function.call迭代调用给定的函数，并把迭代的次数传进函数第一个参数。 如果函数返回 false 可提前退出。 uncurryconst uncurry = (fn, n = 1) =&gt; (...args) =&gt; { const next = acc =&gt; args =&gt; args.reduce((x, y) =&gt; x(y), acc); if (n &gt; args.length) throw new RangeError('Arguments too few!'); return next(fn)(args.slice(0, n));};const add = x =&gt; y =&gt; z =&gt; x + y + z;const uncurriedAdd = uncurry(add, 3);uncurriedAdd(1, 2, 3); // 6 作用：函数反柯里化。 柯里化是将接受多个参数)的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数。 而反柯里化就是将多个接受参数的层层函数，铺平。 解析：反柯里化的关键代码在于 args.reduce((x, y) =&gt; x(y), acc)。 在上例中,args: [1,2,3]acc: x =&gt; y =&gt; z =&gt; x + y + z第一次循环：x：x =&gt; y =&gt; z =&gt; x + y + zy：1返回结果：y =&gt; z =&gt; 1 + y + z第二次循环:x: y =&gt; z =&gt; 1 + y + zy: 2返回结果：z =&gt; 1 + 2 + z最后一次循环的结果，即 1 + 2 +3 可以看出，每次一循环，都会利用闭包”填充”一个所需变量。 返回的结果分为两种情况： 一是 一个保留了 n 个前置参数的函数。 二是层叠函数中最后一个函数的返回结果。 值得一提的是，在源码中使用了slice(0，n)保留适当数量的参数。 如果提供的参数的个数小于给定的解析长度，就会抛出错误。 unfoldconst unfold = (fn, seed) =&gt; { let result = [], val = [null, seed]; while ((val = fn(val[1]))) result.push(val[0]); return result;};var f = n =&gt; (n &gt; 50 ? false : [-n, n + 10]);unfold(f, 10); // [-10, -20, -30, -40, -50] 作用：使用种子值以及特殊的数据存储与迭代方式构建一个数组。 解析: 我为什么说数据存储与迭代方式很特殊呢？ 迭代的变量与结果值，保存在同一数组里，用 01 下标区分。 而迭代的函数，也需要满足这一规范，返回同样的数组[value，nextSeed]，保证下一次迭代，或者返回 false 终止过程。 whenconst when = (pred, whenTrue) =&gt; x =&gt; (pred(x) ? whenTrue(x) : x);const doubleEvenNumbers = when(x =&gt; x % 2 === 0, x =&gt; x * 2);doubleEvenNumbers(2); // 4doubleEvenNumbers(1); // 1 作用：根据pred函数测试给定数据。如结果为真，则执行whenTrue函数；反之，返回数据。 解析: 我喜欢语义化的封装，可大幅提升代码的可读性，减少逻辑负担。 专家级memoizeconst memoize = fn =&gt; { const cache = new Map(); const cached = function(val) { return cache.has(val) ? cache.get(val) : cache.set(val, fn.call(this, val)) &amp;&amp; cache.get(val); }; cached.cache = cache; return cached;};// See the `anagrams` snippet.const anagramsCached = memoize(anagrams);anagramsCached('javascript'); // takes a long timeanagramsCached('javascript'); // returns virtually instantly since it's now cachedconsole.log(anagramsCached.cache); // The cached anagrams map 作用：为给定的函数添加缓存功能。 解析: 通过实例化一个新的Map对象来创建一个空的缓存。 并对函数的调用进一步的封装，如果调用时，传入了一个之前已经传递过的参数，将从缓存中直接返回结果，执行时间为 O(1)；如果是首次传递，则需运行函数，将得到结果缓存，并返回。 其实，我们还可以借助这个片段，看到一丝 JavaScript 语法的残缺。 到目前为止，一个社区公认的私有属性语法都没有，TC39 一直提议用#号，并阐述了很多原因、声明。 哎，说白了，就是 JavaScript 从一开始设计的失误，到现在已经无法挽回了。 throttleconst throttle = (fn, wait) =&gt; { let inThrottle, lastFn, lastTime; return function() { const context = this, args = arguments; if (!inThrottle) { fn.apply(context, args); lastTime = Date.now(); inThrottle = true; } else { clearTimeout(lastFn); lastFn = setTimeout(function() { if (Date.now() - lastTime &gt;= wait) { fn.apply(context, args); lastTime = Date.now(); } }, Math.max(wait - (Date.now() - lastTime), 0)); } };};window.addEventListener( 'resize', throttle(function(evt) { console.log(window.innerWidth); console.log(window.innerHeight); }, 250)); // Will log the window dimensions at most every 250ms 作用: 函数节流。 什么是防抖和节流？有什么区别？如何实现？ 一文中关于防抖解释： 高频事件触发，但在 n 秒内只会执行一次，所以节流会稀释函数的执行频率。 同样，节流也是面试必考的点。 解析：第一次执行时，立即执行给定函数，保存当前的时间，并设置标记变量。 标记变量主要用于判断是否第一次调用，如果是第一次则立刻运行。 反之不是第一次运行，过了等待的毫秒后才可继续运行。 主要逻辑是每次运行前先清除上一个的定时器，然后计算出上一次运行的时间与给定的运行间隔所差的毫秒数，并利用其数据新建一个定时器运行。 定时器里的函数除了调用给定函数，还会更新上一次运行的时间变量。 节流的实现，网上的文章有很多版本，但多少都有点瑕疵。 结束语呼，花了很长的时间，终于搞定了这篇文章。 以后的 30s 源码刨析系列会挑选一些源码片段去解析，而不是针对某一分类了。 本篇文章涉及了我的一些思考，希望能对你有帮助。 欢迎转载本站文章，请注明作者和出处 SimonAKing。","categories":[{"name":"源码","slug":"源码","permalink":"https://simonaking.com/blog/categories/%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"源码","slug":"源码","permalink":"https://simonaking.com/blog/tags/%E6%BA%90%E7%A0%81/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://simonaking.com/blog/tags/JavaScript/"},{"name":"函数式","slug":"函数式","permalink":"https://simonaking.com/blog/tags/%E5%87%BD%E6%95%B0%E5%BC%8F/"}]},{"title":"手撸一个静态文档生成器[译]","date":"2020-02-29T04:05:44.000Z","path":"/build-static-site-generator-nodejs/","text":"目前有很多优秀的静态文档生成器，它们的工作原理比你想象的要简单得多。 前言原文: Build a static site generator in 40 lines with Node.js 作者: Douglas Matoso 翻译许可: image img 为什么要造这个轮子当我计划建立个人网站时，我的需求很简单，做一个只有几个页面的网站，放置一些关于自己的信息，我的技能和项目就够了。 毫无疑问，它应该是纯静态的(不需要后端服务，可托管在任何地方)。 我曾经使用过Jekyll, Hugo和Hexo这些知名的静态文档生成器，但我认为它们有太多的功能，我不想为我的网站增加这么多的复杂性。 所以我觉得，针对我的需求，一个简单的静态文档生成器就可以满足。 嗯，手动构建一个简单的生成器，应该不会那么难。 正文需求分析这个生成器必须满足以下条件： 从EJS模板生成HTML文件。 具有布局文件，所有页面都应该具有相同的页眉，页脚，导航等。 允许可重用布局组件。 站点的大致信息封装到一个配置文件中。 从 JSON 文件中读取数据。 例如：项目列表，这样我可以轻松地迭代和构建项目页面。 为什么使用 EJS 模板? 因为 EJS 很简单，它只是嵌入在 HTML 中的 JavaScript 而已。 项目结构public/ src/ assets/ data/ pages/ partials/ layout.ejs site.config.js public: 生成站点的位置。 src: 源文件。 src/assets: 包含 CSS, JS, 图片 等 src/data: 包含 JSON 数据。 src/pages: 根据其中的 EJS 生成 HTML 页面的模板文件夹。 src/layout.ejs: 主要的原页面模板，包含特殊&lt;%-body%&gt;占位符，将插入具体的页面内容。 site.config.js: 模板中全局配置文件。 生成器生成器代码位于scripts/build.js文件中，每次想重建站点时，执行npm run build命令即可。 实现方法是将以下脚本添加到package.json的scripts块中： \"build\": \"node ./scripts/build\" 下面是完整的生成器代码： const fse = require('fs-extra')const path = require('path')const { promisify } = require('util')const ejsRenderFile = promisify(require('ejs').renderFile)const globP = promisify(require('glob'))const config = require('../site.config')const srcPath = './src'const distPath = './public'// clear destination folderfse.emptyDirSync(distPath)// copy assets folderfse.copy(`${srcPath}/assets`, `${distPath}/assets`)// read page templatesglobP('**/*.ejs', { cwd: `${srcPath}/pages` }) .then((files) =&gt; { files.forEach((file) =&gt; { const fileData = path.parse(file) const destPath = path.join(distPath, fileData.dir) // create destination directory fse.mkdirs(destPath) .then(() =&gt; { // render page return ejsRenderFile(`${srcPath}/pages/${file}`, Object.assign({}, config)) }) .then((pageContents) =&gt; { // render layout with page contents return ejsRenderFile(`${srcPath}/layout.ejs`, Object.assign({}, config, { body: pageContents })) }) .then((layoutContent) =&gt; { // save the html file fse.writeFile(`${destPath}/${fileData.name}.html`, layoutContent) }) .catch((err) =&gt; { console.error(err) }) }) }) .catch((err) =&gt; { console.error(err) }) 接下来，我将解释代码中的具体组成部分。 依赖我们只需要三个依赖项： ejs 把我们的模板编译成HTML。 fs-extra Node 文件模块的衍生版，具有更多的功能，并增加了Promise的支持。 glob 递归读取目录，返回包含与指定模式匹配的所有文件，类型是数组。 Promisify我们使用Node提供的util.promisify将所有回调函数转换为基于Promise的函数。 它使我们的代码更短，更清晰，更易于阅读。 const { promisify } = require('util')const ejsRenderFile = promisify(require('ejs').renderFile)const globP = promisify(require('glob')) 加载配置在顶部，我们加载站点配置文件，以稍后将其注入模板渲染中。 const config = require('../site.config') 站点配置文件本身会加载其他JSON数据，例如： const projects = require('./src/data/projects')module.exports = { site: { title: 'NanoGen', description: 'Micro Static Site Generator in Node.js', projects }} 清空站点文件夹我们使用fs-extra提供的emptyDirSync函数清空 生成后的站点文件夹。 fse.emptyDirSync(distPath) 拷贝静态资源我们使用fs-extra提供的copy函数，该函数以递归方式复制静态资源 到站点文件夹。 fse.copy(`${srcPath}/assets`, `${distPath}/assets`) 编译页面模板首先我们使用glob（已被 promisify）递归读取src/pages文件夹以查找.ejs文件。 它将返回一个匹配给定模式的所有文件数组。 globP('**/*.ejs', { cwd: `${srcPath}/pages` }) .then((files) =&gt; { 对于找到的每个模板文件，我们使用Node的path.parse函数来分隔文件路径的各个组成部分（例如目录，名称和扩展名）。 然后，我们在站点目录中使用fs-extra提供的mkdirs函数创建与之对应的文件夹。 files.forEach((file) =&gt; { const fileData = path.parse(file) const destPath = path.join(distPath, fileData.dir) // create destination directory fse.mkdirs(destPath) 然后，我们使用EJS编译文件，并将配置数据作为数据参数。 由于我们使用的是已 promisify 的ejs.renderFile函数，因此我们可以返回调用结果，并在下一个promise链中处理结果。 .then(() =&gt; { // render page return ejsRenderFile(`${srcPath}/pages/${file}`, Object.assign({}, config))}) 在下一个then块中，我们得到了已编译好的页面内容。 现在，我们编译布局文件，将页面内容作为body属性传递进去。 .then((pageContents) =&gt; { // render layout with page contents return ejsRenderFile(`${srcPath}/layout.ejs`, Object.assign({}, config, { body: pageContents }))}) 最后，我们得到了生成好的编译结果（布局+页面内容的 HTML），然后将其保存到对应的HTML文件中。 .then((layoutContent) =&gt; { // save the html file fse.writeFile(`${destPath}/${fileData.name}.html`, layoutContent)}) 调试服务器为了使查看结果更容易，我们在package.json的scripts中添加一个简单的静态服务器。 \"serve\": \"serve ./public\" 运行 npm run serve 命令，打开http://localhost:5000就看到结果了。 进一步探索Markdown大多数静态文档生成器都支持以Markdown格式编写内容。 并且，它们还支持以YAML格式在顶部添加一些元数据，如下所示： ---title: Hello Worlddate: 2013/7/13 20:46:25--- 只需要一些修改，我们就可以支持相同的功能了。 首先，我们必须增加两个依赖: marked 将markdown编译为HTML front-matter 从markdown中提取元数据(front matter)。 然后，我们将glob的匹配模式更新为包括.md文件，并保留.ejs，以支持渲染复杂页面。 如果想要部署一些纯 HTML 页面，还需包含.html。 globP('**/*.@(md|ejs|html)', { cwd: `${srcPath}/pages` }) 对于每个文件，我们都必须加载文件内容，以便可以在顶部提取到元数据。 .then(() =&gt; { // read page file return fse.readFile(`${srcPath}/pages/${file}`, 'utf-8')}) 我们将加载后的内容传递给front-matter。 它将返回一个对象，其中attribute属性便是提取后的元数据。 然后，我们使用此数据扩充站点配置。 .then((data) =&gt; { // extract front matter const pageData = frontMatter(data) const templateConfig = Object.assign({}, config, { page: pageData.attributes }) 现在，我们根据文件扩展名将页面内容编译为 HTML。 如果是.md，则利用marked函数编译; 如果是.ejs，我们继续使用EJS编译; 如果是.html，便无需编译。 let pageContentswitch (fileData.ext) { case '.md': pageContent = marked(pageData.body) break case '.ejs': pageContent = ejs.render(pageData.body, templateConfig) break default: pageContent = pageData.body} 最后，我们像以前一样渲染布局。 增加元数据，最明显的一个意义是，我们可以为每个页面设置单独的标题，如下所示： ---title: Another Page--- 并让布局动态地渲染这些数据： &lt;title&gt;&lt;%= page.title ? `${page.title} | ` : '' %&gt;&lt;%= site.title %&gt;&lt;/title&gt; 如此一来，每个页面将具有唯一的&lt;title&gt;标签。 多种布局的支持另一个有趣的探索是，在特定的页面中使用不同的布局。 比如专门为站点首页设置一个独一无二的布局： ---layout: minimal--- 我们需要有单独的布局文件，我将它们放在src/layouts文件夹中： src/layouts/ default.ejs mininal.ejs 如果front matter出现了布局属性，我们将利用layouts文件夹中同名模板文件进行渲染; 如果未设置，则利用默认模板渲染。 const layout = pageData.attributes.layout || 'default'return ejsRenderFile(`${srcPath}/layouts/${layout}.ejs`, Object.assign({}, templateConfig, { body: pageContent })) 即使添加了这些新特性，构建脚本也才只有60行。 下一步如果你想更进一步，可以添加一些不难的附加功能： 可热重载的调试服务器 你可以使用像live-server (内置自动重新加载) 或 chokidar (观察文件修改以自动触发构建脚本）这样的模块去完成。 自动部署 添加脚本以将站点部署到GitHub Pages等常见的托管服务，或仅通过SSH（使用scp或rsync等命令）将文件上传到你自己的服务器上。 支持 CSS/JS 预处理器 在静态文件被复制到站点文件前，增加一些预处理器(SASS 编译为 CSS,ES6 编译为 ES5 等)。 更好的日志打印 添加一些 console.log 日志输出 来更好地分析发生了什么。 你可以使用chalk包来完善这件事。 反馈？ 有什么建议吗？ 请随时发表评论或与我联系！ 结束语这个文章的完整示例可以在这里找到：https://github.com/doug2k1/nanogen/tree/legacy。 一段时间后，我决定将项目转换为CLI模块，以使其更易于使用，它位于上面链接的master分支中。 译者： 今日本想写一篇ants(一个高性能的goroutine池)源码解析，奈何环境太吵，静不下心，遂罢。 这是一篇我前些日子无意间看到的文章，虽然是17年的文章，在读完之后仍对我产生了一些思考。 希望这篇文章对你有所帮助。 欢迎转载本站文章，请注明作者和出处 SimonAKing。","categories":[{"name":"后端","slug":"后端","permalink":"https://simonaking.com/blog/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"后端","slug":"后端","permalink":"https://simonaking.com/blog/tags/%E5%90%8E%E7%AB%AF/"},{"name":"Nodejs","slug":"Nodejs","permalink":"https://simonaking.com/blog/tags/Nodejs/"},{"name":"译文","slug":"译文","permalink":"https://simonaking.com/blog/tags/%E8%AF%91%E6%96%87/"}]},{"title":"微博","date":"2020-02-07T15:25:39.000Z","path":"/weibo/","text":"💡💡","categories":[{"name":"Page","slug":"Page","permalink":"https://simonaking.com/blog/categories/Page/"}],"tags":[{"name":"Page","slug":"Page","permalink":"https://simonaking.com/blog/tags/Page/"}]},{"title":"如何优雅地写博客","date":"2020-01-24T03:34:00.000Z","path":"/how-to-blog-elegantly/","text":"分享我的写作经历。 前言本文将以我个人写作方式的演变为主线，分三个不同的阶段讲述。 请注意：文章的重点不在于 静态文档生成器，写作平台的选择。 正文安逸的 PC 阶段初识 Hexo在大二刚开学的时候，我便萌生了建立个人博客的念头。 当查阅很多资料后，发现了一款名叫Hexo的静态文档生成器广受好评，网上有关的文章也非常多，于是在大势所趋下，我走上了这漫长的建站之路。 这里闲话两句： 刚开始，我把大量的时间都用在网页交互上，现在回头一想，真是搞错了重点。 对于一个博客来说，内容才是最重要的。 CI 的增持在最初的写作流程很繁琐，主要分为下面几个步骤： 调用Hexo命令新建文章 启动Hexo的本地服务器 编写好文章 在本地服务器上检查是否有遗漏 利用Hexo生成出站点网页 将这些网页push到Github Page上 很容易看出，在PC阶段，与写作无关的流程会浪费不少时间，写作效率很难得到保障。 在无关流程中，第五步骤 生成网页是最占据时间的。 所以，我根据需求进一步为博客加了上持续集成工具。 由于我的博客是私有仓库，大部分的CI工具都是收费的。 迫不得已，我使用了Gitlab，不论项目是private或public，一个月都免费提供 2000 次持续集成，这对一个不常更新的博客来说，足矣。 后续：现在CI工具已选为GithubAction。 其对于私有仓库，一个月免费提供 2000 分钟会话，并且构建速度比Gitlab快 5 倍左右。 So，在持续集成的增持之后，我的写作流程简化成了如下： 调用Hexo命令新建文章 启动Hexo的本地服务器 编写好文章 在本地服务器上检查是否有遗漏 直接将项目push到Gitlab 如此一来，将部署阶段彻底隔离。 Typora-所见即所得在PC上我的写作软件是Typora，所见即所得，简单好用。 typora-theme-tomotoes 上图是我根据Tomotoes样式打磨的一款Typora主题 已开源，欢迎使用。 虽然PC上写作很安逸，但可惜的是，对于一个没有固定自习位置的学生来说，PC的不易携带性会被逐渐放大，一场潜在的变革 在所难免。 极致的 Android 阶段在大三之后，因忙于考试，我的学习设备从沉重的笔记本换成了Android手机。 这方便是方便了，可如何写博客呢？这成了一个难题。 在这个阶段，每当有idea来时，也只能记在本上。 虽说解决了基本需求，但 一纸一笔是很难分享于众的。 对于我来说，这还远远不够。 我曾听说过一句话： 现代人的知识库会因互联网的出现而无限增加。 即，你解决不了的事情，Google就是了。 遗失的神器-Termux很快的，在Google的帮忙下，我找到了我想要的答案—Termux（手机上的Shell）。 termux 哈哈，乍一看 是不是很强大！ 我给它安装了zsh，hexo等一系列软件，并且还配置了桌面化程序。 在我看来，PC上所有的需求几乎都可以实现，称得上一个小型操作系统了。 不过，Termux有个坑。 如果你的Android没有root，它是不支持访问内部文件系统的。 即，外部软件编写好的博文，无法同步到Termux里。 如果刷机root会浪费很长时间，我采取的是软连接+npm钩子临时复制删除的方法。 { \"scripts\": { \"preci\":\"rm -rf ~/blog/source/_posts &amp;&amp; cp -r ~/storage/dcim/_posts ~/blog/source\", \"ci\": \"git add -A &amp;&amp; git commit -am'add new post' &amp;&amp; git push -f gitlab master\", \"postci\": \"rm -rf ~/blog/source/_posts &amp;&amp; ln -s ~/storage/dcim/_posts ~/blog/source/_posts\" }} 如有进一步的问题，请留言。 码字的进一步思考虽说，Android上有如此极客风格的神器，但在写作软件的生态，却差强人意。 在我几乎找遍了Play商店中所有的写作软件之后，我只看上了一款叫做Epsilon Notes的软件。 然而，在后续发展中，一个致命问题显现了出来：手机上码字的体验真的是次到爆！ 原本我还想写一篇文章：《你浪费了一部手机》，看来是我想错了。 输入外设的硬伤，写作的冲动都被浇灭了。 优雅的 iPad 阶段虽然，在上一篇文章中我吐槽了Apple的作风，但这丝毫不影响我对Apple设备的喜爱，生态闭环的极致便是设备体检的极致。 哈哈，本文正式开始了。 iPad 本文，就是在这些工具的加持下完成的。 下面主要讲述这些工具。 Logitech K380在键盘方面，我下了不少功课，最终选择的是罗技的K380键盘。 因为，之前码字主要在笔记本上，所以 短间距，剪刀式的键盘，我用起来很顺手。 并且值得一提的是，该键盘很轻便，方便携带，可谓是出家旅行的必备之物。 Working Copy working-copy 以Apple的喜欢筑墙的性格，终端模拟器是不可能出现在苹果商店里的。 但在Testflight，我还找到了一个类似于Termux的软件—ish。 这款软件唯一的缺点就是没有优点，连安装个node都几经失败，我果断弃坑。 几经辗转，我幸运地遇到了Working Copy，IOS平台上最强大的Git客户端。 现在我写一篇博文，只需要将pull下来的博客，添加上写好的文章再push上去即可。 并且这一切，在Woking Copy中只需要点几下按钮，真的是将所有流程都简化到极致。 可惜的是，Working Copy的价格不便宜-128 元，它只提供 10 天的免费试用。 但如果你能通过Github学生认证的话，Working Copy还是可以继续使用的😄。 iA Writer如果你想问我，IOS端有没有值得推荐的写作软件？ 那很抱歉，这个问题 我无法回答。 在经过数天的寻找之后，我放弃了。 这些知名软件，真的是一个能打的都没有。 目前，我的折中方案是使用iA Writer，相当于简易版的Typora， 它有个神器功能—可直接打开Working Copy中的Github仓库进行编辑。 也就是说，我建博文，写博客这些流程全在这一个软件中就可以搞定。 明显的缺点是，对于图片 还要使用Working Copy进行导入，有那么一丝破环沉浸感。 完美的 CMS 阶段CMS？静态博客还想要什么自行车🚴‍♀️。 困就一个字，溜了溜了。 结束语这就是我的写作经历，希望对你有所帮助。 最后，新年快乐。 欢迎转载本站文章，请注明作者和出处 SimonAKing。","categories":[{"name":"博客","slug":"博客","permalink":"https://simonaking.com/blog/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://simonaking.com/blog/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"写作","slug":"写作","permalink":"https://simonaking.com/blog/tags/%E5%86%99%E4%BD%9C/"}]},{"title":"昨日青空","date":"2019-12-19T07:32:33.000Z","path":"/yesterday/","text":"起风了。 起风了 忽然 一瞬间长大 就像 被时间的手 擦模糊的画 我们啊 各自要去哪 问题好傻 谁又能 回答 想念从 不说话 来不及的再见 多喧哗 陪我看大雨落下 潮湿的心 滴滴答答 带着温柔 又想起你啊 我好想你 在起风的夜里 我好想你 在人群的缝隙 你听见吗 这一句喜欢你 追得上你背影吗 那些大喊过的名字 没完成的约定 全都藏在心底 开出寂寞的花 你好吗 为什么长大就要走散啊 你现在在哪里 隔我多远距离 是否勇敢飞行 有没有人爱你 每当我想起你 世界突然安静 你也一样吗 青春有你出席 不是为了让你缺席 好想沿着回忆 狂奔向你 昨日的青空 随少年 挥手消失在 人海之中 你在吗 你要幸福啊 我想你啊 。 #post-content > p:nth-child(1),#post-toc,#起风了{display:none}#post-content>p,#post-content>h3{text-align:center;border-bottom:none}.post-count-custom{display:none}#post-content>h3{margin-bottom:15px;margin-top:20px;border-bottom:dashed #efefef 5px;}.post {line-height:180% !important;font-size:105%;letter-spacing:4px;border-radius:20px;text-shadow: rgb(158, 158, 158) 0px 0px 1px;color:hsl(250,13%,30%);padding:0 20px;transition:all .3s ease-in;}.post:hover{transform:translateY(-1px);transition:all 0.2s;}@media screen and (max-width:760px){.post{letter-spacing: 1px;}}","categories":[{"name":"诗词","slug":"诗词","permalink":"https://simonaking.com/blog/categories/%E8%AF%97%E8%AF%8D/"}],"tags":[{"name":"诗词","slug":"诗词","permalink":"https://simonaking.com/blog/tags/%E8%AF%97%E8%AF%8D/"}]},{"title":"[开源福利]Scrcpy-GUI","date":"2019-08-24T13:59:37.000Z","path":"/scrcpy-gui/","text":"高效控制你的 Android 设备。 前言💡简介 是由流行的Android模拟器Genymotion背后的团队创建的，但它本身并不是Android模拟器，它显示和控制通过USB（或通过TCP/IP）连接的Android设备，它不需要任何root访问权限，它适用于GNU/Linux、Windows和MacOS。 Scrcpy的工作原理是在你的Android设备上运行服务器，桌面应用程序使用USB（或使用ADB隧道无线）进行通信。服务器流式传输设备屏幕的H.264视频。 客户端解码视频帧并显示它们。客户端捕获输入（键盘和鼠标）事件，将它们发送到服务器，服务器将它们注入设备。文档提供了更多详细信息。 如果你想在桌面上看到你的Android屏幕与应用程序或内容进行交互，记录你的手机屏幕或执行其他基本任务，那Scrcpy就是一个好的选择。 简而言之，Scrcpy是一种极好的方式，可以在你的计算机上轻松查看你的Android屏幕，并且可以实时与其进行交互。 引用自云网牛站 ✨亮点 亮度 （原生，仅显示设备屏幕） 表演 （30~60fps） 质量 （1920×1080 或以上） 低延迟 （70~100ms） 启动时间短 （显示第一张图像约 1 秒） 非侵入性 （设备上没有安装任何东西） 不需要 ROOT 有线无线都可连接 可以随便调整界面和码率 画面随意裁剪，自带录屏（手游直播利器） 支持多设备同时投屏 利用电脑的键盘和鼠标可以控制手机 把 APK 文件拖拽到电脑窗口即可安装应用到手机，把普通文件拖拽到窗口即可复制到手机 手机电脑共享剪贴板 自动检测 USB 连接的应用 可直接添加设备的局域网 IP，达到无线控制的效果 将自动保存连接过的 IP 地址，下次输入时，自动提醒 支持设备别名 支持中英两种语言 Tray menu 等等等… 部分引用自最美应用 正文🌞要求 Android 5.0以上 打开 USB 调试 在 开发人员选项 打开 USB 调试，USB 连接手机 安装好ADB ，并配置环境变量。 Windows Mac OS Linux 在任何路径下打开命令行，键入 ADB 有反馈。 安装好scrcpy，并配置环境变量 Windows Windows 可以使用包含所有依赖项（包含adb）的预构建存档： 下载下面scrcpy的压缩包，里面有ADB文件，然后把解压后的scrcpy文件夹添加到环境变量，再重启电脑，就可以了。 scrcpy-win32-v1.10.zip scrcpy-win64-v1.10.zip 你也可以手动构建。 Mac OS 可以使用 Homebrew 来安装： brew install scrcpy 如果你还没有安装ADB，可以使用下面的命令： brew cask install android-platform-tools 当然，你也可以手动构建。 Linux 你可能需要手动构建应用程序。别担心，这并不难。 此外，提供了 Snap) 包：scrcpy 对于 Arch Linux， 可以使用 AUR 包：scrcpy 对于 Gentoo，可以使用 Ebuild 包： scrcpy/ 🎉安装点击此处下载应用。 🎇使用连接方法必备条件 请确保 adb , scrcpy 可正常使用 请确保手机已打开 USB 调试, 并已认证电脑调试 有线连接 请确保手机已通过数据线连接到电脑 等待软件自动检测到设备 选中设备，点击打开选中的镜像 等待设备打开 无线连接 请确保手机与电脑处在同一局域网 第一次无线连接时: 请确保手机已通过数据线连接到电脑 请确保只有一个手机通过数据线连接到电脑 第一次需设置端口，以后连接手机，只需要添加手机的静态 IP 即可 输入手机的局域网IP地址（如果IP为DHCP分配，请更改为静态IP） 点击开启无线连接 等待无线连接成功 选中设备，点击打开选中的镜像 等待设备打开 🎯开发# install dependenciesnpm install# serve with hot reload at localhost:9080npm run dev# build electron application for productionnpm run build# lint all JS/Vue component files in `src/`npm run lint 📃协议GNU GPLv3 结束语 如果你有任何问题，欢迎提交 Issues 或 PR！ 欢迎转载本站文章，请注明作者和出处 SimonAKing。","categories":[{"name":"开源","slug":"开源","permalink":"https://simonaking.com/blog/categories/%E5%BC%80%E6%BA%90/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://simonaking.com/blog/tags/%E5%B7%A5%E5%85%B7/"},{"name":"开源","slug":"开源","permalink":"https://simonaking.com/blog/tags/%E5%BC%80%E6%BA%90/"}]},{"title":"Go 开发中的十大常见陷阱[译]","date":"2019-08-17T09:26:05.000Z","path":"/the-top-10-most-common-mistakes-ive-seen-in-go-projects/","text":"Golang 中要注意的陷阱和常见错误。 前言原文: The Top 10 Most Common Mistakes I’ve Seen in Go Projects 作者: Teiva Harsanyi 翻译许可: image-20210118234116954 img 我在 Go 开发中遇到的十大常见错误。顺序无关紧要。 正文未知的枚举值让我们看一个简单的例子: type Status uint32const ( StatusOpen Status = iota StatusClosed StatusUnknown) 在这里，我们使用 iota 创建了一个枚举，其结果如下： StatusOpen = 0StatusClosed = 1StatusUnknown = 2 现在，让我们假设这个Status类型是 JSON 请求的一部分，将被marshalled/unmarshalled。 我们设计了以下结构： type Request struct { ID int `json:\"Id\"` Timestamp int `json:\"Timestamp\"` Status Status `json:\"Status\"`} 然后，接收这样的请求： { \"Id\": 1234, \"Timestamp\": 1563362390, \"Status\": 0} 这里没有什么特别的，状态会被unmarshalled为StatusOpen。 然而，让我们以另一个未设置状态值的请求为例: { \"Id\": 1235, \"Timestamp\": 1563362390} 在这种情况下，请求结构的Status字段将初始化为它的零值(对于uint32类型:0)，因此结果将是StatusOpen而不是StatusUnknown。 那么最好的做法是将枚举的未知值设置为 0： type Status uint32const ( StatusUnknown Status = iota StatusOpen StatusClosed) 如果状态不是 JSON 请求的一部分，它将被初始化为StatusUnknown，这才符合我们的期望。 自动优化的基准测试基准测试需要考虑很多因素的,才能得到正确的测试结果。 一个常见的错误是测试代码无形间被编译器所优化。 下面是teivah/bitvector库中的一个例子: func clear(n uint64, i, j uint8) uint64 { return (math.MaxUint64&lt;&lt;j | ((1 &lt;&lt; i) - 1)) &amp; n} 此函数清除给定范围内的位。为了测试它，可能如下这样做: func BenchmarkWrong(b *testing.B) { for i := 0; i &lt; b.N; i++ { clear(1221892080809121, 10, 63) }} 在这个基准测试中，clear不调用任何其他函数，没有副作用。所以编译器将会把clear优化成内联函数。一旦内联，将会导致不准确的测试结果。 一个解决方案是将函数结果设置为全局变量，如下所示： var result uint64func BenchmarkCorrect(b *testing.B) { var r uint64 for i := 0; i &lt; b.N; i++ { r = clear(1221892080809121, 10, 63) } result = r} 如此一来，编译器将不知道clear是否会产生副作用。 因此，不会将clear优化成内联函数。 延伸阅读High Performance Go Workshop 被转移的指针在函数调用中，按值传递的变量将创建该变量的副本，而通过指针传递只会传递该变量的内存地址。 那么，指针传递会比按值传递更快吗？请看一下这个例子。 我在本地环境上模拟了0.3KB的数据，然后分别测试了按值传递和指针传递的速度。 结果显示：按值传递比指针传递快 4 倍以上，这很违背直觉。 测试结果与 Go 中如何管理内存有关。我虽然不能像威廉·肯尼迪那样出色地解释它，但让我试着总结一下。 译者注开始 作者没有说明 Go 内存的基本存储方式，译者补充一下。 下面是来自 Go 语言圣经的介绍： 一个 goroutine 会以一个很小的栈开始其生命周期，一般只需要 2KB。 一个 goroutine 的栈，和操作系统线程一样，会保存其活跃或挂起的函数调用的本地变量，但是和 OS 线程不太一样的是，一个 goroutine 的栈大小并不是固定的；栈的大小会根据需要动态地伸缩。 而 goroutine 的栈的最大值有 1GB，比传统的固定大小的线程栈要大得多，尽管一般情况下，大多 goroutine 都不需要这么大的栈。 译者自己的理解： 栈：每个 Goruntine 开始的时候都有独立的栈来存储数据。（Goruntine 分为主 Goruntine 和其他 Goruntine，差异就在于起始栈的大小） 堆: 而需要被多个 Goruntine 共享的数据，存储在堆上面。 译者注结束 众所周知，可以在堆或栈上分配变量。 栈储存当前Goroutine的正在使用的变量（译者注: 可理解为局部变量）。一旦函数返回，变量就会从栈中弹出。 堆储存共享变量（全局变量等）。 让我们看一个简单的例子，返回单一的值： func getFooValue() foo { var result foo // Do something return result} 当调用函数时，result变量会在当前 Goruntine 栈创建，当函数返回时，会传递给接收者一份值的拷贝。而result变量自身会从当前 Goruntine 栈出栈。 虽然它仍然存在于内存中，但它不能再被访问。并且还有可能被其他数据变量所擦除。 现在，在看一个返回指针的例子： func getFooPointer() *foo { var result foo // Do something return &amp;result} 当调用函数时，result变量会在当前 Goruntine 栈创建，当函数返回时，会传递给接收者一个指针（变量地址的副本）。如果result变量从当前 Goruntine 栈出栈，则接收者将无法再访问它。（译者注：此情况称为“内存逃逸”） 在这个场景中，Go 编译器将把result变量转义到一个可以共享变量的地方:堆。 不过，传递指针是另一种情况。例如： func main() { p := &amp;foo{} f(p)} 因为我们在同一个 Goroutine 中调用f，所以p变量不需要转义。它只是被推送到堆栈，子功能可以访问它。（译者注：不需要其他 Goruntine 共享的变量就存储在栈上即可） 比如，io.Reader中的Read方法签名，接收切片参数，将内容读取到切片中，返回读取的字节数。而不是返回读取后的切片。（译者注：如果返回切片，会将切片转义到堆中。） type Reader interface { Read(p []byte) (n int, err error)} 为什么栈如此之快？ 主要有两个原因： 堆栈不需要垃圾收集器。就像我们说的，变量一旦创建就会被入栈，一旦函数返回就会从出栈。不需要一个复杂的进程来回收未使用的变量。 储存变量不需要考虑同步。堆属于一个 Goroutine，因此与在堆上存储变量相比，存储变量不需要同步。 总之，当创建一个函数时，我们的默认行为应该是使用值而不是指针。只有在我们想要共享变量时才应使用指针。 如果我们遇到性能问题，可以使用go build -gcflags \"-m -m\"命令，来显示编译器将变量转义到堆的具体操作。 再次重申，对于大多数日常用例来说，值传递是最合适的。 延伸阅读 Language Mechanics On Stacks And Pointers Understanding Allocations: the Stack and the Heap - GopherCon SG 2019 出乎意料的 break如果f返回 true，下面的例子中会发生什么？ for { switch f() { case true: break case false: // Do something }} 我们将调用break语句。然而，将会break出switch语句，而不是for循环。 同样的问题： for { select { case &lt;-ch: // Do something case &lt;-ctx.Done(): break }} break与select语句有关，与for循环无关。 break出for/switch 或 for/select的一种解决方案是使用带标签的 break，如下所示： loop: for { select { case &lt;-ch: // Do something case &lt;-ctx.Done(): break loop } } 缺失上下文的错误Go 在错误处理方面仍然有待提高，以至于现在错误处理是 Go2 中最令人期待的需求。 当前的标准库(在 Go 1.13 之前)只提供error的构造函数，自然而然就会缺失其他信息。 让我们看一下pkg/errors库中错误处理的思想： An error should be handled only once. Logging an error is handling an error. So an error should either be logged or propagated. （译：错误应该只处理一次。记录log 错误就是在处理错误。所以，错误应该记录或者传播） 对于当前的标准库，很难做到这一点，因为我们希望向错误中添加一些上下文信息，使其具有层次结构。 例如: 所期望的REST调用导致数据库问题的示例： unable to server HTTP POST request for customer 1234 |_ unable to insert customer contract abcd |_ unable to commit transaction 如果我们使用pkg/errors，可以这样做： func postHandler(customer Customer) Status { err := insert(customer.Contract) if err != nil { log.WithError(err).Errorf(\"unable to server HTTP POST request for customer %s\", customer.ID) return Status{ok: false} } return Status{ok: true}}func insert(contract Contract) error { err := dbQuery(contract) if err != nil { return errors.Wrapf(err, \"unable to insert customer contract %s\", contract.ID) } return nil}func dbQuery(contract Contract) error { // Do something then fail return errors.New(\"unable to commit transaction\")} 如果不是由外部库返回的初始error可以使用error.New创建。中间层insert对此错误添加更多上下文信息。最终通过log错误来处理错误。每个级别要么返回错误，要么处理错误。 我们可能还想检查错误原因来判读是否应该重试。假设我们有一个来自外部库的db包来处理数据库访问。 该库可能会返回一个名为db.DBError的临时错误。要确定是否需要重试，我们必须检查错误原因： 使用pkg/errors中提供的errors.Cause可以判断错误原因。 func postHandler(customer Customer) Status { err := insert(customer.Contract) if err != nil { switch errors.Cause(err).(type) { default: log.WithError(err).Errorf(\"unable to server HTTP POST request for customer %s\", customer.ID) return Status{ok: false} case *db.DBError: return retry(customer) } } return Status{ok: true}}func insert(contract Contract) error { err := db.dbQuery(contract) if err != nil { return errors.Wrapf(err, \"unable to insert customer contract %s\", contract.ID) } return nil} 我见过的一个常见错误是部分使用pkg/errors。 例如，通过这种方式检查错误： switch err.(type) {default: log.WithError(err).Errorf(\"unable to server HTTP POST request for customer %s\", customer.ID) return Status{ok: false}case *db.DBError: return retry(customer)} 在此示例中，如果db.DBError被wrapped，它将永远不会执行retry。 延伸阅读Don’t just check errors, handle them gracefully 正在扩容的切片有时，我们知道切片的最终长度。假设我们想把Foo切片转换成Bar切片，这意味着这两个切片的长度是一样的。 我经常看到切片以下面的方式初始化： var bars []Barbars := make([]Bar, 0) 切片不是一个神奇的数据结构，如果没有更多可用空间，它会进行双倍扩容。在这种情况下，会自动创建一个切片(容量更大)，并复制其中的元素。 如果想容纳上千个元素，想象一下，我们需要扩容多少次。虽然插入的时间复杂度是O(1)，但它仍会对性能有所影响。 因此，如果我们知道最终长度，我们可以: 用预定义的长度初始化它 func convert(foos []Foo) []Bar { bars := make([]Bar, len(foos)) for i, foo := range foos { bars[i] = fooToBar(foo) } return bars} 或者使用长度 0 和预定义容量初始化它： func convert(foos []Foo) []Bar { bars := make([]Bar, 0, len(foos)) for _, foo := range foos { bars = append(bars, fooToBar(foo)) } return bars} 无规范的 Contextcontext.Context 经常被误用。 根据官方文档: A Context carries a deadline, a cancelation signal, and other values across API boundaries. 这种描述非常笼统，以至于让一些人对使用它感到困惑。 让我们试着详细描述一下。Context可以包含: A deadline（最后期限）。它意味着到期之后（250ms 之后或者一个指定的日期），我们必须停止正在进行的操作（I/O请求，等待的channel输入，等等）。 A cancelation signal（取消信号）。一旦我们收到信号，我们必须停止正在进行的活动。例如，假设我们收到两个请求：一个用来插入一些数据，另一个用来取消第一个请求。这可以通过在第一个调用中使用cancelable上下文来实现，一旦我们获得第二个请求，这个上下文就会被取消。 A list of key/value （键/值列表）均基于interface{}类型。 值得一提的是，Context 是可以组合的。例如，我们可以继承一个带有截止日期和键/值列表的Context。此外，多个goroutines可以共享相同的Context，取消一个Context可能会停止多个活动。 回到我们的主题，举一个我经历的例子。 一个基于urfave/cli （如果您不知道，这是一个很好的库，可以在 Go 中创建命令行应用程序）创建的 Go 应用。一旦开始，程序就会继承父级的Context。这意味着当应用程序停止时，将使用此Context发送取消信号。 我经历的是，这个Context是在调用gRPC时直接传递的，这不是我想做的。相反，我想当应用程序停止时或无操作 100 毫秒后，发送取消请求。 为此，可以简单地创建一个组合的Context。如果parent是父级的Context的名称（由 urfave/cli 创建），那么组合操作如下： ctx, cancel := context.WithTimeout(parent, 100 * time.Millisecond)response, err := grpcClient.Send(ctx, request) Context并不复杂，在我看来，可谓是 Go 的最佳特性之一。 延伸阅读 Understanding the context package in golang gRPC and Deadlines 被遗忘的-race 参数我经常看到的一个错误是在没有-race参数的情况下测试 Go 应用程序。 正如本报告所述，虽然 Go“旨在使并发编程更容易，更不容易出错”，但我们仍然遇到很多并发问题。 显然，Go 竞争检测器无法解决每一个并发问题。但是，它仍有很大价值，我们应该在测试应用程序时始终启用它。 延伸阅读Does the Go race detector catch all data race bugs? 更完美的封装另一个常见错误是将文件名传递给函数。 假设我们实现一个函数来计算文件中的空行数。最初的实现是这样的： func count(filename string) (int, error) { file, err := os.Open(filename) if err != nil { return 0, errors.Wrapf(err, \"unable to open %s\", filename) } defer file.Close() scanner := bufio.NewScanner(file) count := 0 for scanner.Scan() { if scanner.Text() == \"\" { count++ } } return count, nil} filename 作为给定的参数，然后我们打开该文件，再实现读空白行的逻辑，嗯，没有问题。 假设我们希望在此函数之上实现单元测试，并使用普通文件，空文件，具有不同编码类型的文件等进行测试。代码很容易变得非常难以维护。 此外，如果我们想对于HTTP Body实现相同的逻辑，将不得不为此创建另一个函数。 Go 设计了两个很棒的接口：io.Reader 和 io.Writer (译者注：常见 IO 命令行，文件，网络等) 所以可以传递一个抽象数据源的io.Reader，而不是传递文件名。 仔细想一想统计的只是文件吗？一个 HTTP 正文？字节缓冲区？ 答案并不重要，重要的是无论Reader读取的是什么类型的数据，我们都会使用相同的Read方法。 在我们的例子中，甚至可以缓冲输入以逐行读取它（使用bufio.Reader及其ReadLine方法）： func count(reader *bufio.Reader) (int, error) { count := 0 for { line, _, err := reader.ReadLine() if err != nil { switch err { default: return 0, errors.Wrapf(err, \"unable to read\") case io.EOF: return count, nil } } if len(line) == 0 { count++ } }} 打开文件的逻辑现在交给调用count方： file, err := os.Open(filename)if err != nil { return errors.Wrapf(err, \"unable to open %s\", filename)}defer file.Close()count, err := count(bufio.NewReader(file)) 无论数据源如何，都可以调用count。并且，还将促进单元测试，因为可以从字符串创建一个bufio.Reader，这大大提高了效率。 count, err := count(bufio.NewReader(strings.NewReader(\"input\"))) Goruntines 与循环变量我见过的最后一个常见错误是使用 Goroutines 和循环变量。 以下示例将会输出什么？ ints := []int{1, 2, 3}for _, i := range ints { go func() { fmt.Printf(\"%v\\n\", i) }()} 乱序输出 1 2 3 ？答错了。 在这个例子中，每个 Goroutine 共享相同的变量实例，因此最有可能输出3 3 3。 有两种解决方案可以解决这个问题。 第一种是将i变量的值传递给闭包（内部函数）： ints := []int{1, 2, 3}for _, i := range ints { go func(i int) { fmt.Printf(\"%v\\n\", i) }(i)} 第二种是在for循环范围内创建另一个变量： ints := []int{1, 2, 3}for _, i := range ints { i := i go func() { fmt.Printf(\"%v\\n\", i) }()} i := i可能看起来有点奇怪，但它完全有效。 因为处于循环中意味着处于另一个作用域内，所以i := i相当于创建了另一个名为i的变量实例。 当然，为了便于阅读，最好使用不同的变量名称。 延伸阅读Using goroutines on loop iterator variables 结束语你还想提到其他常见的错误吗？请随意分享，继续讨论；) 欢迎转载本站文章，请注明作者和出处 SimonAKing。","categories":[{"name":"后端","slug":"后端","permalink":"https://simonaking.com/blog/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"后端","slug":"后端","permalink":"https://simonaking.com/blog/tags/%E5%90%8E%E7%AB%AF/"},{"name":"Go","slug":"Go","permalink":"https://simonaking.com/blog/tags/Go/"},{"name":"译文","slug":"译文","permalink":"https://simonaking.com/blog/tags/%E8%AF%91%E6%96%87/"}]},{"title":"服务器初始化","date":"2019-05-05T07:37:04.000Z","path":"/server-initialization-step/","text":"记一下服务器的初始配置。 前言前些日子，入手了一台服务器，特此记录一下它的初始配置。 正文注：本人主机为 CentOS 7 x64 系统，以下内容均基于此环境。 安全设置请查考 肉鸡是怎样炼成的 字符集修改cd /etc/sysconfig/sudo vi i18nLANG=\"zh_CN.utf8\"source /etc/sysconfig/i18n 设置 DNSvi /etc/resolv.confnameserver 114.114.114.114nameserver 8.8.8.8 配置 Yum 源cd /etc/yum.repos.d/sudo mv CentOS-Base.repo CentOS-Base.repo_baksudo wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repoyum clean allyum makecache 设置时区yum install ntp -ytimedatectl set-timezone Asia/Shanghaitimedatectl set-ntp yes #同步timedatectl # 查看时区 软件安装常用软件yum install epel-release -yyum -y updateyum clean allyum makecacheyum -y install wget bind-utils net-tools lrzsz gcc gcc-c++ make cmake libxml2-devel openssl-devel curl curl-devel unzip sudo ntp libaio-devel wget ncurses-devel autoconf automake zlib-devel python-devel Vimyum -y install vimcurl -sLf https://spacevim.org/cn/install.sh | bash -s -- -hvi ~/.SpaceVim.d/ Gityum -y install gitgit config --global user.name SimonAKinggit config --global user.email hi@simonaking.comgit config --global http.sslverify falsegit config --global https.sslverify false# 远程仓库密钥生成ssh-keygen -t rsa -C \"hi@simonaking.com\" Zsh# 安装 zsh 包yum -y install zsh# 切换默认 shell 为 zshchsh -s /bin/zsh# 重启服务器reboot# 安装 on my zshsh -c \"$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"vi ~/.zshrcZSH_THEME=\"agnoster\"# autojumpyum install autojump -yyum install autojump-zsh# zsh-autosuggestionsgit clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions# zsh-syntax-highlightinggit clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting# 配置.zshrc 文件plugins=( git autojump zsh-autosuggestions zsh-syntax-highlighting z extract)source ~/.zshrc更新upgrade_oh_my_zsh卸载uninstall_oh_my_zsh 连按两次 Tab 会列出所有的补全列表并直接开始选择，补全项可以使用 ctrl+n/p/f/b 上下左右切换 命令选项补全。在 zsh 中只需要键入 tar - 就会列出所有的选项和帮助说明 命令参数补全。键入 kill 就会列出所有的进程名和对应的进程号 更智能的历史命令。在用或者方向上键查找历史命令时，zsh 支持限制查找。比如，输入 ls,然后再按方向上键，则只会查找用过的 ls 命令。而此时使用则会仍然按之前的方式查找，忽略 ls 多个终端会话共享历史记录 智能跳转，安装了 autojump 之后，zsh 会自动记录你访问过的目录，通过 j 目录名 可以直接进行目录跳转，而且目录名支持模糊匹配和自动补全，例如你访问过 hadoop-1.0.0 目录，输入 j hado 即可正确跳转。j –stat 可以看你的历史路径库。 目录浏览和跳转：输入 d，即可列出你在这个会话里访问的目录列表，输入列表前的序号，即可直接跳转。 在当前目录下输入 .. 或 … ，或直接输入当前目录名都可以跳转，你甚至不再需要输入 cd 命令了。在你知道路径的情况下，比如 /usr/local/bin 你可以输入 cd /u/l/b 然后按进行补全快速输入 通配符搜索：ls -l /*.sh，可以递归显示当前目录下的 shell 文件，文件少时可以代替 find。使用 / 来递归搜索 扩展环境变量，输入环境变量然后按 就可以转换成表达的值 在 .zshrc 中添加 setopt HIST_IGNORE_DUPS 可以消除重复记录，也可以利用 sort -t “;” -k 2 -u ~/.zsh_history | sort -o ~/.zsh_history 手动清除 至此，你现在的 zsh 应该具备如下几个特性： 各种补全：路径补全、命令补全，命令参数补全，插件内容补全等等。触发补全只需要按一下或两下tab键，补全项可以使用ctrl+n/p/f/b 上下左右切换。比如你想杀掉 java 的进程，只需要输入kill java + tab 键，如果只有一个 java 进程，zsh 会自动替换为进程的 pid，如果有多个则会出现选择项供你选择。ssh + 空格 + 两个 tab 键，zsh 会列出所有访问过的主机和用户名进行补全； 即使你没有安装autojump，只要输入d，就会列出你在这个回话中访问的目录，输入前面的序号，就可以直接跳转； 可以忽略 cd 命令, 输入..或者...和当前目录名都可以跳转； 当然，除了上面几点，zsh 还有很多丰富的插件可以使用，这就需要继续的探索了… Nodejscurl -o- https://raw.githubusercontent.com/creationix/nvm/v0.34.0/install.sh | bashsource ~/.bashrc# 安装 node 的最新稳定版nvm install stable# 查看安装版本nvm list# 配置npm config set registry https://registry.npm.taobao.orgnpm config set disturl https://npm.taobao.org/distnpm config set puppeteer_download_host https://npm.taobao.org/mirrors Nginxsudo rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpmsudo yum install -y nginx# 启动 Nginxsudo systemctl start nginx.service# 将 Nginx 加入到开机启动sudo systemctl enable nginx.service 命令别名vi ~/.zshrcalias shadow='/etc/init.d/shadowsocks'alias vi='vim'alias ls='ls --color=auto'alias ll=\"ls --color -al\"alias grep='grep --color=auto'# 查看当前时间alias now='date \"+%Y-%m-%d %H:%M:%S\"'alias reboot='sudo /sbin/reboot'alias poweroff='sudo /sbin/poweroff'alias halt='sudo /sbin/halt'alias shutdown='sudo /sbin/shutdown'# 自动创建父目录alias mkdir='mkdir -pv'# 解压任何文件extract() { if [ -f $1 ] ; then case $1 in *.tar.bz2) tar xjf $1 ;; *.tar.gz) tar xzf $1 ;; *.bz2) bunzip2 $1 ;; *.rar) unrar e $1 ;; *.gz) gunzip $1 ;; *.tar) tar xf $1 ;; *.tbz2) tar xjf $1 ;; *.tgz) tar xzf $1 ;; *.zip) unzip $1 ;; *.Z) uncompress $1 ;; *.7z) 7z x $1 ;; *) echo \"'$1' cannot be extracted via extract()\" ;; esac else echo \"'$1' is not a valid file\" fi}# 查看文件/目录大小alias size='f(){ du -sh $1* | sort -hr; }; f'# 开放端口alias portopen='f(){ /sbin/iptables -I INPUT -p tcp --dport $1 -j ACCEPT; }; f'# 关闭端口alias portclose='f(){ /sbin/iptables -I INPUT -p tcp --dport $1 -j DROP; }; f'# 解压alias untar='tar xvf 'alias -s html='vim' # 在命令行直接输入后缀为 html 的文件名，会在 Vim 中打开alias -s rb='vim' # 在命令行直接输入 ruby 文件，会在 Vim 中打开alias -s py='vim' # 在命令行直接输入 python 文件，会用 vim 中打开，以下类似alias -s js='vim'alias -s md='vim'alias -s mjs='vim'alias -s css='vim'alias -s c='vim'alias -s java='vim'alias -s txt='vim'alias -s gz='tar -xzvf' # 在命令行直接输入后缀为 gz 的文件名，会自动解压打开alias -s tgz='tar -xzvf'alias -s zip='unzip'alias -s bz2='tar -xjvf'alias -s json='vim'alias -s go='vim'alias cat=ccatalias man=tldreval \"$(thefuck --alias)\"# Load zsh-syntax-highlighting.source ~/.oh-my-zsh/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh## Load zsh-autosuggestions.source ~/.oh-my-zsh/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh## Enable autosuggestions automatically.ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE=\"fg=10\"# 保存source ~/.zshrc # 列出 bash 别名alias# 创建一个 bash shell 别名alias name=valuealias c='clear'# 删除别名unalias aliasname# 如果想要使别名永久生效， 请编辑vi ~/.zshrc 安装这两天，我完成了 CentosInit 项目，一个高度自定义的 Centos 初始化脚本。 欢迎 Star , PR ! 如果你想快速配置以上初始化措施，请执行以下命令： 通过 curl sh -c \"$(curl -fsSL https://simonaking.com/Centos-init/install.sh)\" 通过 wget sh -c \"$(wget https://simonaking.com/Centos-init/install.sh -O -)\" 基本介绍脚本功能一共分为四大类: 初始化配置（update） updateLanguageupdateTimeupdateLanguageupdateTimeupdateDNSupdateYumSourceupdateHostnameupdateUlimitupdateCoreConfig 安装常用软件（install） installCommonSoftinstallGitinstallViminstallZshinstallNodeinstallNpmPackagesinstallPythoninstallPipPackagesinstallDockerinstallNginxinstallCcatinstallShadowSocks 配置安装后的软件（config） configVimconfigZshconfigGitconfigNodeconfigDockerconfigNginxconfigShadowSocks 必要的安全配置（secure） 基础项 deleteOrLockUnnecessaryUsersAndGroupssetPrivilegescloseCtrlAltDelcloseIpv6closeSELinux 高阶项 updateSSHPortuseKeyLoginuseIptablepreventCrackingPassword 用户相关项 getUserInfoaddUserjoinWheelGroupbanRootLogin 单独功能安装如果你想安装某一种功能( Update | Install | Config | Secure ) 请参考以下案列: # 在安装命令前设置 ONLY_UPDATE=Y 即可只安装 update 服务ONLY_UPDATE=Y sh -c \"$(curl -fsSL https://simonaking.com/Centos-init/install.sh)\"# Install and ConfigONLY_INSTALL=Y ONLY_CONFIG=Y sh -c \"$(curl -fsSL https://simonaking.com/Centos-init/install.sh)\" 交互模式你也设置设置交互模式，在交互模式下，可高达自定义化你想使用的功能。 每执行完一项功能，都会询问你下一步。 使用功能的方法如下: # 在安装命令前设置 INTERACTIVE=YINTERACTIVE=Y sh -c \"$(curl -fsSL https://simonaking.com/Centos-init/install.sh)\" 结束语欢迎转载本站文章，请注明作者和出处 simonaking.com。","categories":[{"name":"开源","slug":"开源","permalink":"https://simonaking.com/blog/categories/%E5%BC%80%E6%BA%90/"}],"tags":[{"name":"开源","slug":"开源","permalink":"https://simonaking.com/blog/tags/%E5%BC%80%E6%BA%90/"},{"name":"Linux","slug":"Linux","permalink":"https://simonaking.com/blog/tags/Linux/"}]},{"title":"肉鸡是怎样炼成的","date":"2019-04-30T11:11:44.000Z","path":"/server-security-manual/","text":"你的服务器正在被攻击！ 前言安全是一个服务器最基本的必备条件，在创建了服务器之后，你首先要做的事情就是将服务器加固。 由于服务器就相当于一台拥有独立 IP 的、直接暴露于互联网之上的电脑，这在为你带来便利的同时也直接让你的服务器与危险画上了等号，密码穷举、DDOS 攻击、各种各样你想到的、想不到的攻击方法都在等着你。 说不定你的服务器正在被攻击！ 正文注：本人主机为 CentOS 7 x64 系统，以下内容均基于此环境。 查看攻击情况 查看登录失败的日志 sudo lastb 统计尝试暴力破解机器密码的 IP sudo grep \"Failed password for invalid\" /var/log/secure | awk '{print $13}' | sort | uniq -c | sort -nr | more 统计有哪些用户名尝试登录 sudo grep \"Failed password for invalid\" /var/log/secure | awk '{print $11}' | sort | uniq -c | sort -nr | more 嗯哼，结果可怕吗? 安全措施禁止 root永远不要以 root 登录服务器。 你可以新建一个用户来管理，而非直接使用 root 用户，防止密码被破解。 增加用户 useradd -m username# -m 可以为用户创建相应的帐号和用户目录/home/username 设置新用户密码 passwd username 将新用户加入到 Wheel 组 usermod -G wheel username 限制su命令 vi /etc/pam.d/su# 去除下面命令的注释#auth required pam_wheel.so use_uid# 只允许管理员组的用户执行 sh 命令echo \"SU_WHEEL_ONLY yes\"&gt;&gt;/etc/login.defs 除去验证密码 vi /etc/sudoers # 在 root 下面增加 以下内容：username ALL=(ALL) NOPASSWD: ALL 禁止 root 登陆 vi /etc/ssh/sshd_configPermitRootLogin no #禁止 root 登录PermitEmptyPasswords no #禁止空密码登录AllowUsers username #设置刚才创建的用户可以登录 重启服务器 reboot 禁用不必要的账号passwd -l dbuspasswd -l nobodypasswd -l ftppasswd -l mailpasswd -l shutdownpasswd -l haltpasswd -l operatorpasswd -l syncpasswd -l admpasswd -l lp 禁止非授权用户获得权限sudo chattr +i /etc/passwdsudo chattr +i /etc/shadowsudo chattr +i /etc/groupsudo chattr +i /etc/gshadowsudo chmod -R 700 /etc/rc.d/init.d/* 这样操作之后也无法创建账号和修改密码，后面可以使用chattr -i命令恢复之后再进行操作。 修改端口ssh 登陆默认的端口是22，那些扫描穷举密码的，也一定从22开始。 编辑配置文件 sudo vi /etc/ssh/sshd_config 将其中的Port 22改为其他端口 port的取值范围是 0 – 65535(即 2 的 16 次方) 0 到 1024 是众所周知的端口（知名端口，常用于系统服务等，例如 http 服务的端口号是 80） 配置防火墙 #CentOS 6 中防火墙开启对应端口iptables -I INPUT -p tcp --dport 设置的端口号 -j ACCEPT#CentOS 7 中防火墙开启对应端口sudo firewall-cmd --zone=public --add-port=设置的端口号/tcp --permanent 重启 sshd service sshd restart 限制端口转发 编辑配置文件 sudo vi /etc/ssh/sshd_config 修改以下内容 ChrootDirectory /home/%uX11Forwarding noAllowTcpForwarding noUseDNS no 重启服务器 service sshd restart ssh 密钥登录 如果一定要使用密码登录，请查考正文最后 fail2ban 与 DenyHosts 的介绍。 不要相信自己的密码，在暴力枚举面前，只是时间文件。 统计学告诉我们，请配置 RSA 有两种不同的密钥分发方式，但结果都是一样的。 在客户端生成公钥与私钥，上传公钥到服务器 在服务器生成公钥和私钥，复制私钥到客户端 我使用第二种方式进行演示： 服务器生成密钥 sudo ssh-keygen -b 2048 -t rsa 这样一来，在根目录就生成了一个.ssh的隐藏目录，内含两个密钥文件。 xxx 为私钥，需复制到客户端，xxx.pub 为公钥。 服务器配置公钥 cd ~/.sshsudo cat xxx.pub &gt;&gt; authorized_keys # 默认允许的 key 存储的文件sudo chmod 600 authorized_keyssudo chmod 700 ~/.ssh 配置 ssh 文件 sudo vi /etc/ssh/sshd_config#编辑以下内容RSAAuthentication yes #RSA 认证PubkeyAuthentication yes #开启公钥验证AuthorizedKeysFile .ssh/authorized_keys #验证文件路径 复制私钥到本地，并且设置相应 ssh 工具的连接配置。 重启服务器 service sshd restart 禁止密码登录 使用密钥登录成功之后，再设置此项。 sudo vi /etc/ssh/sshd_config#编辑以下内容PasswordAuthentication no #禁止密码认证PermitEmptyPasswords no #禁止空密码UsePAM no#禁用 PAM iptablesiptables 是Linux上最强大的防火墙软件。 安装 yum install iptables -yyum install iptables-services -y #CentOS7 需安装此 iptables 的 service 软件包## Debian/Ubuntu 执行：apt-get install iptables -yapt-get install iptables-persistent -y #持久化 iptables 规则服务# CentOS 7 上默认安装了 firewalld 建议关闭并禁用： systemctl stop firewalldsystemctl mask firewalld 清除已有 iptables 规则 iptables -Fiptables -Xiptables -Z 开发指定端口 # 允许本地回环接口(即运行本机访问本机)iptables -A INPUT -i lo -j ACCEPT# 允许已建立的或相关连的通行iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT#允许所有本机向外的访问iptables -A OUTPUT -j ACCEPT# 允许访问 22222(SSH)端口，以下几条相同，分别是 22222,80,443 端口的访问iptables -A INPUT -p tcp --dport 22222 -j ACCEPTiptables -A INPUT -p tcp --dport 80 -j ACCEPTiptables -A INPUT -p tcp --dport 443 -j ACCEPT#允许 FTP 服务的 21 和 20 端口iptables -A INPUT -p tcp --dport 21 -j ACCEPTiptables -A INPUT -p tcp --dport 20 -j ACCEPT#如果有其他端口的话，规则也类似，稍微修改上述语句就行#允许 pingiptables -A INPUT -p icmp -m icmp --icmp-type 8 -j ACCEPT#禁止其他未允许的规则访问（注意：如果 22 端口未加入允许规则，SSH 链接会直接断开。）iptables -A INPUT -j REJECTiptables -A FORWARD -j REJECT#屏蔽单个 IP 的命令是iptables -I INPUT -s 123.45.6.7 -j DROP#封整个段即从 123.0.0.1 到 123.255.255.254 的命令iptables -I INPUT -s 123.0.0.0/8 -j DROP#封 IP 段即从 123.45.0.1 到 123.45.255.254 的命令iptables -I INPUT -s 124.45.0.0/16 -j DROP#封 IP 段即从 123.45.6.1 到 123.45.6.254 的命令是iptables -I INPUT -s 123.45.6.0/24 -j DROP#屏蔽某 IP 访问指定端口，以 22 端口为例命令是iptables -I INPUT -s 123.45.6.7 -p tcp --dport 22 -j DROP#允许某 IP 访问指定端口，以 22 端口为例命令是iptables -I INPUT -p tcp --dport 22 -j DROPiptables -I INPUT -s 123.45.6.7 -p tcp --dport 22 -j ACCEPT#ACCEPT:允许通过.LOG:记录日志信息,然后传给下一条规则继续匹配.REJECT:拒绝通过,必要时会给出提示DROP:直接丢弃,不给出任何回应.PREROUTING:在进行路由选择前处理数据包INPUT:处理入站的数据包OUTPUT:处理出站的数据包FORWARD:处理转发的数据包POSTROUTING:在进行路由选择后处理数据包 保存防火墙规则 service iptables save 设置防火墙开机启动 chkconfig --level 345 iptables on# CentOS7 可执行：systemctl enable iptables fail2ban如已经设置 禁止密码登录，可忽悠。 通过使用 iptables 防火墙，将尝试爆破 ssh 密码的 IP 封停，默认 10 分钟。 安装 yum install -y fail2ban 配置 cp -pf /etc/fail2ban/jail.conf /etc/fail2ban/jail.localvim /etc/fail2ban/jail.local[sshd]enabled = trueport = 22222logpath = %(sshd_log)sbackend = %(sshd_backend)sfilter = sshdaction = iptables[name=SSH, port=22222, protocol=tcp] sendmail-whois[name=SSH, dest=root, sender=fail2ban@example.com]logpath = /var/log/securemaxretry = 3 DenyHosts如已经设置 禁止密码登录，可忽悠。 分析sshd的日志文件，当发现重复的攻击时就会记录IP到/etc/hosts.deny文件，从而达到自动屏蔽IP的功能。 和 fail2ban 一样，都是防止暴力破解密码，两者任选其一即可。 安装 yum install denyhosts 配置 vi /etc/denyhosts.conf# 配置相关说明SECURE_LOG = /var/log/secure #ssh 日志文件,系统不同,文件不相同HOSTS_DENY = /etc/hosts.deny #控制用户登陆的文件PURGE_DENY = #过多久后清除已经禁止的，空表示永远不解禁BLOCK_SERVICE = sshd #禁止的服务名，如还要添加其他服务，只需添加逗号跟上相应的服务即可DENY_THRESHOLD_INVALID = 5 #允许无效用户失败的次数DENY_THRESHOLD_VALID = 10 #允许普通用户登陆失败的次数DENY_THRESHOLD_ROOT = 1 #允许 root 登陆失败的次数DENY_THRESHOLD_RESTRICTED = 1WORK_DIR = /var/lib/denyhosts #运行目录SUSPICIOUS_LOGIN_REPORT_ALLOWED_HOSTS=YESHOSTNAME_LOOKUP=YES #是否进行域名反解析LOCK_FILE = /var/run/denyhosts.pid #程序的进程 IDADMIN_EMAIL = root@localhost #管理员邮件地址,它会给管理员发邮件SMTP_HOST = localhostSMTP_PORT = 25SMTP_FROM = DenyHosts &lt;nobody@localhost&gt;SMTP_SUBJECT = DenyHosts ReportAGE_RESET_VALID=5d #用户的登录失败计数会在多久以后重置为 0，(h 表示小时，d 表示天，m 表示月，w 表示周，y 表示年)AGE_RESET_ROOT=25dAGE_RESET_RESTRICTED=25dAGE_RESET_INVALID=10dRESET_ON_SUCCESS = yes #如果一个 ip 登陆成功后，失败的登陆计数是否重置为 0DAEMON_LOG = /var/log/denyhosts #自己的日志文件DAEMON_SLEEP = 30s #当以后台方式运行时，每读一次日志文件的时间间隔。 启动 /etc/init.d/daemon-control start #启动 denyhostschkconfig daemon-control on #将 denghosts 设成开机启动 启动命令（yum 安装，已默认配好） service denyhosts startservice denyhosts stopservice denyhosts status 安装这两天，我完成了 CentosInit 项目，一个高度自定义的 Centos 初始化脚本。 欢迎 Star PR ! 如果你想快速配置以上安全措施，请执行以下命令： 通过 curl ONLY_SECURE=Y sh -c \"$(curl -fsSL https://simonaking.com/Centos-init/install.sh)\" 通过 wget ONLY_SECURE=Y sh -c \"$(wget https://simonaking.com/Centos-init/install.sh -O -)\" 基本介绍脚本功能一共分为四大类: 初始化配置（update） updateLanguageupdateTimeupdateLanguageupdateTimeupdateDNSupdateYumSourceupdateHostnameupdateUlimitupdateCoreConfig 安装常用软件（install） installCommonSoftinstallGitinstallViminstallZshinstallNodeinstallNpmPackagesinstallPythoninstallPipPackagesinstallDockerinstallNginxinstallCcatinstallShadowSocks 配置安装后的软件（config） configVimconfigZshconfigGitconfigNodeconfigDockerconfigNginxconfigShadowSocks 必要的安全配置（secure） 基础项 deleteOrLockUnnecessaryUsersAndGroupssetPrivilegescloseCtrlAltDelcloseIpv6closeSELinux 高阶项 updateSSHPortuseKeyLoginuseIptablepreventCrackingPassword 用户相关项 getUserInfoaddUserjoinWheelGroupbanRootLogin 单独功能安装如果你想安装某一种功能( Update | Install | Config | Secure ) 请参考以下案列: # 在安装命令前设置 ONLY_UPDATE=Y 即可只安装 update 服务ONLY_UPDATE=Y sh -c \"$(curl -fsSL https://simonaking.com/Centos-init/install.sh)\"# Install and ConfigONLY_INSTALL=Y ONLY_CONFIG=Y sh -c \"$(curl -fsSL https://simonaking.com/Centos-init/install.sh)\" 交互模式你也设置设置交互模式，在交互模式下，可高达自定义化你想使用的功能。 每执行完一项功能，都会询问你下一步。 使用功能的方法如下: # 在安装命令前设置 INTERACTIVE=YINTERACTIVE=Y sh -c \"$(curl -fsSL https://simonaking.com/Centos-init/install.sh)\" 结束语希望上面的这些措施可以帮助你加强服务器的安全。 欢迎转载本站文章，请注明作者和出处 SimonAKing。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://simonaking.com/blog/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://simonaking.com/blog/tags/Linux/"},{"name":"信安","slug":"信安","permalink":"https://simonaking.com/blog/tags/%E4%BF%A1%E5%AE%89/"}]},{"title":"Vim 修炼秘籍之语法篇","date":"2018-03-18T08:44:05.000Z","path":"/grammar-of-vim-cultivation-cheats/","text":"欲练此功，必先自宫。 前言 少年，我看你骨骼精奇，是万中无一的武学奇才，维护世界和平就靠你了，我这有本秘籍《Vim 修炼秘籍》，见与你有缘，就十块卖给你了！ —— 本秘籍建议零售价：10 元 如果你是一名 Vimer，那么恭喜你，你的 Vim 技能马上要升级了 😈！ 如果你之前不了解过 Vim ，那么也没关系，本文就当成学英语语法了！ 好，废话不多说，秘籍送上。 ps: 建议先熟悉一遍 Vim 修炼秘籍之命令篇，本秘籍食用更佳 正文核心秘诀Vim 功法之究极总结： （操作次数）+ 操作行为 + 操作范围 下面，我会将此秘诀 亲自传授于你。 秘诀解析先列一些常用的 Vim 招式给你瞧瞧，看你是否是传说的练武奇才： c2w —— 删除当前光标后紧邻的两个单词，并转换为普通模式dip —— 删除当前光标所处的一段内容y3f{char} —— 从当前字符，一直复制到第三个 {char} 字符&gt;G —— 当前行到结尾，整体缩进一个 &lt;Tab&gt;v`{mark} —— 从当前字符，选择到 {mark} 标记位置cit —— 删除当前光标所处标签中的内容 如果把招式看成语言，解析其语法，不难发现一个共同点： 每个招式必须包括 谓语（操作行为） 与 宾语（操作对象） 好，既然有了线索，我这就带你各个击破！ 谓语（操作行为）众所周知，谓语是 动词词性的。 在 Vim 功法中，常用的动词如下： c 删除内容，进入普通模式 d 删除 y 复制 v 选择 &gt;,&lt; 缩进 = 智能缩进 gu,gU,g~ 改变内容大小写 宾语（操作对象）宾语代表的是操作对象，而在 Vim 中，所需操作的对象即是 操作的范围。 而常用的操作范围命令如下： w 从当前位置，到下一个单词首字母，单词由特殊字符（”.等）作为间隔 内容： .main {xxx} , 光标处在字符 m 招式：caw 结果：. {xxx} W 从当前位置，到下一个单词首字母，单词由空格作为间隔 内容： .main {xxx} , 光标处在字符 m 招式：caW 结果： {xxx} e 从当前位置，到本单词尾字母 ge 从当前位置到上一个单词尾字母 b 通常代替括号中的内容 上一个单词首字母 p 段落 paragraph s 句子 sentence t 标签中的内容 B 通常代替花括号中的内容 符号 {) \"'&lt; 代表的就是 该符号中的内容 G,gg 结尾，开头 j,k,h,l 上下左右 /{word}&lt;Enter&gt; 从当前字符 到下一个 word 之间的内容 f{char} 从当前字符到下一个 char 字符之间的内容 `mark 从当前字符到 mark 标记 之间的内容 双写动词，操作范围默认是当前行 dd 删除当前行 cc 删除当前行 并转换为普通模式 &gt;&gt; 缩进当前行 v 动词例外，使用 V 选中当前行。 gU 命令是一种特殊情况，可用 gUU 来使它作用于当前行。 数词（操作次数）假如现在有个任务，让你删除两个单词，你会怎么做？ d2w 删除两个单词 2dw 执行两次删除单词的命令 虽然这两式结果相同，但意义却有所差别， 数词灵活多变，可放在 谓语（操作行为）前，又可放在 宾语（操作对象）前， 放在 谓语前，代表操作次数， 放在 宾语前，代表操作范围的扩张次数 介词（修饰范围）常用的介词就两个：i(inside) ， a(around) 举例说明：光标处在字符 c (main)(div class=\"vim-test\" I am Vimer! div)(main) 分别操作： dab 结果：(main)(main) dib 结果：(main)()(main) 顾名思义，i 就是内部的内容，a 就是连同包裹的内容 一起干掉。 招式实战我已经教授了你 Vim 秘籍的基本功 ：（操作次数）+ 操作行为 + 操作范围 现在，利用你所学，来实战巩固吧。 将下面标签中的内容修改了: I am Vimer! (光标所处 字符 c ) (div class=\"vim-test\")you are Bimer!(div) 修改下面字符串为 https://simonaking.com ！（光标所处 第一个 w 字符） https://www.simonaking.com 将文件 所有内容格式化，写出 你认为的命令 将下面字符串改为 I am Vimer （光标所处 I 字符） I am VIMER 将下面字符串的每个字符替换为 ‘!’ I love github and juejin 等待你的评论答案。 结束语好的功夫是练出来的，请你以后务必勤加练习。 好了，Vim 语法先告一段落，希望本文能给你带来帮助。 如果你想了解 Vim 其他方面 如：Ex 命令，寄存器等，请关注我的后续文章。 欢迎转载本站文章，请注明作者和出处 simonaking.com。","categories":[{"name":"工具","slug":"工具","permalink":"https://simonaking.com/blog/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://simonaking.com/blog/tags/%E5%B7%A5%E5%85%B7/"},{"name":"Vim","slug":"Vim","permalink":"https://simonaking.com/blog/tags/Vim/"}]},{"title":"囚思","date":"2018-03-08T01:51:13.000Z","path":"/prison-thoughts/","text":"年少时写的一首小词。 囚思 一往情深深几许？ 二心紧绑，三年孤依不言弃。 炼金情，苦思忆， 岁月多别离， 人渐消沉天渐熄， 思绪囚心屿。 于 2016.05.28 19:28 所作 （正和她处在异地恋） #post-content > p:nth-child(1),#post-toc,#囚思{display:none}#post-content>p,#post-content>h3{text-align:center;border-bottom:none}.post-count-custom{display:none}#post-content>h3{margin-bottom:15px;margin-top:20px;border-bottom:dashed #efefef 5px;}.post {line-height:180% !important;font-size:105%;letter-spacing:4px;border-radius:20px;text-shadow: rgb(158, 158, 158) 0px 0px 1px;color:hsl(250,13%,30%);padding:0 20px;transition:all .3s ease-in;}.post:hover{transform:translateY(-1px);transition:all 0.2s;}@media screen and (max-width:760px){.post{letter-spacing: 1px;}}","categories":[{"name":"诗词","slug":"诗词","permalink":"https://simonaking.com/blog/categories/%E8%AF%97%E8%AF%8D/"}],"tags":[{"name":"诗词","slug":"诗词","permalink":"https://simonaking.com/blog/tags/%E8%AF%97%E8%AF%8D/"}]},{"title":"Git 修炼手册","date":"2018-01-27T01:58:00.000Z","path":"/git-training-manual/","text":"Git 命令大汇总。 入门配置用户信息 git config –global user.name Simon 设置自己的用户名 git config –global user.email jinmaup@gmail.com 设置自己的邮箱 查看配置git config –list 查看自己 git 的配置信息 设置编辑器git config –global core.editor vim 当你用 git 编辑文件时，编辑文件的文本编辑器会默认调用 vim 文本着色git config –global color.ui true 可为大部分 git 的代码布上颜色 基础命令建立版本库 git init 当前路径文件 初始化为 Git 仓库（可以发现 当前路径增加了.git 文件夹） git init 文件夹名 新建一个文件夹，并将其初始化为 Git 代码库 文件添加到暂存区 git add . 把当前目录所有未追踪文件，已修改的文件，添加到暂存区 (不包括被删除的文件) git add 文件（夹）名 把特定文件（夹）添加到暂存区 git add -A 提交所有的文件操作到暂存区 git add -u 提交已修改的文件,被删除的文件（不包括新文件） git add -p 交互式的缓存提交，会提供多个选项来自定义提交内容、方式 文件添加到本地仓库 git commit -m”commit message” 把暂存区的所有文件添加到本地仓库，-m”提交信息” （越详细越好） git commit 文件（夹）名 -m”commit message” 把特定文件（夹）添加到本地仓库，-m”提交信息” （越详细越好） git commit -am”commit message” 针对已经被追踪的文件，可以直接添加到本地仓库，不用先 add 在 commit. git commit –amend -m”commit message” 利用本次 commit 重写上一次 commit git commit –amend –no-edit 利用本次 commit 重写上一次 commit 不会重写上次 commit 的提交信息 仓库状态获取git status 可以立即获取本地仓库状态 以及 git 的步骤提示，建议多使用此命令 版本回退 git reset –hard HEAD 将工作区，暂存区，本地仓库恢复到上一个版本（–hard） git reset –soft HEAD^^^ 将本地仓库恢复到上三个版本,不会修改暂存区，工作区（–soft） git reset –mixd HEAD~5 将暂存区，本地仓库恢复到上五个版本，不会修改工作区（–mixd，默认） git reset –hard commitID 将工作区，暂存区，本地仓库恢复到上指定版本 其中 commitID 就是每一次 commit 的版本号，可以使用 git reflog 获取 撤销暂存 git reset HEAD file.txt 撤销 file.txt 的 add 操作，使其变成不跟踪状态 git reset HEAD^ file.txt 将上一次提交版本的 file.txt 重新置入缓存区 撤销工作区 git checkout – file.txt （只针对未追踪文件）用历史中的 file.txt 替换现有工作区的 file.txt 如果文件增加到暂存区后 又进行了修改，那么执行命令后 将回到暂存区文件状态 git checkout HEAD – file.txt 用最后一次提交版本中的 file.txt 替换现有工作区的 file.txt git checkout commitID – file.txt 用特定版本的 file.txt 替换现有工作区的 file.txt 撤销提交git revert commitID 撤销指定版本的 commit，并将此操作生成一个全新的 commit 并提交 文件操作增 touch touch 文件名 ： 新建文件 mkdir mkdir 文件夹名： 新建文件夹 vim vim 文件名 ： 新建文件，并用 vim 模式打开该文件进行编写 git init git init 文件夹名：新建一个文件夹，并将其初始化为 Git 代码库 printf printf ‘content’ &gt; 文件名 ：新建一个文件，并把 content 注入其内容 echo echo ‘content’ &gt; 文件名 ：新建一个文件，并把 content 注入其内容 删 rm rm 文件名 : 删除文件 clean git clean -f 文件名 ：删除未跟踪文件 改 vim vim 文件名 ： 打开文件，并用 vim 模式进行修改 mv mv 选定文件名 新的文件名：把选定文件名 修改为 新的文件名 printf printf ‘content’ &gt; 文件名 ： 将 content 替换 文件原有内容 echo echo ‘content’ &gt; 文件名 ： 将 content 替换 文件原有内容 查 pwd 得到当前路径 cd cd 路径 ：进到某一文件路径 cd .. : 回退文件路径 cd : 回到默认的路径 cat cat 文件名：查看该文件的内容 ls 查看该目录下的文件列表（不包括隐藏文件） ls -a 查看该目录下的文件列表（包括隐藏文件） show git show : ：展示任意分支某一文件的内容 分支操作查看分支 git branch 列出本地分支 git branch -r 列出远端分支 git branch -a 列出所有分支 git branch -v 查看各个分支最后一个提交对象的信息 git branch –merge 查看已经合并到当前分支的分支 git branch –no-merge 查看为合并到当前分支的分支 git remote show origin 可以查看 remote 地址，远程分支 新建分支 git branch name 新建一个名为 name 的分支 git checkout -b name 新建一个名为 name 的分支，并自动切换为该分支 git branch [branch] [commit] 新建一个分支，指向指定 commit git branch –track [branch] [remote-branch] 新建一个分支，与指定的远程分支建立追踪关系 删除分支 git branch -d name 删除一个名为 name 的分支 git branch -D name 强制删除一个名为 name 的分支 git push : 删除远程分支 git push origin –delete 删除远程分支 切换分支 git checkout name 切换一个名为 name 的分支 git checkout - 切换上一个分支 重命名分支 git branch -m name 将当前所在分支命名为 name 标签新建标签 git tag [tag] 新建一个 tag 在当前 commit git tag [tag] [commit] 新建一个 tag 在指定 commit git tag v0.9 commitID 对某次提交新建标签 查看标签 git tag 列出所有 tag 删除标签 git tag -d [tag] 删除本地 tag git push origin :refs/tags/ 可以删除一个远程标签 推送标签 git push origin –tags 一次性推送全部尚未推送到远程的本地标签 git push origin 可以推送一个本地标签 远程仓库 git remote 显示所关联的远程仓库 git remote -v 显示更详细信息 git remote add origin git@server-name:path/repo-name.git 关联一个远程库 git remote rm name 删除一个远程库 git remote rename 将远程连接从 重命名为 合并 git rebase master 将 master 分之上超前的提交，变基到当前分支 git rebase –interactive 交互模式，修改 commit git rebase –continue 处理完冲突继续合并 git rebase –skip 跳过合并 git rebase –abort 取消合并 查看汇总查看信息 git whatchanged –since=’2 weeks ago’ 查看两个星期内的改动 git log –follow [file] 显示某个文件的版本历史 git log –author=”John” 它会显示所有作者叫 John 的提交 get log –after=”yesterday” 查看昨天的历史信息 git log -3 展示最近 3 次历史信息 git log –graph 可以看到分支合并图 修改历史git rebase -i commitID 将 pick 替换成 r , 然后回车，vi 退出可以使用 :x 修改 git 的历史记录的提交信息 查看文件 git diff HEAD – readme.txt 可以查看工作区和版本库里面最新版本的区别 git diff –staged 显示暂存区（已经 add）的文件和版本库文件的比较 git ls-files 查看在暂存区的文件 删除暂存 git rm –cached 文件名 把文件从暂缓区 返回至 工作区 其他忽略文件echo node_modules/ &gt;&gt; .gitignore 添加忽略文件 打包 git archive master –format=zip –output=master.zip 将 Master 分支打包 git bundle create 将历史记录包括分支内容打包到一个文件中 git clone repo.bundle -b 从某个 Bundle 中导入 工作区 git stash 将工作区现场（已跟踪文件）储藏起来 git stash list 查看保存的工作现场 git stash apply 恢复工作现场 git stash drop 删除 stash 内容 git stash pop 恢复的同时直接删除 stash 内容 git stash apply stash@{0} 恢复指定的工作现场 查找内容 git grep “Hello” 从当前目录的所有文件中查找文本内容 git grep “Hello” v2.5 在某一版本中搜索文本 帮助git help -a .post-toc-level-4{ display:none }","categories":[{"name":"工具","slug":"工具","permalink":"https://simonaking.com/blog/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://simonaking.com/blog/tags/%E5%B7%A5%E5%85%B7/"},{"name":"Git","slug":"Git","permalink":"https://simonaking.com/blog/tags/Git/"}]},{"title":"网站必备之简繁切换","date":"2018-01-26T10:17:31.000Z","path":"/simplified-chinese-and-traditional-chinese-switching/","text":"一个优秀网站能够更好地照顾不同的用户。 前言&nbsp;&nbsp;&nbsp;&nbsp;一个优秀的网站为了能够更好地照顾不同的用户，一般都会提供简繁两种版本字体切换，提高用户的体验。例如 : Hexo 官网 。之所以 Hexo 能得到了不少内地忠实粉丝的追捧，是因为 Hexo 的官网不仅提供了适合台湾同胞（作者是来自台湾的）阅读的繁体中文版，还为我们大陆用户提供了简体中文版，照顾了我们平时的写作习惯。同样，我们也可以提供繁体版来照顾那些使用繁体字的台湾、港澳同胞。 &nbsp;&nbsp;&nbsp;&nbsp;下面，我将由浅入深地讲解：如何使用 35 行代码，让网站支持简繁切换功能。 正文&nbsp;&nbsp;&nbsp;&nbsp;一般而言，网站上实现两种字体的切换，需要先准备两种字体库，而基本逻辑通常是：识别当前字体，然后根据当前字体去相对的字体库中去寻找另一字体，从而进行字体的替换，处理起来不但麻烦而且耗时。 &nbsp;&nbsp;&nbsp;&nbsp;有没有一种方法，可以绕开这些弯路呢？ &nbsp;&nbsp;&nbsp;&nbsp;答案是有的，我们可以利用数组索引的特性来完成，具体逻辑如下： function Exchange(text){ const Simplified = \"万与丑\"; const Traditional = \"萬與醜\";//翻译成简体：万与丑 let result,findIndex; for(let i=0;i&lt;text.length;++i){ findIndex = Simplified.indexOf(text[i]); result += findIndex === -1 ? text[i] : Traditional[j]; } return result;} &nbsp;&nbsp;&nbsp;&nbsp;系统来讲，切换字体的大体过程 可分为 3 大步骤： 得到页面的字体内容 切换为简繁字体 保存状态与切换状态 得到页面的内容&nbsp;&nbsp;&nbsp;&nbsp;毫无疑问，我们所要切换的内容便是页面中的汉字，众所周知，判断汉字可以使用正则表达式/[\\u4e00-\\u9fa5]/g，而我们在第一步 所面临的最大问题便是：如何得到页面中所有的字体内容。分析网页中结构可得，显示给用户的内容一般都在body标签中或者其各个子标签中，我们该如何获取这些包裹着内容的标签呢？又该如何判断 元素与所需字体呢？ &nbsp;&nbsp;&nbsp;&nbsp;下面，我将带你学习两个原生 JS 的 API 。 childNodes childNodes 属性返回节点的子节点集合，包括 元素节点、文本内容、注释、属性等。 document.body.childNodes;/* 获得 body 元素的子节点集合*/ &nbsp;&nbsp;&nbsp;&nbsp;可以想象到，我们先将 document.body.childNodes 作为入口 循环遍历，然后再如法炮制的递归各个元素，便可得到 body 标签中 所有的 DOM 节点以及节点中所需的文本内容。 nodeType nodeType 属性返回以数字值返回指定节点的节点类型。 如果节点是元素节点，则 nodeType 属性将返回 1。 如果节点是文本节点，则 nodeType 属性将返回 3。 document.body.nodeType === 1;/* true */ &nbsp;&nbsp;&nbsp;&nbsp;有了 nodeType 作为当前元素的判断，我们便可轻松的分离出 DOM 节点与 文本节点，从而来进行不同需求的操作。 &nbsp;&nbsp;&nbsp;&nbsp;大体逻辑如下： function translateBody(obj) { let objs = (obj ? obj : document.body).childNodes; for (let i = 0; i &lt; objs.length; i++) { if (objs[i].nodeType === 3) { objs[i].textContent = Exchange(objs[i].textContent); } else if (objs[i].nodeType === 1 ) { translateBody(objs[i]); } }} &nbsp;&nbsp;&nbsp;&nbsp;这样，我们便得到了所需要的文本内容。下面，我们将进行 Exchange 函数的编写。 切换简繁字体&nbsp;&nbsp;&nbsp;&nbsp;毫无疑问，切换字体最大的困难，就是索引相同的字体库了。所幸，我从网上寻得了前辈总结的资源，欢迎大家使用。 const Simplified = \"万与丑专业丛东丝丢两严丧个丬丰临为丽举么义乌乐乔习乡书买乱争于亏云亘亚产亩亲亵亸亿仅从仑仓仪们价众优伙会伛伞伟传伤伥伦伧伪伫体余佣佥侠侣侥侦侧侨侩侪侬俣俦俨俩俪俭债倾偬偻偾偿傥傧储傩儿兑兖党兰关兴兹养兽冁内冈册写军农冢冯冲决况冻净凄凉凌减凑凛几凤凫凭凯击凼凿刍划刘则刚创删别刬刭刽刿剀剂剐剑剥剧劝办务劢动励劲劳势勋勐勚匀匦匮区医华协单卖卢卤卧卫却卺厂厅历厉压厌厍厕厢厣厦厨厩厮县参叆叇双发变叙叠叶号叹叽吁后吓吕吗吣吨听启吴呒呓呕呖呗员呙呛呜咏咔咙咛咝咤咴咸哌响哑哒哓哔哕哗哙哜哝哟唛唝唠唡唢唣唤唿啧啬啭啮啰啴啸喷喽喾嗫呵嗳嘘嘤嘱噜噼嚣嚯团园囱围囵国图圆圣圹场坂坏块坚坛坜坝坞坟坠垄垅垆垒垦垧垩垫垭垯垱垲垴埘埙埚埝埯堑堕塆墙壮声壳壶壸处备复够头夸夹夺奁奂奋奖奥妆妇妈妩妪妫姗姜娄娅娆娇娈娱娲娴婳婴婵婶媪嫒嫔嫱嬷孙学孪宁宝实宠审宪宫宽宾寝对寻导寿将尔尘尧尴尸尽层屃屉届属屡屦屿岁岂岖岗岘岙岚岛岭岳岽岿峃峄峡峣峤峥峦崂崃崄崭嵘嵚嵛嵝嵴巅巩巯币帅师帏帐帘帜带帧帮帱帻帼幂幞干并广庄庆庐庑库应庙庞废庼廪开异弃张弥弪弯弹强归当录彟彦彻径徕御忆忏忧忾怀态怂怃怄怅怆怜总怼怿恋恳恶恸恹恺恻恼恽悦悫悬悭悯惊惧惨惩惫惬惭惮惯愍愠愤愦愿慑慭憷懑懒懔戆戋戏戗战戬户扎扑扦执扩扪扫扬扰抚抛抟抠抡抢护报担拟拢拣拥拦拧拨择挂挚挛挜挝挞挟挠挡挢挣挤挥挦捞损捡换捣据捻掳掴掷掸掺掼揸揽揿搀搁搂搅携摄摅摆摇摈摊撄撑撵撷撸撺擞攒敌敛数斋斓斗斩断无旧时旷旸昙昼昽显晋晒晓晔晕晖暂暧札术朴机杀杂权条来杨杩杰极构枞枢枣枥枧枨枪枫枭柜柠柽栀栅标栈栉栊栋栌栎栏树栖样栾桊桠桡桢档桤桥桦桧桨桩梦梼梾检棂椁椟椠椤椭楼榄榇榈榉槚槛槟槠横樯樱橥橱橹橼檐檩欢欤欧歼殁殇残殒殓殚殡殴毁毂毕毙毡毵氇气氢氩氲汇汉污汤汹沓沟没沣沤沥沦沧沨沩沪沵泞泪泶泷泸泺泻泼泽泾洁洒洼浃浅浆浇浈浉浊测浍济浏浐浑浒浓浔浕涂涌涛涝涞涟涠涡涢涣涤润涧涨涩淀渊渌渍渎渐渑渔渖渗温游湾湿溃溅溆溇滗滚滞滟滠满滢滤滥滦滨滩滪漤潆潇潋潍潜潴澜濑濒灏灭灯灵灾灿炀炉炖炜炝点炼炽烁烂烃烛烟烦烧烨烩烫烬热焕焖焘煅煳熘爱爷牍牦牵牺犊犟状犷犸犹狈狍狝狞独狭狮狯狰狱狲猃猎猕猡猪猫猬献獭玑玙玚玛玮环现玱玺珉珏珐珑珰珲琎琏琐琼瑶瑷璇璎瓒瓮瓯电画畅畲畴疖疗疟疠疡疬疮疯疱疴痈痉痒痖痨痪痫痴瘅瘆瘗瘘瘪瘫瘾瘿癞癣癫癯皑皱皲盏盐监盖盗盘眍眦眬着睁睐睑瞒瞩矫矶矾矿砀码砖砗砚砜砺砻砾础硁硅硕硖硗硙硚确硷碍碛碜碱碹磙礼祎祢祯祷祸禀禄禅离秃秆种积称秽秾稆税稣稳穑穷窃窍窑窜窝窥窦窭竖竞笃笋笔笕笺笼笾筑筚筛筜筝筹签简箓箦箧箨箩箪箫篑篓篮篱簖籁籴类籼粜粝粤粪粮糁糇紧絷纟纠纡红纣纤纥约级纨纩纪纫纬纭纮纯纰纱纲纳纴纵纶纷纸纹纺纻纼纽纾线绀绁绂练组绅细织终绉绊绋绌绍绎经绐绑绒结绔绕绖绗绘给绚绛络绝绞统绠绡绢绣绤绥绦继绨绩绪绫绬续绮绯绰绱绲绳维绵绶绷绸绹绺绻综绽绾绿缀缁缂缃缄缅缆缇缈缉缊缋缌缍缎缏缐缑缒缓缔缕编缗缘缙缚缛缜缝缞缟缠缡缢缣缤缥缦缧缨缩缪缫缬缭缮缯缰缱缲缳缴缵罂网罗罚罢罴羁羟羡翘翙翚耢耧耸耻聂聋职聍联聩聪肃肠肤肷肾肿胀胁胆胜胧胨胪胫胶脉脍脏脐脑脓脔脚脱脶脸腊腌腘腭腻腼腽腾膑臜舆舣舰舱舻艰艳艹艺节芈芗芜芦苁苇苈苋苌苍苎苏苘苹茎茏茑茔茕茧荆荐荙荚荛荜荞荟荠荡荣荤荥荦荧荨荩荪荫荬荭荮药莅莜莱莲莳莴莶获莸莹莺莼萚萝萤营萦萧萨葱蒇蒉蒋蒌蓝蓟蓠蓣蓥蓦蔷蔹蔺蔼蕲蕴薮藁藓虏虑虚虫虬虮虽虾虿蚀蚁蚂蚕蚝蚬蛊蛎蛏蛮蛰蛱蛲蛳蛴蜕蜗蜡蝇蝈蝉蝎蝼蝾螀螨蟏衅衔补衬衮袄袅袆袜袭袯装裆裈裢裣裤裥褛褴襁襕见观觃规觅视觇览觉觊觋觌觍觎觏觐觑觞触觯詟誉誊讠计订讣认讥讦讧讨让讪讫训议讯记讱讲讳讴讵讶讷许讹论讻讼讽设访诀证诂诃评诅识诇诈诉诊诋诌词诎诏诐译诒诓诔试诖诗诘诙诚诛诜话诞诟诠诡询诣诤该详诧诨诩诪诫诬语诮误诰诱诲诳说诵诶请诸诹诺读诼诽课诿谀谁谂调谄谅谆谇谈谊谋谌谍谎谏谐谑谒谓谔谕谖谗谘谙谚谛谜谝谞谟谠谡谢谣谤谥谦谧谨谩谪谫谬谭谮谯谰谱谲谳谴谵谶谷豮贝贞负贠贡财责贤败账货质贩贪贫贬购贮贯贰贱贲贳贴贵贶贷贸费贺贻贼贽贾贿赀赁赂赃资赅赆赇赈赉赊赋赌赍赎赏赐赑赒赓赔赕赖赗赘赙赚赛赜赝赞赟赠赡赢赣赪赵赶趋趱趸跃跄跖跞践跶跷跸跹跻踊踌踪踬踯蹑蹒蹰蹿躏躜躯车轧轨轩轪轫转轭轮软轰轱轲轳轴轵轶轷轸轹轺轻轼载轾轿辀辁辂较辄辅辆辇辈辉辊辋辌辍辎辏辐辑辒输辔辕辖辗辘辙辚辞辩辫边辽达迁过迈运还这进远违连迟迩迳迹适选逊递逦逻遗遥邓邝邬邮邹邺邻郁郄郏郐郑郓郦郧郸酝酦酱酽酾酿释里鉅鉴銮錾钆钇针钉钊钋钌钍钎钏钐钑钒钓钔钕钖钗钘钙钚钛钝钞钟钠钡钢钣钤钥钦钧钨钩钪钫钬钭钮钯钰钱钲钳钴钵钶钷钸钹钺钻钼钽钾钿铀铁铂铃铄铅铆铈铉铊铋铍铎铏铐铑铒铕铗铘铙铚铛铜铝铞铟铠铡铢铣铤铥铦铧铨铪铫铬铭铮铯铰铱铲铳铴铵银铷铸铹铺铻铼铽链铿销锁锂锃锄锅锆锇锈锉锊锋锌锍锎锏锐锑锒锓锔锕锖锗错锚锜锞锟锠锡锢锣锤锥锦锨锩锫锬锭键锯锰锱锲锳锴锵锶锷锸锹锺锻锼锽锾锿镀镁镂镃镆镇镈镉镊镌镍镎镏镐镑镒镕镖镗镙镚镛镜镝镞镟镠镡镢镣镤镥镦镧镨镩镪镫镬镭镮镯镰镱镲镳镴镶长门闩闪闫闬闭问闯闰闱闲闳间闵闶闷闸闹闺闻闼闽闾闿阀阁阂阃阄阅阆阇阈阉阊阋阌阍阎阏阐阑阒阓阔阕阖阗阘阙阚阛队阳阴阵阶际陆陇陈陉陕陧陨险随隐隶隽难雏雠雳雾霁霉霭靓静靥鞑鞒鞯鞴韦韧韨韩韪韫韬韵页顶顷顸项顺须顼顽顾顿颀颁颂颃预颅领颇颈颉颊颋颌颍颎颏颐频颒颓颔颕颖颗题颙颚颛颜额颞颟颠颡颢颣颤颥颦颧风飏飐飑飒飓飔飕飖飗飘飙飚飞飨餍饤饥饦饧饨饩饪饫饬饭饮饯饰饱饲饳饴饵饶饷饸饹饺饻饼饽饾饿馀馁馂馃馄馅馆馇馈馉馊馋馌馍馎馏馐馑馒馓馔馕马驭驮驯驰驱驲驳驴驵驶驷驸驹驺驻驼驽驾驿骀骁骂骃骄骅骆骇骈骉骊骋验骍骎骏骐骑骒骓骔骕骖骗骘骙骚骛骜骝骞骟骠骡骢骣骤骥骦骧髅髋髌鬓魇魉鱼鱽鱾鱿鲀鲁鲂鲄鲅鲆鲇鲈鲉鲊鲋鲌鲍鲎鲏鲐鲑鲒鲓鲔鲕鲖鲗鲘鲙鲚鲛鲜鲝鲞鲟鲠鲡鲢鲣鲤鲥鲦鲧鲨鲩鲪鲫鲬鲭鲮鲯鲰鲱鲲鲳鲴鲵鲶鲷鲸鲹鲺鲻鲼鲽鲾鲿鳀鳁鳂鳃鳄鳅鳆鳇鳈鳉鳊鳋鳌鳍鳎鳏鳐鳑鳒鳓鳔鳕鳖鳗鳘鳙鳛鳜鳝鳞鳟鳠鳡鳢鳣鸟鸠鸡鸢鸣鸤鸥鸦鸧鸨鸩鸪鸫鸬鸭鸮鸯鸰鸱鸲鸳鸴鸵鸶鸷鸸鸹鸺鸻鸼鸽鸾鸿鹀鹁鹂鹃鹄鹅鹆鹇鹈鹉鹊鹋鹌鹍鹎鹏鹐鹑鹒鹓鹔鹕鹖鹗鹘鹚鹛鹜鹝鹞鹟鹠鹡鹢鹣鹤鹥鹦鹧鹨鹩鹪鹫鹬鹭鹯鹰鹱鹲鹳鹴鹾麦麸黄黉黡黩黪黾\";const Traditional = \"萬與醜專業叢東絲丟兩嚴喪個爿豐臨為麗舉麼義烏樂喬習鄉書買亂爭於虧雲亙亞產畝親褻嚲億僅從侖倉儀們價眾優夥會傴傘偉傳傷倀倫傖偽佇體餘傭僉俠侶僥偵側僑儈儕儂俁儔儼倆儷儉債傾傯僂僨償儻儐儲儺兒兌兗黨蘭關興茲養獸囅內岡冊寫軍農塚馮衝決況凍淨淒涼淩減湊凜幾鳳鳧憑凱擊氹鑿芻劃劉則剛創刪別剗剄劊劌剴劑剮劍剝劇勸辦務勱動勵勁勞勢勳猛勩勻匭匱區醫華協單賣盧鹵臥衛卻巹廠廳曆厲壓厭厙廁廂厴廈廚廄廝縣參靉靆雙發變敘疊葉號歎嘰籲後嚇呂嗎唚噸聽啟吳嘸囈嘔嚦唄員咼嗆嗚詠哢嚨嚀噝吒噅鹹呱響啞噠嘵嗶噦嘩噲嚌噥喲嘜嗊嘮啢嗩唕喚呼嘖嗇囀齧囉嘽嘯噴嘍嚳囁嗬噯噓嚶囑嚕劈囂謔團園囪圍圇國圖圓聖壙場阪壞塊堅壇壢壩塢墳墜壟壟壚壘墾坰堊墊埡墶壋塏堖塒塤堝墊垵塹墮壪牆壯聲殼壺壼處備複夠頭誇夾奪奩奐奮獎奧妝婦媽嫵嫗媯姍薑婁婭嬈嬌孌娛媧嫻嫿嬰嬋嬸媼嬡嬪嬙嬤孫學孿寧寶實寵審憲宮寬賓寢對尋導壽將爾塵堯尷屍盡層屭屜屆屬屢屨嶼歲豈嶇崗峴嶴嵐島嶺嶽崠巋嶨嶧峽嶢嶠崢巒嶗崍嶮嶄嶸嶔崳嶁脊巔鞏巰幣帥師幃帳簾幟帶幀幫幬幘幗冪襆幹並廣莊慶廬廡庫應廟龐廢廎廩開異棄張彌弳彎彈強歸當錄彠彥徹徑徠禦憶懺憂愾懷態慫憮慪悵愴憐總懟懌戀懇惡慟懨愷惻惱惲悅愨懸慳憫驚懼慘懲憊愜慚憚慣湣慍憤憒願懾憖怵懣懶懍戇戔戲戧戰戩戶紮撲扡執擴捫掃揚擾撫拋摶摳掄搶護報擔擬攏揀擁攔擰撥擇掛摯攣掗撾撻挾撓擋撟掙擠揮撏撈損撿換搗據撚擄摑擲撣摻摜摣攬撳攙擱摟攪攜攝攄擺搖擯攤攖撐攆擷擼攛擻攢敵斂數齋斕鬥斬斷無舊時曠暘曇晝曨顯晉曬曉曄暈暉暫曖劄術樸機殺雜權條來楊榪傑極構樅樞棗櫪梘棖槍楓梟櫃檸檉梔柵標棧櫛櫳棟櫨櫟欄樹棲樣欒棬椏橈楨檔榿橋樺檜槳樁夢檮棶檢欞槨櫝槧欏橢樓欖櫬櫚櫸檟檻檳櫧橫檣櫻櫫櫥櫓櫞簷檁歡歟歐殲歿殤殘殞殮殫殯毆毀轂畢斃氈毿氌氣氫氬氳彙漢汙湯洶遝溝沒灃漚瀝淪滄渢溈滬濔濘淚澩瀧瀘濼瀉潑澤涇潔灑窪浹淺漿澆湞溮濁測澮濟瀏滻渾滸濃潯濜塗湧濤澇淶漣潿渦溳渙滌潤澗漲澀澱淵淥漬瀆漸澠漁瀋滲溫遊灣濕潰濺漵漊潷滾滯灩灄滿瀅濾濫灤濱灘澦濫瀠瀟瀲濰潛瀦瀾瀨瀕灝滅燈靈災燦煬爐燉煒熗點煉熾爍爛烴燭煙煩燒燁燴燙燼熱煥燜燾煆糊溜愛爺牘犛牽犧犢強狀獷獁猶狽麅獮獰獨狹獅獪猙獄猻獫獵獼玀豬貓蝟獻獺璣璵瑒瑪瑋環現瑲璽瑉玨琺瓏璫琿璡璉瑣瓊瑤璦璿瓔瓚甕甌電畫暢佘疇癤療瘧癘瘍鬁瘡瘋皰屙癰痙癢瘂癆瘓癇癡癉瘮瘞瘺癟癱癮癭癩癬癲臒皚皺皸盞鹽監蓋盜盤瞘眥矓著睜睞瞼瞞矚矯磯礬礦碭碼磚硨硯碸礪礱礫礎硜矽碩硤磽磑礄確鹼礙磧磣堿镟滾禮禕禰禎禱禍稟祿禪離禿稈種積稱穢穠穭稅穌穩穡窮竊竅窯竄窩窺竇窶豎競篤筍筆筧箋籠籩築篳篩簹箏籌簽簡籙簀篋籜籮簞簫簣簍籃籬籪籟糴類秈糶糲粵糞糧糝餱緊縶糸糾紆紅紂纖紇約級紈纊紀紉緯紜紘純紕紗綱納紝縱綸紛紙紋紡紵紖紐紓線紺絏紱練組紳細織終縐絆紼絀紹繹經紿綁絨結絝繞絰絎繪給絢絳絡絕絞統綆綃絹繡綌綏絛繼綈績緒綾緓續綺緋綽緔緄繩維綿綬繃綢綯綹綣綜綻綰綠綴緇緙緗緘緬纜緹緲緝縕繢緦綞緞緶線緱縋緩締縷編緡緣縉縛縟縝縫縗縞纏縭縊縑繽縹縵縲纓縮繆繅纈繚繕繒韁繾繰繯繳纘罌網羅罰罷羆羈羥羨翹翽翬耮耬聳恥聶聾職聹聯聵聰肅腸膚膁腎腫脹脅膽勝朧腖臚脛膠脈膾髒臍腦膿臠腳脫腡臉臘醃膕齶膩靦膃騰臏臢輿艤艦艙艫艱豔艸藝節羋薌蕪蘆蓯葦藶莧萇蒼苧蘇檾蘋莖蘢蔦塋煢繭荊薦薘莢蕘蓽蕎薈薺蕩榮葷滎犖熒蕁藎蓀蔭蕒葒葤藥蒞蓧萊蓮蒔萵薟獲蕕瑩鶯蓴蘀蘿螢營縈蕭薩蔥蕆蕢蔣蔞藍薊蘺蕷鎣驀薔蘞藺藹蘄蘊藪槁蘚虜慮虛蟲虯蟣雖蝦蠆蝕蟻螞蠶蠔蜆蠱蠣蟶蠻蟄蛺蟯螄蠐蛻蝸蠟蠅蟈蟬蠍螻蠑螿蟎蠨釁銜補襯袞襖嫋褘襪襲襏裝襠褌褳襝褲襇褸襤繈襴見觀覎規覓視覘覽覺覬覡覿覥覦覯覲覷觴觸觶讋譽謄訁計訂訃認譏訐訌討讓訕訖訓議訊記訒講諱謳詎訝訥許訛論訩訟諷設訪訣證詁訶評詛識詗詐訴診詆謅詞詘詔詖譯詒誆誄試詿詩詰詼誠誅詵話誕詬詮詭詢詣諍該詳詫諢詡譸誡誣語誚誤誥誘誨誑說誦誒請諸諏諾讀諑誹課諉諛誰諗調諂諒諄誶談誼謀諶諜謊諫諧謔謁謂諤諭諼讒諮諳諺諦謎諞諝謨讜謖謝謠謗諡謙謐謹謾謫譾謬譚譖譙讕譜譎讞譴譫讖穀豶貝貞負貟貢財責賢敗賬貨質販貪貧貶購貯貫貳賤賁貰貼貴貺貸貿費賀貽賊贄賈賄貲賃賂贓資賅贐賕賑賚賒賦賭齎贖賞賜贔賙賡賠賧賴賵贅賻賺賽賾贗讚贇贈贍贏贛赬趙趕趨趲躉躍蹌蹠躒踐躂蹺蹕躚躋踴躊蹤躓躑躡蹣躕躥躪躦軀車軋軌軒軑軔轉軛輪軟轟軲軻轤軸軹軼軤軫轢軺輕軾載輊轎輈輇輅較輒輔輛輦輩輝輥輞輬輟輜輳輻輯轀輸轡轅轄輾轆轍轔辭辯辮邊遼達遷過邁運還這進遠違連遲邇逕跡適選遜遞邐邏遺遙鄧鄺鄔郵鄒鄴鄰鬱郤郟鄶鄭鄆酈鄖鄲醞醱醬釅釃釀釋裏钜鑒鑾鏨釓釔針釘釗釙釕釷釺釧釤鈒釩釣鍆釹鍚釵鈃鈣鈈鈦鈍鈔鍾鈉鋇鋼鈑鈐鑰欽鈞鎢鉤鈧鈁鈥鈄鈕鈀鈺錢鉦鉗鈷缽鈳鉕鈽鈸鉞鑽鉬鉭鉀鈿鈾鐵鉑鈴鑠鉛鉚鈰鉉鉈鉍鈹鐸鉶銬銠鉺銪鋏鋣鐃銍鐺銅鋁銱銦鎧鍘銖銑鋌銩銛鏵銓鉿銚鉻銘錚銫鉸銥鏟銃鐋銨銀銣鑄鐒鋪鋙錸鋱鏈鏗銷鎖鋰鋥鋤鍋鋯鋨鏽銼鋝鋒鋅鋶鐦鐧銳銻鋃鋟鋦錒錆鍺錯錨錡錁錕錩錫錮鑼錘錐錦鍁錈錇錟錠鍵鋸錳錙鍥鍈鍇鏘鍶鍔鍤鍬鍾鍛鎪鍠鍰鎄鍍鎂鏤鎡鏌鎮鎛鎘鑷鐫鎳鎿鎦鎬鎊鎰鎔鏢鏜鏍鏰鏞鏡鏑鏃鏇鏐鐔钁鐐鏷鑥鐓鑭鐠鑹鏹鐙鑊鐳鐶鐲鐮鐿鑔鑣鑞鑲長門閂閃閆閈閉問闖閏闈閑閎間閔閌悶閘鬧閨聞闥閩閭闓閥閣閡閫鬮閱閬闍閾閹閶鬩閿閽閻閼闡闌闃闠闊闋闔闐闒闕闞闤隊陽陰陣階際陸隴陳陘陝隉隕險隨隱隸雋難雛讎靂霧霽黴靄靚靜靨韃鞽韉韝韋韌韍韓韙韞韜韻頁頂頃頇項順須頊頑顧頓頎頒頌頏預顱領頗頸頡頰頲頜潁熲頦頤頻頮頹頷頴穎顆題顒顎顓顏額顳顢顛顙顥纇顫顬顰顴風颺颭颮颯颶颸颼颻飀飄飆飆飛饗饜飣饑飥餳飩餼飪飫飭飯飲餞飾飽飼飿飴餌饒餉餄餎餃餏餅餑餖餓餘餒餕餜餛餡館餷饋餶餿饞饁饃餺餾饈饉饅饊饌饢馬馭馱馴馳驅馹駁驢駔駛駟駙駒騶駐駝駑駕驛駘驍罵駰驕驊駱駭駢驫驪騁驗騂駸駿騏騎騍騅騌驌驂騙騭騤騷騖驁騮騫騸驃騾驄驏驟驥驦驤髏髖髕鬢魘魎魚魛魢魷魨魯魴魺鮁鮃鯰鱸鮋鮓鮒鮊鮑鱟鮍鮐鮭鮚鮳鮪鮞鮦鰂鮜鱠鱭鮫鮮鮺鯗鱘鯁鱺鰱鰹鯉鰣鰷鯀鯊鯇鮶鯽鯒鯖鯪鯕鯫鯡鯤鯧鯝鯢鯰鯛鯨鯵鯴鯔鱝鰈鰏鱨鯷鰮鰃鰓鱷鰍鰒鰉鰁鱂鯿鰠鼇鰭鰨鰥鰩鰟鰜鰳鰾鱈鱉鰻鰵鱅鰼鱖鱔鱗鱒鱯鱤鱧鱣鳥鳩雞鳶鳴鳲鷗鴉鶬鴇鴆鴣鶇鸕鴨鴞鴦鴒鴟鴝鴛鴬鴕鷥鷙鴯鴰鵂鴴鵃鴿鸞鴻鵐鵓鸝鵑鵠鵝鵒鷳鵜鵡鵲鶓鵪鶤鵯鵬鵮鶉鶊鵷鷫鶘鶡鶚鶻鶿鶥鶩鷊鷂鶲鶹鶺鷁鶼鶴鷖鸚鷓鷚鷯鷦鷲鷸鷺鸇鷹鸌鸏鸛鸘鹺麥麩黃黌黶黷黲黽\"; &nbsp;&nbsp;&nbsp;&nbsp;根据上面的总结，Exchange 函数编写如下： function Exchange(text) { let result = '', j, s = \"万与丑专业丛东丝丢两严丧个丬丰临为丽举么义乌乐乔习乡书买乱争于亏云亘亚产亩亲亵亸亿仅从仑仓仪们价众优伙会伛伞伟传伤伥伦伧伪伫体余佣佥侠侣侥侦侧侨侩侪侬俣俦俨俩俪俭债倾偬偻偾偿傥傧储傩儿兑兖党兰关兴兹养兽冁内冈册写军农冢冯冲决况冻净凄凉凌减凑凛几凤凫凭凯击凼凿刍划刘则刚创删别刬刭刽刿剀剂剐剑剥剧劝办务劢动励劲劳势勋勐勚匀匦匮区医华协单卖卢卤卧卫却卺厂厅历厉压厌厍厕厢厣厦厨厩厮县参叆叇双发变叙叠叶号叹叽吁后吓吕吗吣吨听启吴呒呓呕呖呗员呙呛呜咏咔咙咛咝咤咴咸哌响哑哒哓哔哕哗哙哜哝哟唛唝唠唡唢唣唤唿啧啬啭啮啰啴啸喷喽喾嗫呵嗳嘘嘤嘱噜噼嚣嚯团园囱围囵国图圆圣圹场坂坏块坚坛坜坝坞坟坠垄垅垆垒垦垧垩垫垭垯垱垲垴埘埙埚埝埯堑堕塆墙壮声壳壶壸处备复够头夸夹夺奁奂奋奖奥妆妇妈妩妪妫姗姜娄娅娆娇娈娱娲娴婳婴婵婶媪嫒嫔嫱嬷孙学孪宁宝实宠审宪宫宽宾寝对寻导寿将尔尘尧尴尸尽层屃屉届属屡屦屿岁岂岖岗岘岙岚岛岭岳岽岿峃峄峡峣峤峥峦崂崃崄崭嵘嵚嵛嵝嵴巅巩巯币帅师帏帐帘帜带帧帮帱帻帼幂幞干并广庄庆庐庑库应庙庞废庼廪开异弃张弥弪弯弹强归当录彟彦彻径徕御忆忏忧忾怀态怂怃怄怅怆怜总怼怿恋恳恶恸恹恺恻恼恽悦悫悬悭悯惊惧惨惩惫惬惭惮惯愍愠愤愦愿慑慭憷懑懒懔戆戋戏戗战戬户扎扑扦执扩扪扫扬扰抚抛抟抠抡抢护报担拟拢拣拥拦拧拨择挂挚挛挜挝挞挟挠挡挢挣挤挥挦捞损捡换捣据捻掳掴掷掸掺掼揸揽揿搀搁搂搅携摄摅摆摇摈摊撄撑撵撷撸撺擞攒敌敛数斋斓斗斩断无旧时旷旸昙昼昽显晋晒晓晔晕晖暂暧札术朴机杀杂权条来杨杩杰极构枞枢枣枥枧枨枪枫枭柜柠柽栀栅标栈栉栊栋栌栎栏树栖样栾桊桠桡桢档桤桥桦桧桨桩梦梼梾检棂椁椟椠椤椭楼榄榇榈榉槚槛槟槠横樯樱橥橱橹橼檐檩欢欤欧歼殁殇残殒殓殚殡殴毁毂毕毙毡毵氇气氢氩氲汇汉污汤汹沓沟没沣沤沥沦沧沨沩沪沵泞泪泶泷泸泺泻泼泽泾洁洒洼浃浅浆浇浈浉浊测浍济浏浐浑浒浓浔浕涂涌涛涝涞涟涠涡涢涣涤润涧涨涩淀渊渌渍渎渐渑渔渖渗温游湾湿溃溅溆溇滗滚滞滟滠满滢滤滥滦滨滩滪漤潆潇潋潍潜潴澜濑濒灏灭灯灵灾灿炀炉炖炜炝点炼炽烁烂烃烛烟烦烧烨烩烫烬热焕焖焘煅煳熘爱爷牍牦牵牺犊犟状犷犸犹狈狍狝狞独狭狮狯狰狱狲猃猎猕猡猪猫猬献獭玑玙玚玛玮环现玱玺珉珏珐珑珰珲琎琏琐琼瑶瑷璇璎瓒瓮瓯电画畅畲畴疖疗疟疠疡疬疮疯疱疴痈痉痒痖痨痪痫痴瘅瘆瘗瘘瘪瘫瘾瘿癞癣癫癯皑皱皲盏盐监盖盗盘眍眦眬着睁睐睑瞒瞩矫矶矾矿砀码砖砗砚砜砺砻砾础硁硅硕硖硗硙硚确硷碍碛碜碱碹磙礼祎祢祯祷祸禀禄禅离秃秆种积称秽秾稆税稣稳穑穷窃窍窑窜窝窥窦窭竖竞笃笋笔笕笺笼笾筑筚筛筜筝筹签简箓箦箧箨箩箪箫篑篓篮篱簖籁籴类籼粜粝粤粪粮糁糇紧絷纟纠纡红纣纤纥约级纨纩纪纫纬纭纮纯纰纱纲纳纴纵纶纷纸纹纺纻纼纽纾线绀绁绂练组绅细织终绉绊绋绌绍绎经绐绑绒结绔绕绖绗绘给绚绛络绝绞统绠绡绢绣绤绥绦继绨绩绪绫绬续绮绯绰绱绲绳维绵绶绷绸绹绺绻综绽绾绿缀缁缂缃缄缅缆缇缈缉缊缋缌缍缎缏缐缑缒缓缔缕编缗缘缙缚缛缜缝缞缟缠缡缢缣缤缥缦缧缨缩缪缫缬缭缮缯缰缱缲缳缴缵罂网罗罚罢罴羁羟羡翘翙翚耢耧耸耻聂聋职聍联聩聪肃肠肤肷肾肿胀胁胆胜胧胨胪胫胶脉脍脏脐脑脓脔脚脱脶脸腊腌腘腭腻腼腽腾膑臜舆舣舰舱舻艰艳艹艺节芈芗芜芦苁苇苈苋苌苍苎苏苘苹茎茏茑茔茕茧荆荐荙荚荛荜荞荟荠荡荣荤荥荦荧荨荩荪荫荬荭荮药莅莜莱莲莳莴莶获莸莹莺莼萚萝萤营萦萧萨葱蒇蒉蒋蒌蓝蓟蓠蓣蓥蓦蔷蔹蔺蔼蕲蕴薮藁藓虏虑虚虫虬虮虽虾虿蚀蚁蚂蚕蚝蚬蛊蛎蛏蛮蛰蛱蛲蛳蛴蜕蜗蜡蝇蝈蝉蝎蝼蝾螀螨蟏衅衔补衬衮袄袅袆袜袭袯装裆裈裢裣裤裥褛褴襁襕见观觃规觅视觇览觉觊觋觌觍觎觏觐觑觞触觯詟誉誊讠计订讣认讥讦讧讨让讪讫训议讯记讱讲讳讴讵讶讷许讹论讻讼讽设访诀证诂诃评诅识诇诈诉诊诋诌词诎诏诐译诒诓诔试诖诗诘诙诚诛诜话诞诟诠诡询诣诤该详诧诨诩诪诫诬语诮误诰诱诲诳说诵诶请诸诹诺读诼诽课诿谀谁谂调谄谅谆谇谈谊谋谌谍谎谏谐谑谒谓谔谕谖谗谘谙谚谛谜谝谞谟谠谡谢谣谤谥谦谧谨谩谪谫谬谭谮谯谰谱谲谳谴谵谶谷豮贝贞负贠贡财责贤败账货质贩贪贫贬购贮贯贰贱贲贳贴贵贶贷贸费贺贻贼贽贾贿赀赁赂赃资赅赆赇赈赉赊赋赌赍赎赏赐赑赒赓赔赕赖赗赘赙赚赛赜赝赞赟赠赡赢赣赪赵赶趋趱趸跃跄跖跞践跶跷跸跹跻踊踌踪踬踯蹑蹒蹰蹿躏躜躯车轧轨轩轪轫转轭轮软轰轱轲轳轴轵轶轷轸轹轺轻轼载轾轿辀辁辂较辄辅辆辇辈辉辊辋辌辍辎辏辐辑辒输辔辕辖辗辘辙辚辞辩辫边辽达迁过迈运还这进远违连迟迩迳迹适选逊递逦逻遗遥邓邝邬邮邹邺邻郁郄郏郐郑郓郦郧郸酝酦酱酽酾酿释里鉅鉴銮錾钆钇针钉钊钋钌钍钎钏钐钑钒钓钔钕钖钗钘钙钚钛钝钞钟钠钡钢钣钤钥钦钧钨钩钪钫钬钭钮钯钰钱钲钳钴钵钶钷钸钹钺钻钼钽钾钿铀铁铂铃铄铅铆铈铉铊铋铍铎铏铐铑铒铕铗铘铙铚铛铜铝铞铟铠铡铢铣铤铥铦铧铨铪铫铬铭铮铯铰铱铲铳铴铵银铷铸铹铺铻铼铽链铿销锁锂锃锄锅锆锇锈锉锊锋锌锍锎锏锐锑锒锓锔锕锖锗错锚锜锞锟锠锡锢锣锤锥锦锨锩锫锬锭键锯锰锱锲锳锴锵锶锷锸锹锺锻锼锽锾锿镀镁镂镃镆镇镈镉镊镌镍镎镏镐镑镒镕镖镗镙镚镛镜镝镞镟镠镡镢镣镤镥镦镧镨镩镪镫镬镭镮镯镰镱镲镳镴镶长门闩闪闫闬闭问闯闰闱闲闳间闵闶闷闸闹闺闻闼闽闾闿阀阁阂阃阄阅阆阇阈阉阊阋阌阍阎阏阐阑阒阓阔阕阖阗阘阙阚阛队阳阴阵阶际陆陇陈陉陕陧陨险随隐隶隽难雏雠雳雾霁霉霭靓静靥鞑鞒鞯鞴韦韧韨韩韪韫韬韵页顶顷顸项顺须顼顽顾顿颀颁颂颃预颅领颇颈颉颊颋颌颍颎颏颐频颒颓颔颕颖颗题颙颚颛颜额颞颟颠颡颢颣颤颥颦颧风飏飐飑飒飓飔飕飖飗飘飙飚飞飨餍饤饥饦饧饨饩饪饫饬饭饮饯饰饱饲饳饴饵饶饷饸饹饺饻饼饽饾饿馀馁馂馃馄馅馆馇馈馉馊馋馌馍馎馏馐馑馒馓馔馕马驭驮驯驰驱驲驳驴驵驶驷驸驹驺驻驼驽驾驿骀骁骂骃骄骅骆骇骈骉骊骋验骍骎骏骐骑骒骓骔骕骖骗骘骙骚骛骜骝骞骟骠骡骢骣骤骥骦骧髅髋髌鬓魇魉鱼鱽鱾鱿鲀鲁鲂鲄鲅鲆鲇鲈鲉鲊鲋鲌鲍鲎鲏鲐鲑鲒鲓鲔鲕鲖鲗鲘鲙鲚鲛鲜鲝鲞鲟鲠鲡鲢鲣鲤鲥鲦鲧鲨鲩鲪鲫鲬鲭鲮鲯鲰鲱鲲鲳鲴鲵鲶鲷鲸鲹鲺鲻鲼鲽鲾鲿鳀鳁鳂鳃鳄鳅鳆鳇鳈鳉鳊鳋鳌鳍鳎鳏鳐鳑鳒鳓鳔鳕鳖鳗鳘鳙鳛鳜鳝鳞鳟鳠鳡鳢鳣鸟鸠鸡鸢鸣鸤鸥鸦鸧鸨鸩鸪鸫鸬鸭鸮鸯鸰鸱鸲鸳鸴鸵鸶鸷鸸鸹鸺鸻鸼鸽鸾鸿鹀鹁鹂鹃鹄鹅鹆鹇鹈鹉鹊鹋鹌鹍鹎鹏鹐鹑鹒鹓鹔鹕鹖鹗鹘鹚鹛鹜鹝鹞鹟鹠鹡鹢鹣鹤鹥鹦鹧鹨鹩鹪鹫鹬鹭鹯鹰鹱鹲鹳鹴鹾麦麸黄黉黡黩黪黾\", t = \"萬與醜專業叢東絲丟兩嚴喪個爿豐臨為麗舉麼義烏樂喬習鄉書買亂爭於虧雲亙亞產畝親褻嚲億僅從侖倉儀們價眾優夥會傴傘偉傳傷倀倫傖偽佇體餘傭僉俠侶僥偵側僑儈儕儂俁儔儼倆儷儉債傾傯僂僨償儻儐儲儺兒兌兗黨蘭關興茲養獸囅內岡冊寫軍農塚馮衝決況凍淨淒涼淩減湊凜幾鳳鳧憑凱擊氹鑿芻劃劉則剛創刪別剗剄劊劌剴劑剮劍剝劇勸辦務勱動勵勁勞勢勳猛勩勻匭匱區醫華協單賣盧鹵臥衛卻巹廠廳曆厲壓厭厙廁廂厴廈廚廄廝縣參靉靆雙發變敘疊葉號歎嘰籲後嚇呂嗎唚噸聽啟吳嘸囈嘔嚦唄員咼嗆嗚詠哢嚨嚀噝吒噅鹹呱響啞噠嘵嗶噦嘩噲嚌噥喲嘜嗊嘮啢嗩唕喚呼嘖嗇囀齧囉嘽嘯噴嘍嚳囁嗬噯噓嚶囑嚕劈囂謔團園囪圍圇國圖圓聖壙場阪壞塊堅壇壢壩塢墳墜壟壟壚壘墾坰堊墊埡墶壋塏堖塒塤堝墊垵塹墮壪牆壯聲殼壺壼處備複夠頭誇夾奪奩奐奮獎奧妝婦媽嫵嫗媯姍薑婁婭嬈嬌孌娛媧嫻嫿嬰嬋嬸媼嬡嬪嬙嬤孫學孿寧寶實寵審憲宮寬賓寢對尋導壽將爾塵堯尷屍盡層屭屜屆屬屢屨嶼歲豈嶇崗峴嶴嵐島嶺嶽崠巋嶨嶧峽嶢嶠崢巒嶗崍嶮嶄嶸嶔崳嶁脊巔鞏巰幣帥師幃帳簾幟帶幀幫幬幘幗冪襆幹並廣莊慶廬廡庫應廟龐廢廎廩開異棄張彌弳彎彈強歸當錄彠彥徹徑徠禦憶懺憂愾懷態慫憮慪悵愴憐總懟懌戀懇惡慟懨愷惻惱惲悅愨懸慳憫驚懼慘懲憊愜慚憚慣湣慍憤憒願懾憖怵懣懶懍戇戔戲戧戰戩戶紮撲扡執擴捫掃揚擾撫拋摶摳掄搶護報擔擬攏揀擁攔擰撥擇掛摯攣掗撾撻挾撓擋撟掙擠揮撏撈損撿換搗據撚擄摑擲撣摻摜摣攬撳攙擱摟攪攜攝攄擺搖擯攤攖撐攆擷擼攛擻攢敵斂數齋斕鬥斬斷無舊時曠暘曇晝曨顯晉曬曉曄暈暉暫曖劄術樸機殺雜權條來楊榪傑極構樅樞棗櫪梘棖槍楓梟櫃檸檉梔柵標棧櫛櫳棟櫨櫟欄樹棲樣欒棬椏橈楨檔榿橋樺檜槳樁夢檮棶檢欞槨櫝槧欏橢樓欖櫬櫚櫸檟檻檳櫧橫檣櫻櫫櫥櫓櫞簷檁歡歟歐殲歿殤殘殞殮殫殯毆毀轂畢斃氈毿氌氣氫氬氳彙漢汙湯洶遝溝沒灃漚瀝淪滄渢溈滬濔濘淚澩瀧瀘濼瀉潑澤涇潔灑窪浹淺漿澆湞溮濁測澮濟瀏滻渾滸濃潯濜塗湧濤澇淶漣潿渦溳渙滌潤澗漲澀澱淵淥漬瀆漸澠漁瀋滲溫遊灣濕潰濺漵漊潷滾滯灩灄滿瀅濾濫灤濱灘澦濫瀠瀟瀲濰潛瀦瀾瀨瀕灝滅燈靈災燦煬爐燉煒熗點煉熾爍爛烴燭煙煩燒燁燴燙燼熱煥燜燾煆糊溜愛爺牘犛牽犧犢強狀獷獁猶狽麅獮獰獨狹獅獪猙獄猻獫獵獼玀豬貓蝟獻獺璣璵瑒瑪瑋環現瑲璽瑉玨琺瓏璫琿璡璉瑣瓊瑤璦璿瓔瓚甕甌電畫暢佘疇癤療瘧癘瘍鬁瘡瘋皰屙癰痙癢瘂癆瘓癇癡癉瘮瘞瘺癟癱癮癭癩癬癲臒皚皺皸盞鹽監蓋盜盤瞘眥矓著睜睞瞼瞞矚矯磯礬礦碭碼磚硨硯碸礪礱礫礎硜矽碩硤磽磑礄確鹼礙磧磣堿镟滾禮禕禰禎禱禍稟祿禪離禿稈種積稱穢穠穭稅穌穩穡窮竊竅窯竄窩窺竇窶豎競篤筍筆筧箋籠籩築篳篩簹箏籌簽簡籙簀篋籜籮簞簫簣簍籃籬籪籟糴類秈糶糲粵糞糧糝餱緊縶糸糾紆紅紂纖紇約級紈纊紀紉緯紜紘純紕紗綱納紝縱綸紛紙紋紡紵紖紐紓線紺絏紱練組紳細織終縐絆紼絀紹繹經紿綁絨結絝繞絰絎繪給絢絳絡絕絞統綆綃絹繡綌綏絛繼綈績緒綾緓續綺緋綽緔緄繩維綿綬繃綢綯綹綣綜綻綰綠綴緇緙緗緘緬纜緹緲緝縕繢緦綞緞緶線緱縋緩締縷編緡緣縉縛縟縝縫縗縞纏縭縊縑繽縹縵縲纓縮繆繅纈繚繕繒韁繾繰繯繳纘罌網羅罰罷羆羈羥羨翹翽翬耮耬聳恥聶聾職聹聯聵聰肅腸膚膁腎腫脹脅膽勝朧腖臚脛膠脈膾髒臍腦膿臠腳脫腡臉臘醃膕齶膩靦膃騰臏臢輿艤艦艙艫艱豔艸藝節羋薌蕪蘆蓯葦藶莧萇蒼苧蘇檾蘋莖蘢蔦塋煢繭荊薦薘莢蕘蓽蕎薈薺蕩榮葷滎犖熒蕁藎蓀蔭蕒葒葤藥蒞蓧萊蓮蒔萵薟獲蕕瑩鶯蓴蘀蘿螢營縈蕭薩蔥蕆蕢蔣蔞藍薊蘺蕷鎣驀薔蘞藺藹蘄蘊藪槁蘚虜慮虛蟲虯蟣雖蝦蠆蝕蟻螞蠶蠔蜆蠱蠣蟶蠻蟄蛺蟯螄蠐蛻蝸蠟蠅蟈蟬蠍螻蠑螿蟎蠨釁銜補襯袞襖嫋褘襪襲襏裝襠褌褳襝褲襇褸襤繈襴見觀覎規覓視覘覽覺覬覡覿覥覦覯覲覷觴觸觶讋譽謄訁計訂訃認譏訐訌討讓訕訖訓議訊記訒講諱謳詎訝訥許訛論訩訟諷設訪訣證詁訶評詛識詗詐訴診詆謅詞詘詔詖譯詒誆誄試詿詩詰詼誠誅詵話誕詬詮詭詢詣諍該詳詫諢詡譸誡誣語誚誤誥誘誨誑說誦誒請諸諏諾讀諑誹課諉諛誰諗調諂諒諄誶談誼謀諶諜謊諫諧謔謁謂諤諭諼讒諮諳諺諦謎諞諝謨讜謖謝謠謗諡謙謐謹謾謫譾謬譚譖譙讕譜譎讞譴譫讖穀豶貝貞負貟貢財責賢敗賬貨質販貪貧貶購貯貫貳賤賁貰貼貴貺貸貿費賀貽賊贄賈賄貲賃賂贓資賅贐賕賑賚賒賦賭齎贖賞賜贔賙賡賠賧賴賵贅賻賺賽賾贗讚贇贈贍贏贛赬趙趕趨趲躉躍蹌蹠躒踐躂蹺蹕躚躋踴躊蹤躓躑躡蹣躕躥躪躦軀車軋軌軒軑軔轉軛輪軟轟軲軻轤軸軹軼軤軫轢軺輕軾載輊轎輈輇輅較輒輔輛輦輩輝輥輞輬輟輜輳輻輯轀輸轡轅轄輾轆轍轔辭辯辮邊遼達遷過邁運還這進遠違連遲邇逕跡適選遜遞邐邏遺遙鄧鄺鄔郵鄒鄴鄰鬱郤郟鄶鄭鄆酈鄖鄲醞醱醬釅釃釀釋裏钜鑒鑾鏨釓釔針釘釗釙釕釷釺釧釤鈒釩釣鍆釹鍚釵鈃鈣鈈鈦鈍鈔鍾鈉鋇鋼鈑鈐鑰欽鈞鎢鉤鈧鈁鈥鈄鈕鈀鈺錢鉦鉗鈷缽鈳鉕鈽鈸鉞鑽鉬鉭鉀鈿鈾鐵鉑鈴鑠鉛鉚鈰鉉鉈鉍鈹鐸鉶銬銠鉺銪鋏鋣鐃銍鐺銅鋁銱銦鎧鍘銖銑鋌銩銛鏵銓鉿銚鉻銘錚銫鉸銥鏟銃鐋銨銀銣鑄鐒鋪鋙錸鋱鏈鏗銷鎖鋰鋥鋤鍋鋯鋨鏽銼鋝鋒鋅鋶鐦鐧銳銻鋃鋟鋦錒錆鍺錯錨錡錁錕錩錫錮鑼錘錐錦鍁錈錇錟錠鍵鋸錳錙鍥鍈鍇鏘鍶鍔鍤鍬鍾鍛鎪鍠鍰鎄鍍鎂鏤鎡鏌鎮鎛鎘鑷鐫鎳鎿鎦鎬鎊鎰鎔鏢鏜鏍鏰鏞鏡鏑鏃鏇鏐鐔钁鐐鏷鑥鐓鑭鐠鑹鏹鐙鑊鐳鐶鐲鐮鐿鑔鑣鑞鑲長門閂閃閆閈閉問闖閏闈閑閎間閔閌悶閘鬧閨聞闥閩閭闓閥閣閡閫鬮閱閬闍閾閹閶鬩閿閽閻閼闡闌闃闠闊闋闔闐闒闕闞闤隊陽陰陣階際陸隴陳陘陝隉隕險隨隱隸雋難雛讎靂霧霽黴靄靚靜靨韃鞽韉韝韋韌韍韓韙韞韜韻頁頂頃頇項順須頊頑顧頓頎頒頌頏預顱領頗頸頡頰頲頜潁熲頦頤頻頮頹頷頴穎顆題顒顎顓顏額顳顢顛顙顥纇顫顬顰顴風颺颭颮颯颶颸颼颻飀飄飆飆飛饗饜飣饑飥餳飩餼飪飫飭飯飲餞飾飽飼飿飴餌饒餉餄餎餃餏餅餑餖餓餘餒餕餜餛餡館餷饋餶餿饞饁饃餺餾饈饉饅饊饌饢馬馭馱馴馳驅馹駁驢駔駛駟駙駒騶駐駝駑駕驛駘驍罵駰驕驊駱駭駢驫驪騁驗騂駸駿騏騎騍騅騌驌驂騙騭騤騷騖驁騮騫騸驃騾驄驏驟驥驦驤髏髖髕鬢魘魎魚魛魢魷魨魯魴魺鮁鮃鯰鱸鮋鮓鮒鮊鮑鱟鮍鮐鮭鮚鮳鮪鮞鮦鰂鮜鱠鱭鮫鮮鮺鯗鱘鯁鱺鰱鰹鯉鰣鰷鯀鯊鯇鮶鯽鯒鯖鯪鯕鯫鯡鯤鯧鯝鯢鯰鯛鯨鯵鯴鯔鱝鰈鰏鱨鯷鰮鰃鰓鱷鰍鰒鰉鰁鱂鯿鰠鼇鰭鰨鰥鰩鰟鰜鰳鰾鱈鱉鰻鰵鱅鰼鱖鱔鱗鱒鱯鱤鱧鱣鳥鳩雞鳶鳴鳲鷗鴉鶬鴇鴆鴣鶇鸕鴨鴞鴦鴒鴟鴝鴛鴬鴕鷥鷙鴯鴰鵂鴴鵃鴿鸞鴻鵐鵓鸝鵑鵠鵝鵒鷳鵜鵡鵲鶓鵪鶤鵯鵬鵮鶉鶊鵷鷫鶘鶡鶚鶻鶿鶥鶩鷊鷂鶲鶹鶺鷁鶼鶴鷖鸚鷓鷚鷯鷦鷲鷸鷺鸇鷹鸌鸏鸛鸘鹺麥麩黃黌黶黷黲黽\"; if (!currentEncoding) {//如果当前是 繁体切换为简体，进行交换。 j = s; s = t; t = j; } for (let i = 0; i &lt; text.length; i++) { j = s.indexOf(text[i]); result += j === -1 ? text[i] : t[j]; } return result;} 保存与切换状态保存状态&nbsp;&nbsp;&nbsp;&nbsp;相信学习过 HTML5 的同学都对localStorage有一点的了解吧，我们就利用它来进行当前状态的保存。当用户进入网站时，读取曾经保存的状态，而每当状态的切换，我们都要刷新当前存储的值。另外，值得注意得是，localStorage中存储的是字符串类型的值，必须对其进行转换，才能使用，如下所示： if (localStorage.getItem(\"targetEncoding\") === \"false\") { /* doSomething... */} 切换状态&nbsp;&nbsp;&nbsp;&nbsp;目前我们的需求是简繁字体切换，充其量就是两种状态的保存，用 布尔类型 一定是没错的。 let currentEncoding = targetEncoding = true; &nbsp;&nbsp;&nbsp;&nbsp;我们定义了两个变量，当 currentEncoding的值为 true 时，说明 当前字体为简体，反之为繁体。而targetEncoding永远指向 currentEncoding下一个要切换的状态。 &nbsp;&nbsp;&nbsp;&nbsp;当切换状态时， 逻辑如下： currentEncoding = targetEncoding;targetEncoding = !targetEncoding; &nbsp;&nbsp;&nbsp;&nbsp;Ok ，大体过程就搞定了，下面是源码~ 源代码点击显/隐源文件 let currentEncoding = targetEncoding = true;let stopDOM = [\"BR\",\"TIME\",\"IMG\",\"CANVAS\",\"SCRIPT\"];if (localStorage.getItem(\"targetEncoding\") === \"false\") { targetEncoding = false; translateBody();}function translateBody(obj) { let objs = (obj ? obj : document.body).childNodes; for (let i = 0; i &lt; objs.length; i++) { if (objs[i].nodeType === 3 &amp;&amp; /[\\u4e00-\\u9fa5]/g.test(objs[i].textContent)) { objs[i].textContent = Exchange(objs[i].textContent); } else if (objs[i].nodeType === 1 &amp;&amp; !stopDOM.includes(objs[i].tagName)) { translateBody(objs[i]); } }}function Exchange(text) { let result = '', j, s = \"万与丑专业丛东丝丢两严丧个丬丰临为丽举么义乌乐乔习乡书买乱争于亏云亘亚产亩亲亵亸亿仅从仑仓仪们价众优伙会伛伞伟传伤伥伦伧伪伫体余佣佥侠侣侥侦侧侨侩侪侬俣俦俨俩俪俭债倾偬偻偾偿傥傧储傩儿兑兖党兰关兴兹养兽冁内冈册写军农冢冯冲决况冻净凄凉凌减凑凛几凤凫凭凯击凼凿刍划刘则刚创删别刬刭刽刿剀剂剐剑剥剧劝办务劢动励劲劳势勋勐勚匀匦匮区医华协单卖卢卤卧卫却卺厂厅历厉压厌厍厕厢厣厦厨厩厮县参叆叇双发变叙叠叶号叹叽吁后吓吕吗吣吨听启吴呒呓呕呖呗员呙呛呜咏咔咙咛咝咤咴咸哌响哑哒哓哔哕哗哙哜哝哟唛唝唠唡唢唣唤唿啧啬啭啮啰啴啸喷喽喾嗫呵嗳嘘嘤嘱噜噼嚣嚯团园囱围囵国图圆圣圹场坂坏块坚坛坜坝坞坟坠垄垅垆垒垦垧垩垫垭垯垱垲垴埘埙埚埝埯堑堕塆墙壮声壳壶壸处备复够头夸夹夺奁奂奋奖奥妆妇妈妩妪妫姗姜娄娅娆娇娈娱娲娴婳婴婵婶媪嫒嫔嫱嬷孙学孪宁宝实宠审宪宫宽宾寝对寻导寿将尔尘尧尴尸尽层屃屉届属屡屦屿岁岂岖岗岘岙岚岛岭岳岽岿峃峄峡峣峤峥峦崂崃崄崭嵘嵚嵛嵝嵴巅巩巯币帅师帏帐帘帜带帧帮帱帻帼幂幞干并广庄庆庐庑库应庙庞废庼廪开异弃张弥弪弯弹强归当录彟彦彻径徕御忆忏忧忾怀态怂怃怄怅怆怜总怼怿恋恳恶恸恹恺恻恼恽悦悫悬悭悯惊惧惨惩惫惬惭惮惯愍愠愤愦愿慑慭憷懑懒懔戆戋戏戗战戬户扎扑扦执扩扪扫扬扰抚抛抟抠抡抢护报担拟拢拣拥拦拧拨择挂挚挛挜挝挞挟挠挡挢挣挤挥挦捞损捡换捣据捻掳掴掷掸掺掼揸揽揿搀搁搂搅携摄摅摆摇摈摊撄撑撵撷撸撺擞攒敌敛数斋斓斗斩断无旧时旷旸昙昼昽显晋晒晓晔晕晖暂暧札术朴机杀杂权条来杨杩杰极构枞枢枣枥枧枨枪枫枭柜柠柽栀栅标栈栉栊栋栌栎栏树栖样栾桊桠桡桢档桤桥桦桧桨桩梦梼梾检棂椁椟椠椤椭楼榄榇榈榉槚槛槟槠横樯樱橥橱橹橼檐檩欢欤欧歼殁殇残殒殓殚殡殴毁毂毕毙毡毵氇气氢氩氲汇汉污汤汹沓沟没沣沤沥沦沧沨沩沪沵泞泪泶泷泸泺泻泼泽泾洁洒洼浃浅浆浇浈浉浊测浍济浏浐浑浒浓浔浕涂涌涛涝涞涟涠涡涢涣涤润涧涨涩淀渊渌渍渎渐渑渔渖渗温游湾湿溃溅溆溇滗滚滞滟滠满滢滤滥滦滨滩滪漤潆潇潋潍潜潴澜濑濒灏灭灯灵灾灿炀炉炖炜炝点炼炽烁烂烃烛烟烦烧烨烩烫烬热焕焖焘煅煳熘爱爷牍牦牵牺犊犟状犷犸犹狈狍狝狞独狭狮狯狰狱狲猃猎猕猡猪猫猬献獭玑玙玚玛玮环现玱玺珉珏珐珑珰珲琎琏琐琼瑶瑷璇璎瓒瓮瓯电画畅畲畴疖疗疟疠疡疬疮疯疱疴痈痉痒痖痨痪痫痴瘅瘆瘗瘘瘪瘫瘾瘿癞癣癫癯皑皱皲盏盐监盖盗盘眍眦眬着睁睐睑瞒瞩矫矶矾矿砀码砖砗砚砜砺砻砾础硁硅硕硖硗硙硚确硷碍碛碜碱碹磙礼祎祢祯祷祸禀禄禅离秃秆种积称秽秾稆税稣稳穑穷窃窍窑窜窝窥窦窭竖竞笃笋笔笕笺笼笾筑筚筛筜筝筹签简箓箦箧箨箩箪箫篑篓篮篱簖籁籴类籼粜粝粤粪粮糁糇紧絷纟纠纡红纣纤纥约级纨纩纪纫纬纭纮纯纰纱纲纳纴纵纶纷纸纹纺纻纼纽纾线绀绁绂练组绅细织终绉绊绋绌绍绎经绐绑绒结绔绕绖绗绘给绚绛络绝绞统绠绡绢绣绤绥绦继绨绩绪绫绬续绮绯绰绱绲绳维绵绶绷绸绹绺绻综绽绾绿缀缁缂缃缄缅缆缇缈缉缊缋缌缍缎缏缐缑缒缓缔缕编缗缘缙缚缛缜缝缞缟缠缡缢缣缤缥缦缧缨缩缪缫缬缭缮缯缰缱缲缳缴缵罂网罗罚罢罴羁羟羡翘翙翚耢耧耸耻聂聋职聍联聩聪肃肠肤肷肾肿胀胁胆胜胧胨胪胫胶脉脍脏脐脑脓脔脚脱脶脸腊腌腘腭腻腼腽腾膑臜舆舣舰舱舻艰艳艹艺节芈芗芜芦苁苇苈苋苌苍苎苏苘苹茎茏茑茔茕茧荆荐荙荚荛荜荞荟荠荡荣荤荥荦荧荨荩荪荫荬荭荮药莅莜莱莲莳莴莶获莸莹莺莼萚萝萤营萦萧萨葱蒇蒉蒋蒌蓝蓟蓠蓣蓥蓦蔷蔹蔺蔼蕲蕴薮藁藓虏虑虚虫虬虮虽虾虿蚀蚁蚂蚕蚝蚬蛊蛎蛏蛮蛰蛱蛲蛳蛴蜕蜗蜡蝇蝈蝉蝎蝼蝾螀螨蟏衅衔补衬衮袄袅袆袜袭袯装裆裈裢裣裤裥褛褴襁襕见观觃规觅视觇览觉觊觋觌觍觎觏觐觑觞触觯詟誉誊讠计订讣认讥讦讧讨让讪讫训议讯记讱讲讳讴讵讶讷许讹论讻讼讽设访诀证诂诃评诅识诇诈诉诊诋诌词诎诏诐译诒诓诔试诖诗诘诙诚诛诜话诞诟诠诡询诣诤该详诧诨诩诪诫诬语诮误诰诱诲诳说诵诶请诸诹诺读诼诽课诿谀谁谂调谄谅谆谇谈谊谋谌谍谎谏谐谑谒谓谔谕谖谗谘谙谚谛谜谝谞谟谠谡谢谣谤谥谦谧谨谩谪谫谬谭谮谯谰谱谲谳谴谵谶谷豮贝贞负贠贡财责贤败账货质贩贪贫贬购贮贯贰贱贲贳贴贵贶贷贸费贺贻贼贽贾贿赀赁赂赃资赅赆赇赈赉赊赋赌赍赎赏赐赑赒赓赔赕赖赗赘赙赚赛赜赝赞赟赠赡赢赣赪赵赶趋趱趸跃跄跖跞践跶跷跸跹跻踊踌踪踬踯蹑蹒蹰蹿躏躜躯车轧轨轩轪轫转轭轮软轰轱轲轳轴轵轶轷轸轹轺轻轼载轾轿辀辁辂较辄辅辆辇辈辉辊辋辌辍辎辏辐辑辒输辔辕辖辗辘辙辚辞辩辫边辽达迁过迈运还这进远违连迟迩迳迹适选逊递逦逻遗遥邓邝邬邮邹邺邻郁郄郏郐郑郓郦郧郸酝酦酱酽酾酿释里鉅鉴銮錾钆钇针钉钊钋钌钍钎钏钐钑钒钓钔钕钖钗钘钙钚钛钝钞钟钠钡钢钣钤钥钦钧钨钩钪钫钬钭钮钯钰钱钲钳钴钵钶钷钸钹钺钻钼钽钾钿铀铁铂铃铄铅铆铈铉铊铋铍铎铏铐铑铒铕铗铘铙铚铛铜铝铞铟铠铡铢铣铤铥铦铧铨铪铫铬铭铮铯铰铱铲铳铴铵银铷铸铹铺铻铼铽链铿销锁锂锃锄锅锆锇锈锉锊锋锌锍锎锏锐锑锒锓锔锕锖锗错锚锜锞锟锠锡锢锣锤锥锦锨锩锫锬锭键锯锰锱锲锳锴锵锶锷锸锹锺锻锼锽锾锿镀镁镂镃镆镇镈镉镊镌镍镎镏镐镑镒镕镖镗镙镚镛镜镝镞镟镠镡镢镣镤镥镦镧镨镩镪镫镬镭镮镯镰镱镲镳镴镶长门闩闪闫闬闭问闯闰闱闲闳间闵闶闷闸闹闺闻闼闽闾闿阀阁阂阃阄阅阆阇阈阉阊阋阌阍阎阏阐阑阒阓阔阕阖阗阘阙阚阛队阳阴阵阶际陆陇陈陉陕陧陨险随隐隶隽难雏雠雳雾霁霉霭靓静靥鞑鞒鞯鞴韦韧韨韩韪韫韬韵页顶顷顸项顺须顼顽顾顿颀颁颂颃预颅领颇颈颉颊颋颌颍颎颏颐频颒颓颔颕颖颗题颙颚颛颜额颞颟颠颡颢颣颤颥颦颧风飏飐飑飒飓飔飕飖飗飘飙飚飞飨餍饤饥饦饧饨饩饪饫饬饭饮饯饰饱饲饳饴饵饶饷饸饹饺饻饼饽饾饿馀馁馂馃馄馅馆馇馈馉馊馋馌馍馎馏馐馑馒馓馔馕马驭驮驯驰驱驲驳驴驵驶驷驸驹驺驻驼驽驾驿骀骁骂骃骄骅骆骇骈骉骊骋验骍骎骏骐骑骒骓骔骕骖骗骘骙骚骛骜骝骞骟骠骡骢骣骤骥骦骧髅髋髌鬓魇魉鱼鱽鱾鱿鲀鲁鲂鲄鲅鲆鲇鲈鲉鲊鲋鲌鲍鲎鲏鲐鲑鲒鲓鲔鲕鲖鲗鲘鲙鲚鲛鲜鲝鲞鲟鲠鲡鲢鲣鲤鲥鲦鲧鲨鲩鲪鲫鲬鲭鲮鲯鲰鲱鲲鲳鲴鲵鲶鲷鲸鲹鲺鲻鲼鲽鲾鲿鳀鳁鳂鳃鳄鳅鳆鳇鳈鳉鳊鳋鳌鳍鳎鳏鳐鳑鳒鳓鳔鳕鳖鳗鳘鳙鳛鳜鳝鳞鳟鳠鳡鳢鳣鸟鸠鸡鸢鸣鸤鸥鸦鸧鸨鸩鸪鸫鸬鸭鸮鸯鸰鸱鸲鸳鸴鸵鸶鸷鸸鸹鸺鸻鸼鸽鸾鸿鹀鹁鹂鹃鹄鹅鹆鹇鹈鹉鹊鹋鹌鹍鹎鹏鹐鹑鹒鹓鹔鹕鹖鹗鹘鹚鹛鹜鹝鹞鹟鹠鹡鹢鹣鹤鹥鹦鹧鹨鹩鹪鹫鹬鹭鹯鹰鹱鹲鹳鹴鹾麦麸黄黉黡黩黪黾\", t = \"萬與醜專業叢東絲丟兩嚴喪個爿豐臨為麗舉麼義烏樂喬習鄉書買亂爭於虧雲亙亞產畝親褻嚲億僅從侖倉儀們價眾優夥會傴傘偉傳傷倀倫傖偽佇體餘傭僉俠侶僥偵側僑儈儕儂俁儔儼倆儷儉債傾傯僂僨償儻儐儲儺兒兌兗黨蘭關興茲養獸囅內岡冊寫軍農塚馮衝決況凍淨淒涼淩減湊凜幾鳳鳧憑凱擊氹鑿芻劃劉則剛創刪別剗剄劊劌剴劑剮劍剝劇勸辦務勱動勵勁勞勢勳猛勩勻匭匱區醫華協單賣盧鹵臥衛卻巹廠廳曆厲壓厭厙廁廂厴廈廚廄廝縣參靉靆雙發變敘疊葉號歎嘰籲後嚇呂嗎唚噸聽啟吳嘸囈嘔嚦唄員咼嗆嗚詠哢嚨嚀噝吒噅鹹呱響啞噠嘵嗶噦嘩噲嚌噥喲嘜嗊嘮啢嗩唕喚呼嘖嗇囀齧囉嘽嘯噴嘍嚳囁嗬噯噓嚶囑嚕劈囂謔團園囪圍圇國圖圓聖壙場阪壞塊堅壇壢壩塢墳墜壟壟壚壘墾坰堊墊埡墶壋塏堖塒塤堝墊垵塹墮壪牆壯聲殼壺壼處備複夠頭誇夾奪奩奐奮獎奧妝婦媽嫵嫗媯姍薑婁婭嬈嬌孌娛媧嫻嫿嬰嬋嬸媼嬡嬪嬙嬤孫學孿寧寶實寵審憲宮寬賓寢對尋導壽將爾塵堯尷屍盡層屭屜屆屬屢屨嶼歲豈嶇崗峴嶴嵐島嶺嶽崠巋嶨嶧峽嶢嶠崢巒嶗崍嶮嶄嶸嶔崳嶁脊巔鞏巰幣帥師幃帳簾幟帶幀幫幬幘幗冪襆幹並廣莊慶廬廡庫應廟龐廢廎廩開異棄張彌弳彎彈強歸當錄彠彥徹徑徠禦憶懺憂愾懷態慫憮慪悵愴憐總懟懌戀懇惡慟懨愷惻惱惲悅愨懸慳憫驚懼慘懲憊愜慚憚慣湣慍憤憒願懾憖怵懣懶懍戇戔戲戧戰戩戶紮撲扡執擴捫掃揚擾撫拋摶摳掄搶護報擔擬攏揀擁攔擰撥擇掛摯攣掗撾撻挾撓擋撟掙擠揮撏撈損撿換搗據撚擄摑擲撣摻摜摣攬撳攙擱摟攪攜攝攄擺搖擯攤攖撐攆擷擼攛擻攢敵斂數齋斕鬥斬斷無舊時曠暘曇晝曨顯晉曬曉曄暈暉暫曖劄術樸機殺雜權條來楊榪傑極構樅樞棗櫪梘棖槍楓梟櫃檸檉梔柵標棧櫛櫳棟櫨櫟欄樹棲樣欒棬椏橈楨檔榿橋樺檜槳樁夢檮棶檢欞槨櫝槧欏橢樓欖櫬櫚櫸檟檻檳櫧橫檣櫻櫫櫥櫓櫞簷檁歡歟歐殲歿殤殘殞殮殫殯毆毀轂畢斃氈毿氌氣氫氬氳彙漢汙湯洶遝溝沒灃漚瀝淪滄渢溈滬濔濘淚澩瀧瀘濼瀉潑澤涇潔灑窪浹淺漿澆湞溮濁測澮濟瀏滻渾滸濃潯濜塗湧濤澇淶漣潿渦溳渙滌潤澗漲澀澱淵淥漬瀆漸澠漁瀋滲溫遊灣濕潰濺漵漊潷滾滯灩灄滿瀅濾濫灤濱灘澦濫瀠瀟瀲濰潛瀦瀾瀨瀕灝滅燈靈災燦煬爐燉煒熗點煉熾爍爛烴燭煙煩燒燁燴燙燼熱煥燜燾煆糊溜愛爺牘犛牽犧犢強狀獷獁猶狽麅獮獰獨狹獅獪猙獄猻獫獵獼玀豬貓蝟獻獺璣璵瑒瑪瑋環現瑲璽瑉玨琺瓏璫琿璡璉瑣瓊瑤璦璿瓔瓚甕甌電畫暢佘疇癤療瘧癘瘍鬁瘡瘋皰屙癰痙癢瘂癆瘓癇癡癉瘮瘞瘺癟癱癮癭癩癬癲臒皚皺皸盞鹽監蓋盜盤瞘眥矓著睜睞瞼瞞矚矯磯礬礦碭碼磚硨硯碸礪礱礫礎硜矽碩硤磽磑礄確鹼礙磧磣堿镟滾禮禕禰禎禱禍稟祿禪離禿稈種積稱穢穠穭稅穌穩穡窮竊竅窯竄窩窺竇窶豎競篤筍筆筧箋籠籩築篳篩簹箏籌簽簡籙簀篋籜籮簞簫簣簍籃籬籪籟糴類秈糶糲粵糞糧糝餱緊縶糸糾紆紅紂纖紇約級紈纊紀紉緯紜紘純紕紗綱納紝縱綸紛紙紋紡紵紖紐紓線紺絏紱練組紳細織終縐絆紼絀紹繹經紿綁絨結絝繞絰絎繪給絢絳絡絕絞統綆綃絹繡綌綏絛繼綈績緒綾緓續綺緋綽緔緄繩維綿綬繃綢綯綹綣綜綻綰綠綴緇緙緗緘緬纜緹緲緝縕繢緦綞緞緶線緱縋緩締縷編緡緣縉縛縟縝縫縗縞纏縭縊縑繽縹縵縲纓縮繆繅纈繚繕繒韁繾繰繯繳纘罌網羅罰罷羆羈羥羨翹翽翬耮耬聳恥聶聾職聹聯聵聰肅腸膚膁腎腫脹脅膽勝朧腖臚脛膠脈膾髒臍腦膿臠腳脫腡臉臘醃膕齶膩靦膃騰臏臢輿艤艦艙艫艱豔艸藝節羋薌蕪蘆蓯葦藶莧萇蒼苧蘇檾蘋莖蘢蔦塋煢繭荊薦薘莢蕘蓽蕎薈薺蕩榮葷滎犖熒蕁藎蓀蔭蕒葒葤藥蒞蓧萊蓮蒔萵薟獲蕕瑩鶯蓴蘀蘿螢營縈蕭薩蔥蕆蕢蔣蔞藍薊蘺蕷鎣驀薔蘞藺藹蘄蘊藪槁蘚虜慮虛蟲虯蟣雖蝦蠆蝕蟻螞蠶蠔蜆蠱蠣蟶蠻蟄蛺蟯螄蠐蛻蝸蠟蠅蟈蟬蠍螻蠑螿蟎蠨釁銜補襯袞襖嫋褘襪襲襏裝襠褌褳襝褲襇褸襤繈襴見觀覎規覓視覘覽覺覬覡覿覥覦覯覲覷觴觸觶讋譽謄訁計訂訃認譏訐訌討讓訕訖訓議訊記訒講諱謳詎訝訥許訛論訩訟諷設訪訣證詁訶評詛識詗詐訴診詆謅詞詘詔詖譯詒誆誄試詿詩詰詼誠誅詵話誕詬詮詭詢詣諍該詳詫諢詡譸誡誣語誚誤誥誘誨誑說誦誒請諸諏諾讀諑誹課諉諛誰諗調諂諒諄誶談誼謀諶諜謊諫諧謔謁謂諤諭諼讒諮諳諺諦謎諞諝謨讜謖謝謠謗諡謙謐謹謾謫譾謬譚譖譙讕譜譎讞譴譫讖穀豶貝貞負貟貢財責賢敗賬貨質販貪貧貶購貯貫貳賤賁貰貼貴貺貸貿費賀貽賊贄賈賄貲賃賂贓資賅贐賕賑賚賒賦賭齎贖賞賜贔賙賡賠賧賴賵贅賻賺賽賾贗讚贇贈贍贏贛赬趙趕趨趲躉躍蹌蹠躒踐躂蹺蹕躚躋踴躊蹤躓躑躡蹣躕躥躪躦軀車軋軌軒軑軔轉軛輪軟轟軲軻轤軸軹軼軤軫轢軺輕軾載輊轎輈輇輅較輒輔輛輦輩輝輥輞輬輟輜輳輻輯轀輸轡轅轄輾轆轍轔辭辯辮邊遼達遷過邁運還這進遠違連遲邇逕跡適選遜遞邐邏遺遙鄧鄺鄔郵鄒鄴鄰鬱郤郟鄶鄭鄆酈鄖鄲醞醱醬釅釃釀釋裏钜鑒鑾鏨釓釔針釘釗釙釕釷釺釧釤鈒釩釣鍆釹鍚釵鈃鈣鈈鈦鈍鈔鍾鈉鋇鋼鈑鈐鑰欽鈞鎢鉤鈧鈁鈥鈄鈕鈀鈺錢鉦鉗鈷缽鈳鉕鈽鈸鉞鑽鉬鉭鉀鈿鈾鐵鉑鈴鑠鉛鉚鈰鉉鉈鉍鈹鐸鉶銬銠鉺銪鋏鋣鐃銍鐺銅鋁銱銦鎧鍘銖銑鋌銩銛鏵銓鉿銚鉻銘錚銫鉸銥鏟銃鐋銨銀銣鑄鐒鋪鋙錸鋱鏈鏗銷鎖鋰鋥鋤鍋鋯鋨鏽銼鋝鋒鋅鋶鐦鐧銳銻鋃鋟鋦錒錆鍺錯錨錡錁錕錩錫錮鑼錘錐錦鍁錈錇錟錠鍵鋸錳錙鍥鍈鍇鏘鍶鍔鍤鍬鍾鍛鎪鍠鍰鎄鍍鎂鏤鎡鏌鎮鎛鎘鑷鐫鎳鎿鎦鎬鎊鎰鎔鏢鏜鏍鏰鏞鏡鏑鏃鏇鏐鐔钁鐐鏷鑥鐓鑭鐠鑹鏹鐙鑊鐳鐶鐲鐮鐿鑔鑣鑞鑲長門閂閃閆閈閉問闖閏闈閑閎間閔閌悶閘鬧閨聞闥閩閭闓閥閣閡閫鬮閱閬闍閾閹閶鬩閿閽閻閼闡闌闃闠闊闋闔闐闒闕闞闤隊陽陰陣階際陸隴陳陘陝隉隕險隨隱隸雋難雛讎靂霧霽黴靄靚靜靨韃鞽韉韝韋韌韍韓韙韞韜韻頁頂頃頇項順須頊頑顧頓頎頒頌頏預顱領頗頸頡頰頲頜潁熲頦頤頻頮頹頷頴穎顆題顒顎顓顏額顳顢顛顙顥纇顫顬顰顴風颺颭颮颯颶颸颼颻飀飄飆飆飛饗饜飣饑飥餳飩餼飪飫飭飯飲餞飾飽飼飿飴餌饒餉餄餎餃餏餅餑餖餓餘餒餕餜餛餡館餷饋餶餿饞饁饃餺餾饈饉饅饊饌饢馬馭馱馴馳驅馹駁驢駔駛駟駙駒騶駐駝駑駕驛駘驍罵駰驕驊駱駭駢驫驪騁驗騂駸駿騏騎騍騅騌驌驂騙騭騤騷騖驁騮騫騸驃騾驄驏驟驥驦驤髏髖髕鬢魘魎魚魛魢魷魨魯魴魺鮁鮃鯰鱸鮋鮓鮒鮊鮑鱟鮍鮐鮭鮚鮳鮪鮞鮦鰂鮜鱠鱭鮫鮮鮺鯗鱘鯁鱺鰱鰹鯉鰣鰷鯀鯊鯇鮶鯽鯒鯖鯪鯕鯫鯡鯤鯧鯝鯢鯰鯛鯨鯵鯴鯔鱝鰈鰏鱨鯷鰮鰃鰓鱷鰍鰒鰉鰁鱂鯿鰠鼇鰭鰨鰥鰩鰟鰜鰳鰾鱈鱉鰻鰵鱅鰼鱖鱔鱗鱒鱯鱤鱧鱣鳥鳩雞鳶鳴鳲鷗鴉鶬鴇鴆鴣鶇鸕鴨鴞鴦鴒鴟鴝鴛鴬鴕鷥鷙鴯鴰鵂鴴鵃鴿鸞鴻鵐鵓鸝鵑鵠鵝鵒鷳鵜鵡鵲鶓鵪鶤鵯鵬鵮鶉鶊鵷鷫鶘鶡鶚鶻鶿鶥鶩鷊鷂鶲鶹鶺鷁鶼鶴鷖鸚鷓鷚鷯鷦鷲鷸鷺鸇鷹鸌鸏鸛鸘鹺麥麩黃黌黶黷黲黽\"; if (!currentEncoding) { j = s; s = t; t = j; } for (let i = 0; i &lt; text.length; i++) { j = s.indexOf(text[i]); result += j === -1 ? text[i] : t[j]; } return result;}/* 调用函数: button.onclick = translatePage() */function translatePage() { currentEncoding = targetEncoding; targetEncoding = !targetEncoding; localStorage.setItem(\"targetEncoding\", targetEncoding); translateBody();} 结束语欢迎转载本站文章，请注明作者和出处 simonaking.com。","categories":[{"name":"前端","slug":"前端","permalink":"https://simonaking.com/blog/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://simonaking.com/blog/tags/%E5%89%8D%E7%AB%AF/"},{"name":"博客","slug":"博客","permalink":"https://simonaking.com/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"神奇的位运算","date":"2018-01-25T08:32:02.000Z","path":"/magic-bit-operation/","text":"位运算在计算机领域的作用可谓举足轻重。 前言&nbsp;&nbsp;&nbsp;&nbsp;首先，我们要了解一个概念：程序中的所有数在计算机内存中都是以二进制的形式储存的。而位运算，就是直接对在内存中的二进制位进行操作，跳过了 程序转义成二进制的这一步骤，对编译时间有所提高，但带来的缺点也很明显，程序的可读性变低了。 &nbsp;&nbsp;&nbsp;&nbsp;掌握位运算 是一位程序员的基本素养，位运算在计算机领域的作用可谓举足轻重。 &nbsp;&nbsp;&nbsp;&nbsp;下面我将讲解 位运算的大体方法以及一些基本的应用。 正文and 运算 只有对应的两个 二进制数，均为 1，结果才为 1，否则为 0 &amp; 1判断 n 的第 m 位数。 介绍两个重要应用，来证明其含义： (n &gt;&gt;m ) &amp; 1 判断 整数 n 的二进制 第 m 位 是否 为 1 或者 为 0 n 的第 m 位数，如果为 1 ，1&amp;1 就返回 1 ，如果为 0，0&amp;1 就返回 0 判断 奇偶性 如果 n 为奇数，辗转相除 2，最后的余数 必定为 1，如果 n 为偶数，辗转相除 余数必定为 0 也就是说，n 为奇数，n&amp;1 等价于 1&amp;1 ，返回 1，n 为偶数，n&amp;1 等价于 0&amp;1，返回 0 &amp; 0将 n 的第 m 位数，重置为 0 基本应用：n &amp; ~(1 &lt;&lt; m) 1 &lt;&lt; m 定位到 n 的第 m 位数 ~(1 &lt;&lt; m) 将 1 进行非运算，变为 0，其他剩下的 m 位，变成 1，而 &amp;1，是无实际作用的 n &amp; 0 ：&amp; 按位与运算 只有对应的两个数 全部为 1 时，结果才为 1，而&amp;0，返回值一定为 0 or 运算 只有对应的两个 二进制数，均为 0，结果才为 0，否则为 1 | 1将 n 的第 m 位数，重置为 1 基本应用：n | (1 &lt;&lt; m): 1 &lt;&lt; m 定位到 n 的第 m 位数 n | 1 n 的第 m 位数 进行 |1 操作 其返回值必定为 1！ 因为|只有，两个数都为 0 时，结果才为 0 | 0无实际作用 一定要清楚， 是 n 的第 m 位数 在进行操作，其他 位数操作，根本无 影响 因为，其他位数，是 在进行 “| 0” 操作，而所谓的 |0 操作，与 &amp;1 操作，毫无差别。 假设 k=n 的第 m 位数，k = 1 ，k|0 = 1|0 = 1，k = 0，k|0 = 0|0 = 0，所谓 无实际作用。 但是要注意一点，我说的 0 是在二进制数中的 0，有实际含义的 0，不是补 0 的 0 所以，可以感性的认识到，| 0 与 &amp; 1 以及 下文的 ^ 0，都是无实际作用的 xor 运算 只有对应的两个 二进制数相等时，结果才为 0，否则为 1 ^ 1将 n 的第 m 位数，取反 基本应用：n ^ (1 &lt;&lt; m) 1 &lt;&lt; m ： 定位到 n 的第 m 位数 n ^ 1，我们要知道，^ (异或）：不相等为 1，相等为 0 而 ^1：如果 n 的第 m 位数 为 1，1^1 返回值为 0，如果 n 的第 m 位数 为 0，0^1 返回值 为 1 所以，^1 的重要作用，就是 与之相反的作用 ^ 0无实际作用 假定 整数 k 为 0，k^0 = 0^0 = 0 ; 假定整数 k 为 1，k^0 = 1^0 = 1 所以说，无论怎么变化，^0 都是无实际作用的 shl &amp; shr 运算 左移运算符 “&lt;&lt;” 表达式：a &lt;&lt; b a&lt;&lt;b 的值是：将 a 各二进位全部左移 b 位后得到的值。左移时，高位丢弃，低位补 0。 实际上，左移 1 位，就等于是乘以 2，左移 n 位，就等于是乘以 2n。 而左移操作比乘法操作快得多。例如:9 &lt;&lt; 49的二进制形式：0000 0000 0000 0000 0000 0000 0000 1001因此，表达式“9&lt;&lt;4”的值，就是将上面的二进制数左移4位，得：0000 0000 0000 0000 0000 0000 1001 0000即为十进制的144 , 而 9*2的4次幂 = 9*16 = 144. 右移运算符 “&gt;&gt;” 表达式：a &gt;&gt; b a&gt;&gt;b 的值是：将 a 各二进位全部右移 b 位后得到的值。右移时，移出最右边的位就被丢弃。 对于有符号数，如 long,int,short,char 类型变量，在右移时，符号位（即最高位）将一起移动，并且大多数 C/C++编译器规定，如果原符号位为 1，则右移时高位就补充 1，原符号位为 0，则右移时高位就补充 0。实际上，右移 n 位，就相当于左操作数除以2n，并且将结果往小里取整。例如：-25 &gt;&gt; 4 = -2 -2 &gt;&gt; 4 = -1 18 &gt;&gt; 4 = 1 应用对 2 的整数幂进行模运算#include &lt;stdio.h&gt;int main(){ int n,k; while(~scanf(\"%d %d\",&amp;n,&amp;k)){ n&lt;&lt;=k;//相当于 n 乘以 2 的 k 次幂，并将结果赋给 n n&gt;&gt;=k;//相当于 n 除以 2 的 k 次幂，并将结果赋给 n printf(\"%d\\n\",n); } return 0;} 两数交换#include &lt;stdio.h&gt;int main(){ int n,m; while(~scanf(\"%d %d\",&amp;n,&amp;m)){ n^=m; m^=n; n^=m; printf(\"%d %d\\n\",n,m); } return 0;} 按位异或 ^ : 不相同 为：1 ; 相同 为 ：0 将参与运算的两操作数各对应的二进制位进行异或操作， 即只有对应的两个二进位不相同时，结果的对应二进制位才是 1，否则为 0。 异或运算的特点是：如果 a^b=c，那么就有 c^b = a 以及 c^a=b 例如：表达式“21 ^ 18 ”的值是7(即二进制数111)。21： 1010118： 1001021^18: 00111假设 n = 5，m = 65的二进制为：1016的二进制为：110n^=m = 5^=6 = 101 ^ 110 = 011 ,此时 n 的二进制为：011m^=n = 6^=011 = 110 ^ 011 = 101 ,此时 m 的二进制为：101，也正是 5的二进制数，也就是说 m ==开始的 nn^=m = 011^=5 = 011 ^ 101 = 110 ,此时 n 的二进制位：110，也正是 6的二进制数，也就是说 n ==开始的 m 层次结构：A-&gt;B B-&gt;A A-&gt;B 正 反 正 判断 2 的正整数幂#include &lt;stdio.h&gt;int main(){ int n; while(~scanf(\"%d\",&amp;n)){ if(!(n &amp; (n-1)) &amp;&amp; n) printf(\"%d 为 2 的正整数幂\\n\",n); else printf(\"%d 不是 2 的正整数幂\\n\",n); } return 0;} 给定整数 n 判断 n 是否为 2 的正整数幂 表达式：(! (n &amp; (n-1)) &amp;&amp; n 举个例子： n = 16 = 10000，n-1 = 15 = 1111那么 ：10000 &amp; 01111 = 00000 = 0再举个例子： n = 256 = 10000000 ,n-1 = 255 = 11111111那么：100000000 &amp; 011111111 = 000000000 = 0 是的，如果一个数 n 是 2 的正整数幂，那么 n 的二进制必定为 1000…. n-1 的二进制必定为 1111…. 即： n &amp; n-1 = 0 所以 (! (n &amp; (n-1)) 为 1 ; &amp;&amp; n ：判断 n 为正数 判断奇偶性#include &lt;stdio.h&gt;int main(){ int n; while(~scanf(\"%d\",&amp;n)){ if(n&amp;1) printf(\"%d 是奇数\\n\",n); else printf(\"%d 是偶数\\n\",n); } return 0;} 记住：在做位运算时，位数不够的数，自动在 前面补 0 比如：21 &amp; 1 ：10101 &amp; 00001 = 00001 = 1 16 &amp; 1 ：10000 &amp; 00001 = 00000 = 0 事实证明：偶数的二进制的末尾 为 0，奇数的二进制的末尾 为 1 十进制 m 转换 n 进制方法： m 一直除 n，每相除一次，m 就等于商，直到商为 0，然后余数反排 即可。 1的二进制：1/2 =0 余1余数反排 即是 1的二进制：16的二进制：6/2 =3 余0 3/2 =1 余1 1/2 =0 余1余数反排 即是 6的二进制：11015的二进制：15/2=7 余1 7/2=3 余1 3/2=1 余1 1/2=0 余1余数反排 即是 15的二进制：11115的二进制：5/2 =2 余1 2/2 =1 余0 1/2 =0 余1余数反排 即是 5的二进制：10121的二进制：21/2 =10 余1 10/2 =5 余0 5/2 =2 余1 2/2 =1 余0 1/2 =0 余1余数反排 即是 21的二进制：10101 其他方面 (n &gt;&gt; m) &amp; 1 == (n &gt;&gt; m) | 0 == (n &gt;&gt; m) ^ 0 n &amp; ~(1 &lt;&lt; m) : 将 n 的第 m 位数，重置为 0 n | (1 &lt;&lt; m) : 将 n 的第 m 位数，重置为 1 n ^ (1 &lt;&lt; m) : 将 n 的第 m 位数，取其相反 结束语欢迎转载本站文章，请注明作者和出处 simonaking.com。","categories":[{"name":"后端","slug":"后端","permalink":"https://simonaking.com/blog/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"后端","slug":"后端","permalink":"https://simonaking.com/blog/tags/%E5%90%8E%E7%AB%AF/"},{"name":"位运算","slug":"位运算","permalink":"https://simonaking.com/blog/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"让你的 Capslock 键变废为宝","date":"2018-01-18T02:31:08.000Z","path":"/resurrect-your-capslock-key/","text":"很多时候我们是用不到 Capslock 键的。 Capslock 键的劣性&nbsp;&nbsp;&nbsp;&nbsp;如果你是 Windows 系统用户，就会发现，很多时候我们是用不到 Capslock 键的。Capslock 键是切换大小写的锁定，而在平常工作中，只要摁住 Shift 键一样可完成该功能。并且 在键盘的布局上来看 ，Capslock 键 的地理位置 非常便捷，这可不是我们想要的。 &nbsp;&nbsp;&nbsp;&nbsp;下文将告诉你 如何把 作用微小的 Capslock 键 变成你的得力助手。 修改前奏本文使用的修改键的脚本语言 是使用的 AutoHotKey ，一门超级强大的脚本语言。 点击AutoHotKey 官网下载链接下载 AutoHotKey 安装包 并安装。 新建文本文件，文件名格式为 文件名.ahk , 并用编辑器打开，建议 使用下载 AutoHotKey 插件后的 VSCode。 新建完成后的 ahk 文件，你可以双击运行， 或者 右键点击文件，然后单击 Compile Script 转换成 可执行文件再执行。 修改进行曲&nbsp;&nbsp;&nbsp;&nbsp;俗话说：“授人以鱼不如授人以渔”，所以，我先教你三个简单的例子，以便你能快速掌握 所需的 AHK 脚本知识。 模拟发送命令 AHK 文件 模拟键盘事件 AHK 文件 模拟光标行为 AHK 文件 一些 AHK 小常识其中还有一些必备的小知识 AHK 文件 修改成果 AHK 文件 源文件我调试了很长时间的 Capslock 快捷配置，希望能对你有所帮助。 点击显/隐源文件 ;管理员运行if not A_IsAdmin{ Run *RunAs \"%A_ScriptFullPath%\" ExitApp};无环境变量#NoEnv;高进程Process Priority,,High;一直关闭 CapslockSetCapsLockState, AlwaysOff; CapsLock -&gt; EscCapsLock::Send {Esc}return; CapsLock &amp; alt -&gt; EnterCapsLock &amp; alt::Send {Enter}return; CapsLock &amp; Space -&gt; ShiftCapsLock &amp; Space::Send {Shift Down}returnCapsLock &amp; Space up::Send {Shift up}return; 光标移动CapsLock &amp; j::MouseMove, -15, 0, 0, RreturnCapsLock &amp; k::MouseMove, 0, 15, 0, RreturnCapsLock &amp; i::MouseMove, 0, -15, 0, RreturnCapsLock &amp; l::MouseMove, 15, 0, 0, Rreturn; 左键单击CapsLock &amp; u::SendEvent {Blind}{LButton down}KeyWait EnterSendEvent {Blind}{LButton up}return; 右键单击CapsLock &amp; o::SendEvent {Blind}{RButton down}KeyWait EnterSendEvent {Blind}{RButton up}return; h 向上滚动CapsLock &amp; h::SendEvent {Blind}{WheelUp}return; 分号 向下滚动CapsLock &amp; `;::SendEvent {Blind}{WheelDown}returnCapsLock &amp; 3::SendEvent {Blind}{WheelUp}returnCapsLock &amp; 4::SendEvent {Blind}{WheelDown}returnCapsLock &amp; F5::Reloadreturn; 指针移动CapsLock &amp; e::Send {Up}returnCapsLock &amp; d::Send {Down}returnCapsLock &amp; s::Send {Left}returnCapsLock &amp; f::Send {right}return; 行首行尾CapsLock &amp; a::Send {home}returnCapsLock &amp; g::Send {end}return; 左右删除CapsLock &amp; w::Send {BS}returnCapsLock &amp; r::Send {Delete}return; 撤销重做CapsLock &amp; t::Send ^{z}return 结束语欢迎转载本站文章，请注明作者和出处 simonaking.com。","categories":[{"name":"开源","slug":"开源","permalink":"https://simonaking.com/blog/categories/%E5%BC%80%E6%BA%90/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://simonaking.com/blog/tags/%E5%B7%A5%E5%85%B7/"},{"name":"开源","slug":"开源","permalink":"https://simonaking.com/blog/tags/%E5%BC%80%E6%BA%90/"},{"name":"AHK","slug":"AHK","permalink":"https://simonaking.com/blog/tags/AHK/"}]},{"title":"学习 Less-看这篇就够了","date":"2017-12-08T02:52:11.000Z","path":"/learning-less-seeing-this-is-enough/","text":"Less 一门简单而又优雅的预处理语言。 前言CSS 的短板&nbsp;&nbsp;&nbsp;&nbsp;作为前端学习者的我们 或多或少都要学些 CSS ，它作为前端开发的三大基石之一，时刻引领着 Web 的发展潮向。 而 CSS 作为一门标记性语言，可能 给初学者第一印象 就是简单易懂，毫无逻辑，不像编程该有的样子。在语法更新时，每当新属性提出，浏览器的兼容又会马上变成绊脚石，可以说 CSS 短板不容忽视。 &nbsp;&nbsp;&nbsp;&nbsp;问题的诞生往往伴随着技术的兴起， 在 Web 发展的这几年， 为了让 CSS 富有逻辑性，短板不那么严重，涌现出了 一些神奇的预处理语言。 它们让 CSS 彻底变成一门 可以使用 变量 、循环 、继承 、自定义方法等多种特性的标记语言，逻辑性得以大大增强。 预处理语言的诞生其中 就我所知的有三门语言：Sass、Less 、Stylus 。 Sass 诞生于 2007 年，Ruby 编写，其语法功能都十分全面，可以说 它完全把 CSS 变成了一门编程语言。另外 在国内外都很受欢迎，并且它的项目团队很是强大 ，是一款十分优秀的预处理语言。 Stylus 诞生于 2010 年，来自 Node.js 社区，语法功能也和 Sass 不相伯仲，是一门十分独特的创新型语言。 Less 诞生于 2009 年，受 Sass 的影响创建的一个开源项目。 它扩充了 CSS 语言，增加了诸如变量、混合（mixin）、函数等功能，让 CSS 更易维护、方便制作主题、扩充（引用于官网）。 选择预处理语言这是一个十分纠结的问题。 在网上讨论看来，Sass 与 Stylus 相比于 Less 功能更为丰富，但对于学习成本以及适应时间 ，Less 稍胜一筹，这也是我选择 Less 的原因。 Less 没有去掉任何 CSS 的功能，而是在现有的语法上，增添了许多额外的功能特性，所以学习 Less 是一件非常舒服的事情。 如果你之前没有接触过预处理语言，纠结应该学哪一个，不如先看看 下面 Less 的介绍，我相信你会爱上它的。 使用 Less 的前奏使用 Less 有两种方式 在页面中 引入 Less.js 可在官网下载 或使用 CDN&lt;script src=\"//cdnjs.cloudflare.com/ajax/libs/less.js/2.7.2/less.min.js\"&gt;&lt;/script&gt; 需要注意的是，link 标签一定要在 Less.js 之前引入，并且 link 标签的 rel 属性要设置为 stylesheet/less。&lt;link rel=\"stylesheet/less\" href=\"style.less\"&gt;&lt;script src=\"less.min.js\"&gt;&lt;/script&gt; 在命令行 使用 npm 安装 npm install -g less 具体使用命令 $ lessc styles.less &gt; styles.css 假如还有问题，官网已经有了明确的步骤。 如果你也是 Webpack 的使用者，还需要配合 less-loader 进行处理，具体可见我的这篇文章：Webpack 飞行手册，里面详细说明了 less 的处理方式。 如果你在本地环境，可以使用第一种方式，非常简单；但在生产环境中，性能非常重要，最好使用第二种方式。 正文下面我将简介 Less 的功能特性。 变量我们常常在 CSS 中 看到同一个值重复多次，这样难易于代码维护。 理想状态，应是下面这样： const bgColor=\"skyblue\";$(\".post-content\").css(\"background-color\",bgColor);$(\"#wrap\").css(\"background-color\",bgColor);$(\".arctive\").css(\"background-color\",bgColor); 只要我们修改 bgColor这一个变量， 整个页面的背景颜色都会随之改变。 而 Less 中的变量十分强大，可化万物，值得一提的是，其变量是常量 ，所以只能定义一次，不能重复使用。 值变量 /* Less */@color: #999;@bgColor: skyblue;//不要添加引号@width: 50%;#wrap { color: @color; background: @bgColor; width: @width;}/* 生成后的 CSS */#wrap { color: #999; background: skyblue; width: 50%;} 以 @ 开头 定义变量，并且使用时 直接 键入 @名称。 在平时工作中，我们就可以把 常用的变量 封装到一个文件中，这样利于代码组织维护。 @lightPrimaryColor: #c5cae9;@textPrimaryColor: #fff;@accentColor: rgb(99, 137, 185);@primaryTextColor: #646464;@secondaryTextColor: #000;@dividerColor: #b6b6b6;@borderColor: #dadada; 选择器变量 让 选择器 变成 动态 /* Less */@mySelector: #wrap;@Wrap: wrap;@{mySelector}{ //变量名 必须使用大括号包裹 color: #999; width: 50%;}.@{Wrap}{ color:#ccc;}#@{Wrap}{ color:#666;}/* 生成的 CSS */#wrap{ color: #999; width: 50%;}.wrap{ color:#ccc;}#wrap{ color:#666;} 属性变量 可减少代码书写量 /* Less */@borderStyle: border-style;@Soild:solid;#wrap{ @{borderStyle}: @Soild;//变量名 必须使用大括号包裹}/* 生成的 CSS */#wrap{ border-style:solid;} url 变量 项目结构改变时，修改其变量即可。 /* Less */@images: \"../img\";//需要加引号body { background: url(\"@{images}/dog.png\");//变量名 必须使用大括号包裹}/* 生成的 CSS */body { background: url(\"../img/dog.png\");} 声明变量 有点类似于 下面的 混合方法 结构: @name: { 属性: 值 ;}; 使用：@name(); /* Less */@background: {background:red;};#main{ @background();}@Rules:{ width: 200px; height: 200px; border: solid 1px red;};#con{ @Rules();}/* 生成的 CSS */#main{ background:red;}#con{ width: 200px; height: 200px; border: solid 1px red;} 变量运算 不得不提的是，Less 的变量运算完全超出我的期望，十分强大。 加减法时 以第一个数据的单位为基准 乘除法时 注意单位一定要统一 /* Less */@width:300px;@color:#222;#wrap{ width:@width-20; height:@width-20*5; margin:(@width-20)*5; color:@color*2; background-color:@color + #111;}/* 生成的 CSS */#wrap{ width:280px; height:200px; margin:1400px; color:#444; background-color:#333;} 变量作用域 一句话理解就是：就近原则，不要跟我提闭包。 借助官网的 Demo /* Less */@var: @a;@a: 100%;#wrap { width: @var; @a: 9%;}/* 生成的 CSS */#wrap { width: 9%;} 用变量去定义变量 /* Less */@fnord: \"I am fnord.\";@var: \"fnord\";#wrap::after{ content: @@var; //将@var 替换为其值 content:@fnord;}/* 生成的 CSS */#wrap::after{ content: \"I am fnord.\";} 嵌套 &amp; 的妙用 &amp; ：代表的上一层选择器的名字，此例便是header。 /* Less */#header{ &amp;:after{ content:\"Less is more!\"; } .title{ font-weight:bold; } &amp;_content{//理解方式：直接把 &amp; 替换成 #header margin:20px; }}/* 生成的 CSS */#header::after{ content:\"Less is more!\";}#header .title{ //嵌套了 font-weight:bold;}#header_content{//没有嵌套！ margin:20px;} 媒体查询 在以往的工作中，我们使用 媒体查询，都要把一个元素 分开写 #wrap{ width:500px;}@media screen and (max-width:768px){ #wrap{ width:100px; }} Less 提供了一个十分便捷的方式 /* Less */#main{ //something... @media screen{ @media (max-width:768px){ width:100px; } } @media tv { width:2000px; }}/* 生成的 CSS */@media screen and (maxwidth:768px){ #main{ width:100px; }}@media tv{ #main{ width:2000px; }} 唯一的缺点就是 每一个元素都会编译出自己 @media 声明，并不会合并。 实战技巧 可以借助 Less 在元素中，去定义自己的私有样式。 /* Less */#main{ // something.. &amp;.show{ display:block; }}.show{ display:none;} const main = document.getElementById(\"main\");main.classList.add(\"show\"); 结果： #main.show{ display:block;}.show{ display:none; //会被覆盖。} 混合方法 无参数方法 方法犹如 声明的集合，使用时 直接键入名称即可。 /* Less */.card { // 等价于 .card() background: #f6f6f6; box-shadow: 0 1px 2px rgba(151, 151, 151, .58);}#wrap{ .card;//等价于.card();}/* 生成的 CSS */#wrap{ background: #f6f6f6; box-shadow: 0 1px 2px rgba(151, 151, 151, .58);} 其中 .card 与 .card() 是等价的。 个人建议，为了避免 代码混淆，应写成 : .card(){ //something...}#wrap{ .card();} 要点： . 与 # 皆可作为 方法前缀。 方法后写不写 () 看个人习惯。 默认参数方法 Less 可以使用默认参数，如果 没有传参数，那么将使用默认参数。 @arguments 犹如 JS 中的 arguments 指代的是 全部参数。 传的参数中 必须带着单位。 /* Less */.border(@a:10px,@b:50px,@c:30px,@color:#000){ border:solid 1px @color; box-shadow: @arguments;//指代的是 全部参数}#main{ .border(0px,5px,30px,red);//必须带着单位}#wrap{ .border(0px);}#content{ .border;//等价于 .border()}/* 生成的 CSS */#main{ border:solid 1px red; box-shadow:0px,5px,30px,red;}#wrap{ border:solid 1px #000; box-shadow: 0px 50px 30px #000;}#content{ border:solid 1px #000; box-shadow: 10px 50px 30px #000;} 方法的匹配模式 与 面向对象中的多态 很相似 /* Less */.triangle(top,@width:20px,@color:#000){ border-color:transparent transparent @color transparent ;}.triangle(right,@width:20px,@color:#000){ border-color:transparent @color transparent transparent ;}.triangle(bottom,@width:20px,@color:#000){ border-color:@color transparent transparent transparent ;}.triangle(left,@width:20px,@color:#000){ border-color:transparent transparent transparent @color;}.triangle(@_,@width:20px,@color:#000){ border-style: solid; border-width: @width;}#main{ .triangle(left, 50px, #999)}/* 生成的 CSS */#main{ border-color:transparent transparent transparent #999; border-style: solid; border-width: 50px;} 要点 第一个参数 left 要会找到方法中匹配程度最高的，如果匹配程度相同，将全部选择，并存在着样式覆盖替换。 如果匹配的参数 是变量，则将会匹配，如 @_ 。 方法的命名空间 让方法更加规范 /* Less */#card(){ background: #723232; .d(@w:300px){ width: @w; #a(@h:300px){ height: @h;//可以使用上一层传进来的方法 } }}#wrap{ #card &gt; .d &gt; #a(100px); // 父元素不能加 括号}#main{ #card .d();}#con{ //不得单独使用命名空间的方法 //.d() 如果前面没有引入命名空间 #card ，将会报错 #card; // 等价于 #card(); .d(20px); //必须先引入 #card}/* 生成的 CSS */#wrap{ height:100px;}#main{ width:300px;}#con{ width:20px;} 要点 在 CSS 中&gt; 选择器，选择的是 儿子元素，就是 必须与父元素 有直接血源的元素。 在引入命令空间时，如使用 &gt; 选择器，父元素不能加 括号。 不得单独使用命名空间的方法 必须先引入命名空间，才能使用 其中方法。 子方法 可以使用上一层传进来的方法 方法的条件筛选 Less 没有 if else，可是它有 when /* Less */#card{ // and 运算符 ，相当于 与运算 &amp;&amp;，必须条件全部符合才会执行 .border(@width,@color,@style) when (@width&gt;100px) and(@color=#999){ border:@style @color @width; } // not 运算符，相当于 非运算 !，条件为 不符合才会执行 .background(@color) when not (@color&gt;=#222){ background:@color; } // , 逗号分隔符：相当于 或运算 ||，只要有一个符合条件就会执行 .font(@size:20px) when (@size&gt;50px) , (@size&lt;100px){ font-size: @size; }}#main{ #card&gt;.border(200px,#999,solid); #card .background(#111); #card &gt; .font(40px);}/* 生成后的 CSS */#main{ border:solid #999 200px; background:#111; font-size:40px;} 要点 比较运算有： &gt; &gt;= = =&lt; &lt;。 = 代表的是等于 除去关键字 true 以外的值都被视为 false： 数量不定的参数 如果你希望你的方法接受数量不定的参数，你可以使用… ，犹如 ES6 的扩展运算符。 /* Less */.boxShadow(...){ box-shadow: @arguments;}.textShadow(@a,...){ text-shadow: @arguments;}#main{ .boxShadow(1px,4px,30px,red); .textShadow(1px,4px,30px,red);}/* 生成后的 CSS */#main{ box-shadow: 1px 4px 30px red; text-shadow: 1px 4px 30px red;} 方法使用 important！ 使用方法 非常简单，在方法名后 加上关键字即可。 /* Less */.border{ border: solid 1px red; margin: 50px;}#main{ .border() !important;}/* 生成后的 CSS */#main { border: solid 1px red !important; margin: 50px !important;} 循环方法 Less 并没有提供 for 循环功能，但这也难不倒 聪明的程序员，使用递归去实现。 下面是官网中的一个 Demo，模拟了生成栅格系统。 /* Less */.generate-columns(4);.generate-columns(@n, @i: 1) when (@i =&lt; @n) { .column-@{i} { width: (@i * 100% / @n); } .generate-columns(@n, (@i + 1));}/* 生成后的 CSS */.column-1 { width: 25%;}.column-2 { width: 50%;}.column-3 { width: 75%;}.column-4 { width: 100%;} 属性拼接方法 +_ 代表的是 空格；+ 代表的是 逗号。 逗号/* Less */.boxShadow() { box-shadow+: inset 0 0 10px #555;}.main { .boxShadow(); box-shadow+: 0 0 20px black;}/* 生成后的 CSS */.main { box-shadow: inset 0 0 10px #555, 0 0 20px black;} 空格/* Less */.Animation() { transform+_: scale(2);}.main { .Animation(); transform+_: rotate(15deg);}/* 生成的 CSS */.main { transform: scale(2) rotate(15deg);} 实战技巧 下面是官网中的一个非常赞的 Demo /* Less */.average(@x, @y) { @average: ((@x + @y) / 2);}div { .average(16px, 50px); // 调用 方法 padding: @average; // 使用返回值}/* 生成的 CSS */div { padding: 33px;} 可以说 Less 是一门优雅编程语言。 继承extend 是 Less 的一个伪类。它可继承 所匹配声明中的全部样式。 extend 关键字的使用 /* Less */.animation{ transition: all .3s ease-out; .hide{ transform:scale(0); }}#main{ &amp;:extend(.animation);}#con{ &amp;:extend(.animation .hide);}/* 生成后的 CSS */.animation,#main{ transition: all .3s ease-out;}.animation .hide , #con{ transform:scale(0);} all 全局搜索替换 使用选择器匹配到的 全部声明。 /* Less */#main{ width: 200px;}#main { &amp;:after { content:\"Less is good!\"; }}#wrap:extend(#main all) {}/* 生成的 CSS */#main,#wrap{ width: 200px;}#main:after, #wrap:after { content: \"Less is good!\";} 减少代码的重复性 从表面 看来，extend 与 方法 最大的差别，就是 extend 是同个选择器共用同一个声明，而 方法 是使用自己的声明，这无疑 增加了代码的重复性。 方法示例 与上面的 extend 进行对比： /* Less */.Method{ width: 200px; &amp;:after { content:\"Less is good!\"; }}#main{ .Method;}#wrap{ .Method;}/* 生成的 CSS */#main{ width: 200px; &amp;:after{ content:\"Less is good!\"; }}#wrap{ width: 200px; &amp;:after{ content:\"Less is good!\"; }} 要点 翻译官网 选择器和扩展之间 是允许有空格的：pre:hover :extend(div pre). 可以有多个扩展: pre:hover:extend(div pre):extend(.bucket tr) - 注意这与 pre:hover:extend(div pre, .bucket tr)一样。 这是不可以的，扩展必须在最后 : pre:hover:extend(div pre).nth-child(odd)。 如果一个规则集包含多个选择器，所有选择器都可以使用 extend 关键字。 导入 导入 less 文件 可省略后缀 import \"main\";//等价于import \"main.less\"; @import 的位置可随意放置 #main{ font-size:15px;}@import \"style\"; reference Less 中 最强大的特性 使用 引入的 Less 文件，但不会 编译它。 /* Less */@import (reference) \"bootstrap.less\";#wrap:extend(.navbar all){} 翻译官网： 使用@import (reference)导入外部文件，但不会添加 把导入的文件 编译到最终输出中，只引用。 once @import 语句的默认行为。这表明相同的文件只会被导入一次，而随后的导入文件的重复代码都不会解析。 @import (once) \"foo.less\";@import (once) \"foo.less\"; // this statement will be ignored multiple 使用@import (multiple)允许导入多个同名文件。 /* Less */// file: foo.less.a { color: green;}// file: main.less@import (multiple) \"foo.less\";@import (multiple) \"foo.less\";/* 生成后的 CSS */.a { color: green;}.a { color: green;} 函数 判断类型 isnumber 判断给定的值 是否 是一个数字。 isnumber(#ff0); // falseisnumber(blue); // falseisnumber(\"string\"); // falseisnumber(1234); // trueisnumber(56px); // trueisnumber(7.8%); // trueisnumber(keyword); // falseisnumber(url(...)); // false iscolor 判断给定的值 是否 是一个颜色。 isurl 判断给定的值 是否 是一个 url 。 颜色操作 saturate 增加一定数值的颜色饱和度。 lighten 增加一定数值的颜色亮度。 darken 降低一定数值的颜色亮度。 fade 给颜色设定一定数值的透明度。 mix 根据比例混合两种颜色。 数学函数 ceil 向上取整。 floor 向下取整。 percentage 将浮点数转换为百分比字符串。 round 四舍五入。 sqrt 计算一个数的平方根。 abs 计算数字的绝对值，原样保持单位。 pow 计算一个数的乘方。 由于 文章 篇幅有限，所以 只能介绍一些 使用效率高的函数。 如果你想了解更多，可以去官网的函数链接 其他 注释 /* */ CSS 原生注释，会被编译在 CSS 文件中。 /&nbsp;&nbsp;&nbsp;/ Less 提供的一种注释，不会被编译在 CSS 文件中。 避免编译 /* Less */#main{ width:~'calc(300px-30px)';}/* 生成后的 CSS */#main{ width:calc(300px-30px);} 结构： ~' 值 ' 变量拼串 在平时工作中，这种需求 太常见了。 在下面例子中， 实现了不同的 transtion-delay、animation、@keyframes .judge(@i) when(@i=1){ @size:15px;}.judge(@i) when(@i&gt;1){ @size:16px;}.loopAnimation(@i) when (@i&lt;16) { .circle:nth-child(@{i}){ .judeg(@i); border-radius:@size @size 0 0; animation: ~\"circle-@{i}\" @duration infinite @ease; transition-delay:~\"@{i}ms\"; } @keyframes ~\"circle-@{i}\" { // do something... } .loopAnimation(@i + 1);} 结构： ~\"字符@{变量}字符\"; 使用 JS 因为 Less 是由 JS 编写，所以 Less 有一得天独厚的特性：代码中使用 Javascript 。 /* Less */@content:`\"aaa\".toUpperCase()`;#randomColor{ @randomColor: ~\"rgb(`Math.round(Math.random() * 256)`,`Math.round(Math.random() * 256)`,`Math.round(Math.random() * 256)`)\";}#wrap{ width: ~\"`Math.round(Math.random() * 100)`px\"; &amp;:after{ content:@content; } height: ~\"`window.innerHeight`px\"; alert:~\"`alert(1)`\"; #randomColor(); background-color: @randomColor;}/* 生成后的 CSS */// 弹出 1#wrap{ width: 随机值（0~100）px; height: 743px;//由电脑而异 background: 随机颜色;}#wrap::after{ content:\"AAA\";} &nbsp;&nbsp;&nbsp;&nbsp;前几个月 ， 有个 CSS in JS 的概念非常火，现在 看来 JS in CSS 也未曾不可。我觉得完全可以根据 Less 这个特性来造个轮子，JS 来控制 CSS ，形成 动态属性，如果成功 很可能会改变 现在前端的打开姿势。 &nbsp;&nbsp;&nbsp;&nbsp;从我学习 Web 以来，无数前辈告诉我，Web 有三大基石，JS 控制行为，HTML 控制结构，CSS 控制样式。我一直再想 为什么要分为 3 个语言？为什么不能合成一个语言？或者说 就没有更合适的吗？在这几年的 Web 发展中，页面从 MVC 到 现在的 MVVC，结构正在发生着改变，但 其根本 不过是造了一个又一个 完美的轮子。我们为什么就不能打破传统呢？让 前端的 三大基石 变成一座大山呢？ &nbsp;&nbsp;&nbsp;&nbsp;请试想一下，那该是个怎样的世界。 结束语以上便是 Less 的特性总结，希望本文能对你有所帮助。 欢迎转载本站文章，请注明作者和出处 simonaking.com。 .post-content ol li > p:nth-child(1){font-weight:bold;color:#555;text-shadow: rgb(207, 207, 207) 0 0 1px;}","categories":[{"name":"前端","slug":"前端","permalink":"https://simonaking.com/blog/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://simonaking.com/blog/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Less","slug":"Less","permalink":"https://simonaking.com/blog/tags/Less/"}]},{"title":"VSCode 之高效快捷键","date":"2017-12-05T08:40:11.000Z","path":"/vscode-efficient-shortcuts/","text":"绝对福利,不容错过！ 前言常言道：“工欲善其事必先利其器”，而我的器便是 VSCode ，这是一款高颜值的编辑器。 不过在经过长时间的使用后，发现总有些一些快捷键令我难以接受。 遂花了一天的时间，将快捷键全部调整了一遍，总结如下： 😶 底部有源文件,可供你替换 正文编辑 Alt + Enter 跳转到下一个编辑点 Ctrl + A 全选 Ctrl + Shift + A Autoprefixer/Eslint Ctrl + Shift + Z 重做 Ctrl + R 注释当前行 Ctrl + T 格式化 Ctrl + Y 选择下一个匹配 Ctrl + Shift + Y 选择所有匹配项 Ctrl + / 增加注释 Ctrl + J 连接下一行 Ctrl + Shift + J 将标签内的内容全部缩成一行 Ctrl + P 交换字符位置 Ctrl + G 浏览 markdown 开启 LiveServer Alt + G 关闭 LiveServer Alt + . Emmet 命令列表 Alt + z 自动换行 Ctrl + L 选中一行 Ctrl + Shift + L 跳转行 Ctrl + D 删除行 Ctrl + F 搜索 Ctrl + H 替换 Ctrl + Shift + C 向下复制一行 Ctrl + Shift + V 打开 Ditto Ctrl + Enter 在当前行下边插入一行 Shift + Enter 在当前行上方插入一行 Alt + Up/Down 移动行 Ctrl + Shift + [] 折叠代码 Alt + X 光标撤销 Ctrl + F5 Code Run Ctrl + Shift + Space 显示参数 Ctrl + 左键 多处编辑 Ctrl + Shift + 左键 块选择 Alt + Shift + Right 选中标签内中的内容 Alt + Shift + Left 选中标签中的第一个子标签 Alt + Left 移除包裹标签 Alt + Right 键入标签名 包围所在标签 与 多光标一起使用 威力无穷 Alt + Shift +Enter 将当前标签替换成键入的标签 Ctrl + Shift + J 将标签内的内容全部缩成一行 Alt + Enter 跳转到下一个编辑点 F12 移动到定义处 Alt + F12 定义处缩略图,可更改 Shift + F12 列出所有的引用 Ctrl + Alt + Up 定位到文件中上一个修改 Ctrl + Alt + Down 定位到文件中下一个修改 命令窗口 F1 Ctrl + Shift + P Ctrl + E 输入 &gt; Ctrl + P 输入 &gt; 其中在 Ctrl + E / P 窗口中还可以这么玩 : 直接输入文件名，跳转到文件 ? 列出当前可执行的动作 ! 显示 Errors 或 Warnings，也可以 Ctrl+Shift+M : 跳转到行数 @ 跳转到 symbol（搜索变量或者函数），也可以 Ctrl+Shift+O 直接进入 @ 根据分类跳转 symbol，查找属性或函数，也可以 Ctrl+Shift+O 后输入:进入 # 根据名字查找 symbol 项目 Ctrl + O 打开文件 Ctrl + Shift + O 打开文件夹 Ctrl + Alt + O 打开本地 Git 项目 Ctrl + B 打开最近项目 Alt + R (需先 Ctrl + Shift + E) 打开聚焦文件的路径 标签 Ctrl + Shift + T 打开关闭后的标签 Ctrl + Num 聚焦到某个标签 Ctrl + W 关闭当前标签 调试 F5 调试 Shift + F5 运行 不调试 F10 单步执行 注意事项 先关掉所有的 Chrome 启动调试 Launch to Chrome 可以使用断点，单独调试 还可以像 Chrome 调试台那样 去使用调试$(\"#header\").style.background获取 header 的背景颜色$document.querySelector 。$$相当于 document.querySelectorAll 。$_返回上一个表达式的值dirconsole.dirkeys取对象的键名, 返回键名组成的数组values(object)返回一个数组，该数组包含属于指定对象的所有属性值。dirxml(object)$(\"#header\").css(\"color\",\"red\");使用页面中的框架,记录 jQuery1 + 2普通输入function(){alert(1);}函数 设置 Ctrl + , 设置 Ctrl + Shift + , 快捷键 Ctrl + Alt + , 代码片段 Alt + F2 选择主题 Alt + F1 改变语言 Ctrl + Shift + S 设置 窗口 Ctrl + M 打开新窗口 Ctrl + Shift +M 重新载入 Ctrl + \\ 多栏编辑 Ctrl + Shift + \\ 切换多栏布局 Alt + W 只保留当前栏 Alt + A 当前栏增大视图 Alt + Num 聚焦到第 Num 个栏 Booksmarks Ctrl + Q 切换书签 Ctrl + Shift + Q 跳转到下一个书签 Ctrl + Alt + Q 跳转到上一个书签 Ctrl + Shift + Alt + Q 书签列表 F1 + Clear remove all bookmarks in the current file 清除当前文件的所有标签 F1 + Clear from All Files remove all bookmarks from all files 清除所有标签 文件 Ctrl + S 保存当前文件 Ctrl + Shift +S 保存所有文件 Ctrl + Alt + S 另存为 Ctrl + Shift + N 在资源管理器中新建文件 侧边栏 Ctrl + Shift + E 聚焦到资源管理器 Ctrl + Shift + F 全局搜索 Ctrl + Shift + D 调试代码 Ctrl + Shift + G Git 版本库 Ctrl + Shift + X 插件商场 Ctrl + Shift + B 切换侧边栏 Ctrl + Shift + H 全局替换 底栏 Ctrl + Shift + W 问题 F8 下一个错误/警告 Shift + F8 上一个错误/警告 Ctrl + Shift + R 调试控制台 Ctrl + Shift + U 输出 Alt + Q 终端 Markdown Alt + B 粗体 Ctrl + i 斜体 Ctrl + Shift + [/] 增加标题等级 Ctrl + G 浏览视图 右键 Markdown 视图 保存多种类型 其他特性 悬停提示 文件拖拽移动 双击变量 高亮匹配相同词 code ./ 使用 VSCode 打开当前文件 F11 全屏 文件右键 在资源管理器中打开 在终端打开 选择以比较 然后在选择一个文件 即可进行比较 复制路径 Alt + Shift+C Git 查看该文件的历史 Git F1 View Git History (git log) (git.viewHistory) View File History (git.viewFileHistory) View Line History (git.viewLineHistory) Alt + F3 查看文件更改 NPM &amp;&amp; Task Ctrl + I 导入模块 Alt + F5 运行脚本 Ctrl+u 运行任务 源文件点击显/隐源文件 [{ \"key\": \"tab\", \"command\": \"editor.emmet.action.expandAbbreviation\", \"when\": \"config.emmet.triggerExpansionOnTab &amp;&amp; editorTextFocus &amp;&amp; !editorHasMultipleSelections &amp;&amp; !editorHasSelection &amp;&amp; !editorReadonly &amp;&amp; !editorTabMovesFocus\" }, { \"key\": \"ctrl+c\", \"command\": \"-extension.vim_ctrl+c\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.overrideCtrlC &amp;&amp; vim.use&lt;C-c&gt; &amp;&amp; !inDebugRepl\" }, { \"key\": \"ctrl+f\", \"command\": \"-extension.vim_ctrl+f\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-f&gt; &amp;&amp; !inDebugRepl\" }, { \"key\": \"ctrl+l\", \"command\": \"expandLineSelection\", \"when\": \"editorTextFocus\" },{ \"key\": \"ctrl+h\", \"command\": \"-extension.vim_ctrl+h\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-h&gt; &amp;&amp; !inDebugRepl &amp;&amp; vim.mode == 'Insert'\" }, { \"key\": \"ctrl+v\", \"command\": \"-extension.vim_ctrl+v\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-v&gt; &amp;&amp; !inDebugRepl &amp;&amp; vim.mode != 'Insert'\" }, { \"key\": \"ctrl+f1\", \"command\": \"-extension.viewInBrowser\", \"when\": \"editorTextFocus\" }, { \"key\": \"alt+x\", \"command\": \"cursorUndo\", \"when\": \"editorTextFocus\" },{ \"key\": \"shift+alt+f\", \"command\": \"-editor.action.formatDocument\", \"when\": \"editorHasDocumentFormattingProvider &amp;&amp; editorTextFocus &amp;&amp; !editorReadonly\" }, { \"key\": \"ctrl+f\", \"command\": \"actions.find\" }, { \"key\": \"ctrl+f\", \"command\": \"-actions.find\" }, { \"key\": \"ctrl+shift+f\", \"command\": \"workbench.action.findInFiles\", \"when\": \"!searchInputBoxFocus\" }, { \"key\": \"ctrl+shift+f\", \"command\": \"-workbench.action.findInFiles\", \"when\": \"!searchInputBoxFocus\" }, { \"key\": \"ctrl+shift+f\", \"command\": \"workbench.view.search\", \"when\": \"!searchViewletVisible\" }, { \"key\": \"ctrl+shift+f\", \"command\": \"-workbench.view.search\", \"when\": \"!searchViewletVisible\" }, { \"key\": \"ctrl+r\", \"command\": \"editor.action.commentLine\", \"when\": \"editorTextFocus &amp;&amp; !editorReadonly\" }, { \"key\": \"ctrl+oem_2\", \"command\": \"-editor.action.commentLine\", \"when\": \"editorTextFocus &amp;&amp; !editorReadonly\" }, { \"key\": \"ctrl+d\", \"command\": \"editor.action.deleteLines\", \"when\": \"editorTextFocus &amp;&amp; !editorReadonly\" }, { \"key\": \"ctrl+shift+k\", \"command\": \"-editor.action.deleteLines\", \"when\": \"editorTextFocus &amp;&amp; !editorReadonly\" }, { \"key\": \"ctrl+alt+o\", \"command\": \"-extension.openWith\", \"when\": \"editorTextFocus &amp;&amp; editorLangId == 'html'\" }, { \"key\": \"alt+f1\", \"command\": \"workbench.action.editor.changeLanguageMode\" }, { \"key\": \"ctrl+k m\", \"command\": \"-workbench.action.editor.changeLanguageMode\" }, { \"key\": \"shift+enter\", \"command\": \"editor.action.insertLineBefore\", \"when\": \"editorTextFocus &amp;&amp; !editorReadonly\" }, { \"key\": \"ctrl+shift+enter\", \"command\": \"-editor.action.insertLineBefore\", \"when\": \"editorTextFocus &amp;&amp; !editorReadonly\" }, { \"key\": \"ctrl+shift+g\", \"command\": \"workbench.view.scm\" }, { \"key\": \"ctrl+shift+g\", \"command\": \"-workbench.view.scm\" }, { \"key\": \"alt+shift+g\", \"command\": \"markdown.showPreview\", \"when\": \"editorLangId == 'markdown'\" }, { \"key\": \"ctrl+shift+v\", \"command\": \"-markdown.showPreview\", \"when\": \"editorLangId == 'markdown'\" }, { \"key\": \"ctrl+shift+c\", \"command\": \"editor.action.copyLinesDownAction\", \"when\": \"editorTextFocus &amp;&amp; !editorReadonly\" }, { \"key\": \"shift+alt+down\", \"command\": \"-editor.action.copyLinesDownAction\", \"when\": \"editorTextFocus &amp;&amp; !editorReadonly\" }, { \"key\": \"alt+r\", \"command\": \"revealFileInOS\", \"when\": \"explorerViewletFocus &amp;&amp; explorerViewletVisible\" }, { \"key\": \"shift+alt+r\", \"command\": \"-revealFileInOS\", \"when\": \"explorerViewletFocus &amp;&amp; explorerViewletVisible\" }, { \"key\": \"ctrl+a\", \"command\": \"-extension.vim_ctrl+a\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-a&gt; &amp;&amp; !inDebugRepl\" }, { \"key\": \"ctrl+g\", \"command\": \"extension.liveServer.goOnline\", \"when\": \"editorTextFocus &amp;&amp; editorLangId != 'markdown'\" }, { \"key\": \"alt+g\", \"command\": \"extension.liveServer.goOffline\", \"when\": \"editorTextFocus &amp;&amp; editorLangId != 'markdown'\" }, { \"key\": \"alt+l o\", \"command\": \"-extension.liveServer.goOnline\", \"when\": \"editorTextFocus\" }, { \"key\": \"alt+l c\", \"command\": \"-extension.liveServer.goOffline\", \"when\": \"editorTextFocus\" }, { \"key\": \"ctrl+q\", \"command\": \"bookmarks.toggle\", \"when\": \"editorTextFocus\" }, { \"key\": \"ctrl+alt+k\", \"command\": \"-bookmarks.toggle\", \"when\": \"editorTextFocus\" }, { \"key\": \"ctrl+shift+q\", \"command\": \"bookmarks.jumpToNext\", \"when\": \"editorTextFocus\" }, { \"key\": \"ctrl+alt+l\", \"command\": \"-bookmarks.jumpToNext\", \"when\": \"editorTextFocus\" }, { \"key\": \"ctrl+alt+q\", \"command\": \"bookmarks.jumpToPrevious\", \"when\": \"editorTextFocus\" }, { \"key\": \"ctrl+alt+j\", \"command\": \"-bookmarks.jumpToPrevious\", \"when\": \"editorTextFocus\" }, { \"key\": \"ctrl+shift+alt+q\", \"command\": \"bookmarks.listFromAllFiles\" }, { \"key\": \"ctrl+n\", \"command\": \"-extension.vim_ctrl+n\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-n&gt; &amp;&amp; !inDebugRepl\" }, { \"key\": \"ctrl+shift+n\", \"command\": \"explorer.newFile\", }, { \"key\": \"ctrl+n\", \"command\": \"workbench.action.files.newUntitledFile\" , },{ \"key\": \"ctrl+w\", \"command\": \"-extension.vim_ctrl+w\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-w&gt; &amp;&amp; !inDebugRepl\"},{ \"key\": \"ctrl+w ctrl+w\", \"command\": \"-extension.vim_navigateGroups\", \"when\": \"vim.active &amp;&amp; vim.use&lt;C-w&gt; &amp;&amp; !editorTextFocus\"},{ \"key\": \"ctrl+w l\", \"command\": \"-extension.vim_navigateRight\", \"when\": \"vim.active &amp;&amp; vim.use&lt;C-w&gt; &amp;&amp; !editorTextFocus\"},{ \"key\": \"ctrl+w j\", \"command\": \"-extension.vim_navigateDown\", \"when\": \"vim.active &amp;&amp; vim.use&lt;C-w&gt; &amp;&amp; !editorTextFocus\"},{ \"key\": \"ctrl+w k\", \"command\": \"-extension.vim_navigateUp\", \"when\": \"vim.active &amp;&amp; vim.use&lt;C-w&gt; &amp;&amp; !editorTextFocus\"},{ \"key\": \"ctrl+w h\", \"command\": \"-extension.vim_navigateLeft\", \"when\": \"vim.active &amp;&amp; vim.use&lt;C-w&gt; &amp;&amp; !editorTextFocus\"},{ \"key\": \"ctrl+u\", \"command\": \"-extension.vim_ctrl+u\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-u&gt; &amp;&amp; !inDebugRepl\"},{ \"key\": \"ctrl+o\", \"command\": \"-extension.vim_ctrl+o\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-o&gt; &amp;&amp; !inDebugRepl\"},{ \"key\": \"win+a\", \"command\": \"-extension.vim_cmd+a\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;D-a&gt; &amp;&amp; !inDebugRepl &amp;&amp; vim.mode != 'Insert'\"},{ \"key\": \"backspace\", \"command\": \"-extension.vim_backspace\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; !inDebugRepl\"},{ \"key\": \"ctrl+alt+down\", \"command\": \"workbench.action.editor.nextChange\", \"when\": \"editorTextFocus\"},{ \"key\": \"ctrl+alt+up\", \"command\": \"workbench.action.editor.previousChange\", \"when\": \"editorTextFocus\"},{ \"key\": \"win+d\", \"command\": \"-extension.vim_cmd+d\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;D-d&gt; &amp;&amp; !inDebugRepl\"},{ \"key\": \"win+right\", \"command\": \"-extension.vim_cmd+right\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;D-right&gt; &amp;&amp; !inDebugRepl &amp;&amp; vim.mode != 'Insert'\"},{ \"key\": \"win+v\", \"command\": \"-extension.vim_cmd+v\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;D-v&gt; &amp;&amp; !inDebugRepl &amp;&amp; vim.mode == 'SearchInProgressMode'\"},{ \"key\": \"ctrl+pagedown\", \"command\": \"-extension.vim_ctrl+pagedown\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-pagedown&gt; &amp;&amp; !inDebugRepl\"},{ \"key\": \"ctrl+r\", \"command\": \"-extension.vim_ctrl+r\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-r&gt; &amp;&amp; !inDebugRepl\"},{ \"key\": \"ctrl+pageup\", \"command\": \"-extension.vim_ctrl+pageup\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-pageup&gt; &amp;&amp; !inDebugRepl\"},{ \"key\": \"ctrl+shift+2\", \"command\": \"-extension.vim_ctrl+shift+2\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-shift+2&gt;\"},{ \"key\": \"ctrl+x\", \"command\": \"-extension.vim_ctrl+x\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-x&gt; &amp;&amp; !inDebugRepl\"},{ \"key\": \"ctrl+x\", \"command\": \"-extension.vim_ctrl+x\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-x&gt; &amp;&amp; !inDebugRepl\"},{ \"key\": \"ctrl+x\", \"command\": \"-extension.vim_ctrl+x\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-x&gt; &amp;&amp; !inDebugRepl\"},{ \"key\": \"ctrl+y\", \"command\": \"-extension.vim_ctrl+y\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-y&gt; &amp;&amp; !inDebugRepl\"},{ \"key\": \"ctrl+y\", \"command\": \"-extension.vim_ctrl+y\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-y&gt; &amp;&amp; !inDebugRepl\"},{ \"key\": \"ctrl+y\", \"command\": \"-extension.vim_ctrl+y\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-y&gt; &amp;&amp; !inDebugRepl\"},{ \"key\": \"ctrl+y\", \"command\": \"-extension.vim_ctrl+y\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-y&gt; &amp;&amp; !inDebugRepl\"},{ \"key\": \"ctrl+y\", \"command\": \"-extension.vim_ctrl+y\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-y&gt; &amp;&amp; !inDebugRepl\"},{ \"key\": \"ctrl+y\", \"command\": \"-extension.vim_ctrl+y\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-y&gt; &amp;&amp; !inDebugRepl\"},{ \"key\": \"ctrl+y\", \"command\": \"-extension.vim_ctrl+y\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-y&gt; &amp;&amp; !inDebugRepl\"},{ \"key\": \"delete\", \"command\": \"-extension.vim_delete\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; !inDebugRepl &amp;&amp; vim.mode != 'Insert'\"},{ \"key\": \"delete\", \"command\": \"-extension.vim_delete\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; !inDebugRepl &amp;&amp; vim.mode != 'Insert'\"},{ \"key\": \"end\", \"command\": \"-extension.vim_end\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; !inDebugRepl &amp;&amp; vim.mode != 'Insert'\"},{ \"key\": \"end\", \"command\": \"-extension.vim_end\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; !inDebugRepl &amp;&amp; vim.mode != 'Insert'\"},{ \"key\": \"home\", \"command\": \"-extension.vim_home\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; !inDebugRepl &amp;&amp; vim.mode != 'Insert'\"},{ \"key\": \"win+left\", \"command\": \"-extension.vim_cmd+left\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;D-left&gt; &amp;&amp; !inDebugRepl &amp;&amp; vim.mode != 'Insert'\"},{ \"key\": \"ctrl+oem_4\", \"command\": \"-extension.vim_ctrl+[\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-[&gt; &amp;&amp; !inDebugRepl\"},{ \"key\": \"ctrl+ oem_6\", \"command\": \"-extension.vim_ctrl+]\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-]&gt; &amp;&amp; !inDebugRepl\"},{ \"key\": \"ctrl+b\", \"command\": \"-extension.vim_ctrl+b\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-b&gt; &amp;&amp; !inDebugRepl &amp;&amp; vim.mode != 'Insert'\"},{ \"key\": \"ctrl+d\", \"command\": \"-extension.vim_ctrl+d\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; !inDebugRepl\"},{ \"key\": \"ctrl+e\", \"command\": \"-extension.vim_ctrl+e\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-e&gt; &amp;&amp; !inDebugRepl\"},{ \"key\": \"ctrl+i\", \"command\": \"-extension.vim_ctrl+i\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-i&gt; &amp;&amp; !inDebugRepl\"},{ \"key\": \"ctrl+j\", \"command\": \"-extension.vim_ctrl+j\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-j&gt; &amp;&amp; !inDebugRepl &amp;&amp; vim.mode != 'Insert'\"},{ \"key\": \"ctrl+k\", \"command\": \"-extension.vim_ctrl+k\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-k&gt; &amp;&amp; !inDebugRepl &amp;&amp; vim.mode != 'Insert'\"},{ \"key\": \"ctrl+p\", \"command\": \"-extension.vim_ctrl+p\", \"when\": \"suggestWidgetVisible &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-p&gt;\"},{ \"key\": \"down\", \"command\": \"-extension.vim_down\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; !inDebugRepl &amp;&amp; !suggestWidgetMultipleSuggestions &amp;&amp; !suggestWidgetVisible\"},{ \"key\": \"left\", \"command\": \"-extension.vim_left\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; !inDebugRepl\"},{ \"key\": \"right\", \"command\": \"-extension.vim_right\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; !inDebugRepl\"},{ \"key\": \"shift+backspace\", \"command\": \"-extension.vim_shift+backspace\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;shift+BS&gt; &amp;&amp; !inDebugRepl &amp;&amp; vim.mode == 'SearchInProgressMode'\"},{ \"key\": \"tab\", \"command\": \"-extension.vim_tab\", \"when\": \"editorFocus &amp;&amp; vim.active &amp;&amp; !inDebugRepl &amp;&amp; vim.mode != 'Insert'\"},{ \"key\": \"up\", \"command\": \"-extension.vim_up\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; !inDebugRepl &amp;&amp; !suggestWidgetMultipleSuggestions &amp;&amp; !suggestWidgetVisible\"},{ \"key\": \"win+c\", \"command\": \"-extension.vim_cmd+c\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.overrideCopy &amp;&amp; vim.use&lt;D-c&gt; &amp;&amp; !inDebugRepl\"},{ \"key\": \"ctrl+y\", \"command\": \"editor.action.addSelectionToNextFindMatch\", \"when\": \"editorFocus\"},{ \"key\": \"ctrl+shift+o\", \"command\": \"workbench.action.files.openFolder\"},{ \"key\": \"ctrl+/\", \"command\": \"editor.action.blockComment\", \"when\": \"editorTextFocus &amp;&amp; !editorReadonly\"},{ \"key\": \"ctrl+shift+s\", \"command\": \"workbench.action.files.saveAll\"},{ \"key\": \"ctrl+alt+s\", \"command\": \"workbench.action.files.saveAs\"},{ \"key\": \"ctrl+shift+y\", \"command\": \"editor.action.changeAll\", \"when\": \"editorTextFocus &amp;&amp; !editorReadonly\"},{ \"key\": \"ctrl+t\", \"command\": \"editor.action.formatDocument\", \"when\": \"editorFocus\"},{ \"key\": \"ctrl+shift+t\", \"command\": \"HookyQR.beautifyFile\", \"when\": \"editorFocus\"},{ \"key\": \"ctrl+j\", \"command\": \"editor.action.joinLines\", \"when\": \"editorFocus\"},{ \"key\": \"ctrl+m\", \"command\": \"editor.action.insertSnippet\", \"when\": \"editorFocus\"},{ \"key\": \"alt+enter\", \"command\": \"editor.action.inspectTMScopes\", \"when\": \"editorFocus\"},{ \"key\": \"ctrl+p\", \"command\": \"editor.action.transposeLetters\", \"when\": \"editorFocus\"},{ \"key\": \"ctrl+shift+a\", \"command\": \"eslint.executeAutofix\", \"when\": \"editorFocus\"},{ \"key\": \"ctrl+alt+,\", \"command\": \"workbench.action.openSnippets\", \"when\": \"editorFocus\"},{ \"key\": \"alt+f2\", \"command\": \"workbench.action.selectTheme\", \"when\": \"editorFocus\"},{ \"key\": \"ctrl+m\", \"command\": \"workbench.action.newWindow\"},{ \"key\": \"ctrl+shift+,\", \"command\": \"workbench.action.openGlobalKeybindings\"},{ \"key\": \"ctrl+u\", \"command\": \"workbench.action.tasks.runTask\"},{ \"key\": \"f11\", \"command\": \"workbench.action.toggleZenMode\"},{ \"key\": \"ctrl+f5\", \"command\": \"code-runner.run\"},{ \"key\": \"ctrl+i\", \"command\": \"npm-intellisense.import\" , \"when\": \"editorLangId != 'markdown'\"},{ \"key\": \"alt+f5\", \"command\": \"npm-script.run\"},{ \"key\": \"shift+f5\", \"command\": \"workbench.action.debug.run\", \"when\": \"!inDebugMode\" },{ \"key\": \"ctrl+shift+\\\\\", \"command\": \"workbench.action.toggleEditorGroupLayout\"},{ \"key\": \"ctrl+shift+b\", \"command\": \"workbench.action.toggleSidebarVisibility\"},{ \"key\": \"ctrl+g\", \"command\": \"markdown.showPreview\", \"when\": \"editorLangId == 'markdown'\"},{ \"key\": \"ctrl+shift+l\", \"command\": \"workbench.action.gotoLine\"},{ \"key\": \"alt+a\", \"command\": \"workbench.action.increaseViewSize\" , \"when\": \"editorLangId != 'markdown'&amp;&amp;editorFocus\"},{ \"key\": \"alt+w\", \"command\": \"workbench.action.joinTwoGroups\" , \"when\": \"editorFocus\"},{ \"key\": \"ctrl+1\", \"command\": \"workbench.action.openEditorAtIndex1\" },{ \"key\": \"ctrl+2\", \"command\": \"workbench.action.openEditorAtIndex2\" },{ \"key\": \"ctrl+3\", \"command\": \"workbench.action.openEditorAtIndex3\" },{ \"key\": \"ctrl+4\", \"command\": \"workbench.action.openEditorAtIndex4\" },{ \"key\": \"ctrl+5\", \"command\": \"workbench.action.openEditorAtIndex5\" },{ \"key\": \"ctrl+6\", \"command\": \"workbench.action.openEditorAtIndex6\" },{ \"key\": \"ctrl+7\", \"command\": \"workbench.action.openEditorAtIndex7\" },{ \"key\": \"ctrl+8\", \"command\": \"workbench.action.openEditorAtIndex8\" },{ \"key\": \"ctrl+9\", \"command\": \"workbench.action.openEditorAtIndex9\" },{ \"key\": \"alt+1\", \"command\": \"workbench.action.focusFirstEditorGroup\" },{ \"key\": \"alt+2\", \"command\": \"workbench.action.focusSecondEditorGroup\" },{ \"key\": \"alt+3\", \"command\": \"workbench.action.focusThirdEditorGroup\" },{ \"key\": \"ctrl+shift+m\", \"command\": \"workbench.action.reloadWindow\"},{ \"key\": \"alt+.\", \"command\": \"workbench.action.showEmmetCommands\", \"when\": \"editorLangId != 'markdown'&amp;&amp;editorFocus\"},{ \"key\": \"alt+enter\", \"command\": \"editor.emmet.action.nextEditPoint\", \"when\": \"editorFocus\"},{ \"key\": \"ctrl+shift+j\", \"command\": \"editor.emmet.action.mergeLines\", \"when\": \"editorFocus\"},{ \"key\": \"alt+left\", \"command\": \"editor.emmet.action.removeTag\", \"when\": \"editorFocus\"},{ \"key\": \"alt+right\", \"command\": \"editor.emmet.action.wrapWithAbbreviation\", \"when\": \"editorFocus\"},{ \"key\": \"alt+shift+right\", \"command\": \"editor.emmet.action.balanceOut\", \"when\": \"editorFocus\"},{ \"key\": \"alt+shift+left\", \"command\": \"editor.emmet.action.balanceIn\", \"when\": \"editorFocus\"},{ \"key\": \"alt+shift+enter\", \"command\": \"editor.emmet.action.updateTag\", \"when\": \"editorFocus\"},{ \"key\": \"ctrl+shift+w\", \"command\": \"workbench.actions.view.problems\"},{ \"key\": \"alt+q\", \"command\": \"workbench.action.terminal.toggleTerminal\"},{ \"key\": \"ctrl+shift+r\", \"command\": \"workbench.debug.action.toggleRepl\"},{ \"key\": \"ctrl+shift+a\", \"command\": \"autoprefixer.execute\", \"when\": \"editorTextFocus &amp;&amp; editorLangId != 'javascript' &amp;&amp; editorLangId != 'typescript'\"},{ \"key\": \"ctrl+shift+a\", \"command\": \"tslint.fixAllProblems\", \"when\": \"editorTextFocus &amp;&amp; editorLangId != 'javascript' &amp;&amp; editorLangId != 'less' &amp;&amp; editorLangId != 'css'\"},{ \"key\": \"ctrl+alt+o\", \"command\": \"gitProjectManager.openProject\"},{ \"key\": \"ctrl+b\", \"command\": \"workbench.action.openRecent\"},{ \"key\": \"ctrl+r\", \"command\": \"-workbench.action.openRecent\"},{ \"key\": \"alt+b\", \"command\": \"markdown.extension.editing.toggleBold\", \"when\": \"editorTextFocus &amp;&amp; editorLangId == 'markdown'\"},{ \"key\": \"alt+c\", \"command\": \"markdown-preview-enhanced.syncPreview\", \"when\": \"editorLangId == 'markdown'\"},{ \"key\": \"win+`\", \"command\": \"search.action.collapseSearchResults\"}] 结束如果你的机器是 Windows 系统，同时也是 VSCode 重度使用者，不妨试试我的快捷键，可以让你的操作彻底飞起来~😎 欢迎转载本站文章，请注明作者和出处 simonaking.com。 .Key{color:#999;font-size:98%;}","categories":[{"name":"工具","slug":"工具","permalink":"https://simonaking.com/blog/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://simonaking.com/blog/tags/%E5%B7%A5%E5%85%B7/"},{"name":"VSCode","slug":"VSCode","permalink":"https://simonaking.com/blog/tags/VSCode/"},{"name":"快捷键","slug":"快捷键","permalink":"https://simonaking.com/blog/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"}]},{"title":"Webpack 飞行手册","date":"2017-11-30T11:16:57.000Z","path":"/webpack-flight-manual/","text":"现在是一个 Web 技术蓬发的时代。 前言在学习 Webpack 之前，我们需要了解一个概念：模块。 何为模块？如果你曾学过 Java , C# 之类的语言，一定会知道 Java 中的 import 或 C# 中的 using 吧？ 比如：我想在 C# 中进行数据库操作，我只需要在代码头部加上 下面这两段代码即可。 using System.Data;using System.Data.SqlClient; 这两段代码可以看成 两个与数据库操作相关的模块。 当我们需求是数据库，或者是读取 IO 等其他操作，我们便加载其他不同的模块。 很明显，这实现了编程中的一个非常重要的功能 按需加载。 在前端中 模块又该如何定义呢？ 按照我个人的理解： 在 HTML 中 模块 便是一个组件&lt;div class=\"layer\"&gt; &lt;div&gt;&lt;%= name %&gt;&lt;/div&gt; &lt;% for(var i = 0; i &lt; People.length;++i) { %&gt; &lt;%= People[i] %&gt; &lt;% } %&gt;&lt;/div&gt; 在 CSS 中 模块 便是一个局部样式 header{ display:block;}header h1{ font-size: 60px;} 在 Javascript 中 模块 便是一个封装着方法或数据的脚本文件 let People = { name: \"Simon\" } ;module.exports = People; 而我们又该怎样实现 在前端中加载模块呢？ 下面是两个很常见的例子： 在 Less 中 @import \"header\";@import \"layout\";@import \"footer\"; 在 Javascript // CommonJSconst $ = require(\"jQuery\");//es6let People = { name: \"Simon\" } ;module.exports = People;import \"./layer.less\";import tpl from \"./layer.ejs\"; 如果你直接运行以上代码，浏览器并不会解析，这个时候，就要依靠 Webpack 了！ Webpack 是什么Webpack 是一款目前非常流行的前端模块打包工具，可以将项目中所加载的模块进行打包，以及将 一些浏览器不支持的语言进行转换。 Webpack 的打包原理是 先找到入口文件，递归探索出所有依赖的模块，最后 利用 Loader 进行不同文件类型的处理，打包成一个 Javascript 文件。 其中，Webpack 的两个最核心原理分别是： 一切皆模块 按需加载 当然 Webpack 的作用不止加载模块这么简单，前端的常用需求通常都可以实现：利用 Loader 转换 es6 、 Less 、 Typescript ，还可利用插件 开发多页面应用,等等诸多强大功能。 正文下面，我将讲解 Webpack 的具体使用和配置。 安装我一般在项目中使用 Webpack，都是先执行下面这四条命令进行 Webpack 的安装 npm install -g webpack 在全局安装 Webpack，第一次使用时 执行 npm install --save-dev webpack 将 Webpack 安装到你的项目 npm init npm 初始化，会询问你的项目信息，可以回车跳过 npm install --save-dev webpack-dev-server 在当前项目，安装 Webpack 服务器 安装完成后，便是建立配置文件了。 基本配置在项目根目录下新建名为 webpack.config.js 的文件， 基本上 一个配置文件的大体结构就是下面这样： modules.export={ entry:{ /* 入口文件 */ }, output:{ /* 出口文件 */ }, module:{ /* Loader */ rules:[{},{},{}] }, plugins:[ /* 插件 */ ], devtool: ... devServer: {...} resolve:{...}} 我们下面就先分析 modules.export 各个属性 入口entry 代表是入口文件，Webpack 工作的开始。 Webpack 会递归的探索出 入口文件中所依赖的模块，并按照顺序 利用 Loader 进行处理。 官网给出了其 3 种数据类型： 字符串entry: \"app.js\"; 数组 数组中的每一项都会被打包，形成互不依赖的文件entry: [\"app.js\",\"main.js\"]; 对象 对象中的每一个属性都会被打包，形成互不依赖的文件entry:{ app: \"./src/js/app.js\", main: \"./src/js/main.js\"} 一般入口文件中多是 import 或者 require 等模块导入命令。 出口output 顾名思义，Webpack 打包后文件的具体配置 常用的属性有 4 个 path: ${__dirname }/dist 打包后文件所在路径 filename: “js/[name].js” 打包后文件的名字，这里有 4 种常用的写法 自定义 [name].js 代表的便是入口的文件名 [hash].js 此次打包后的 hash 值 [chunkhash] 该块打包后的 hash 值 publicPath: \"http://cdn.com/\" 上线时的公共路径，主要应用于线上 chunkFilename: ‘js/[name].js’ 按需加载模块时输出的文件名称 LoaderLoader 是 Webpack 中最振奋人心的东西了！ 将一切浏览器不支持的语言，处理成 浏览器可以支持。 针对各个文件类型，都有各种的 Loader 等你去挖掘。 Loader 的工作方式 是从右向左执行，链式地按照顺序进行编译。 loader 链中的第一个返回值给下一个 loader，在最后一个 loader，返回所预期的结果。 loader 可以是同步或异步函数，也可使用 options 对象去接受配置参数。 基础结构 module:{ rules:[ { test:/\\.xxx$/,//以 xxx 结尾的文件 loader: \"xxx-loader\", exclude: {排除的路径}, include: {包含的路径}, options: {Loader 配置} } ]} 可以很清楚的看到，Loader 利用 test 的正则 找到各个类型文件，然后使用 loader 进行处理，便可转换成浏览器支持的文件。 其中我知道的 loader 的写法有两种: 每一个 loader 都是一个对象loaders:[ {loader:\"style-loader\"}, { loader: \"css-loader?modules\", options: { importLoaders: 1 } }, {loader: \"less-loader\"}] 使用 ! 号拼接的写法loader: \"style-loader!css-loader?importLoaders=1!less-loader\" 下面介绍三个 前端必备的 Loader 方式css style-loader 通过注入style标签将 CSS 添加到 DOMnpm install style-loader --save-dev css-loader css-loader 像 import / require（）一样解释@import 和 url（）并解析它们。npm install css-loader --save-dev postcss-loader 补充 不兼容的 css 属性 的浏览器前缀npm install post-loader --save-dev less-loader 将 Less 转换成 CSSnpm install less --save-devnpm install less-loader --save-dev javascriptbabel 主要用于将 es6 转换成 es2015 npm install --save-dev babel-core babel-loader babel-preset-es2015 图片 &amp; 字体 file-loader 用于压缩文件npm install --save-dev file-loader url-loader 如果文件下于 规定限制，将会转换成 二进制编码npm install --save-dev url-loader ejs另外 我想介绍一下 自己常用的 ejs-loader 配置 npm install --save-dev ejs-loader test:/\\.ejs$/ , loader:\"ejs-loader\", 使用 &lt;div class=\"layer\"&gt; &lt;div&gt;&lt;%= name %&gt;&lt;/div&gt; &lt;% for(let i = 0; i &lt; Array.length;++i) { %&gt; &lt;%= Array[i] %&gt; &lt;% } %&gt;&lt;/div&gt; //入口文件import tpl from \"./layer.ejs\";document.body.innerHTML = tpl({ name:\"Simon\", arr:[\"Apple\",\"Xiaomi\"]}); 运行 生成后的页面 ，便会发现 ejs 组件已经被加进去了， 想象一下，我们在平时工作中是否可以把 一个轮播图，或者 排行榜 、评论 当成一个组件呢？ 插件plugins 在日常工作中，我们使用 Loader 处理不同类型的文件，当有某种其他方面的需求时，比如 抽离 CSS 、生成多页面 HTML ，plugins 便派上了用场。 插件的使用，一般都要先 require 出来，然后在 plugins 属性中 进行初始化 const htmlWebpackPlugin = require(\"html-webpack-plugin\");......plugins: [ new htmlWebpackPlugin({/* options */}) ] 下面将介绍 一些工作中常用的插件 clean-webpack-plugin 主要用于 打包之前 先清空 打包目录下的文件，防止文件混乱。npm install --save-dev clean-webpack-plugin html-webpack-plugin 主要用于生成 HTML，可以规定 模板 HTML，也可以为 模板传入参数，压缩文件等npm install --save-dev html-webpack-plugin 这个插件可谓是 前端必备的，它的配置有很多new htmlWebpackPlugin({ //打包后的文件名 filename: \"index.html\", //模板 template: \"index.html\", //为 true 自动生成 script 标签添加到 html 中 //或者写 body/head 标签名 inject: false,//js 的注入标签 //通过&lt;%= htmlWebpackPlugin.options.title %&gt;引用 title: \"参数 title\", //通过&lt;%= htmlWebpackPlugin.options.date %&gt; 引用 date: new Date() //网站的图标 favicon: 'path/to/yourfile.ico' //生成此次打包的 hash //如果文件名中有哈希，便代表有 合理的缓冲 hash: true, //排除的块 excludeChunks: [''], //选中的块 与入口文件相关 chunks: ['app','people'], //压缩 minify:{ removeComments: true, collapseWhitespace: true, removeRedundantAttributes: true, useShortDoctype: true, removeEmptyAttributes: true, removeStyleLinkTypeAttributes: true, keepClosingSlash: true, minifyJS: true, minifyCSS: true, minifyURLs: true, }}), 那么问题来了，我们在模板文件中 又该怎样使用参数呢？ 直接按照 ejs 的语法写入 html 文件即可！&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;%= htmlWebpackPlugin.options.date %&gt;&lt;/html&gt; 生成后的模板文件&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;Thu Dec 07 2017 10:01:58 GMT+0800 (中国标准时间)&lt;/html&gt; 另外，如果想生成 多页面应用，只需 将上面的配置，多复制几遍即可。new htmlWebpackPlugin({ filename: \"index1.html\", }new htmlWebpackPlugin({ filename: \"index2.html\", }new htmlWebpackPlugin({ filename: \"index3.html\", } UglifyJsPlugin 主要用于压缩 Javascript 文件npm i -D uglifyjs-webpack-plugin webpack.ProvidePlugin 自动加载模块，全局使用变量，下面借助 官网的 DEMOnew webpack.ProvidePlugin({ $: 'jquery', jQuery: 'jquery'})// in a module$('#item'); // &lt;= 起作用jQuery('#item'); // &lt;= 起作用// $ 自动被设置为 \"jquery\" 输出的内容 open-browser-webpack-plugin 打开服务器后 会自动打开浏览器端口，用起来 很方便 HotModuleReplacementPlugin 热更新插件 常用命令 webpack 最基本的启动 webpack 命令。找到根目录下的 webpack.config.js 文件中的 entry 属性，递归出所有项目中依赖的模块。 webpack -w 监控代码变化，实时进行打包更新 webpack -p 对打包后的文件进行压缩，利用线上发布 webpack -d 提供 SourceMaps，方便调试代码 webpack –colors 输出结果带彩色，可以更详细的查看信息 webpack –profile 输出性能数据，可以看到每一步的耗时 前两个命令使用频率会较大 devtool不知道你现在时候有没有一个想法？ webpack 打包后的文件就一定正确无误吗？ 如果发生错误的话，该怎么办呢？ devtool 属性 便提供了生成 sourcemap 的功能，具体有下面这些选项。 source-map 此选项具有最完备的 source map，但会减慢打包的速度； cheap-module-source-map 生成一个不带列映射的 map eval-source-map 使用 eval 打包源文件模块，生成一个完整的 source map。 cheap-module-eval-source-map 这是最快生成 source map 的方法，生成后的 Source Map 会和打包后的 JavaScript 文件同行显示，但没有列映射，所以慎用 devServer contentBase: “./dist”, 本地服务器所加载的页面所在的目录 historyApiFallback: true, 再找不到文件的时候默认指向 index.html inline: true, 当源文件改变时会自动刷新页面 hot: true, 热加载开启 port:8080 设置默认监听端口 resolve extensions: [“.js”, “.html”, “.css”, “.txt”,”less”,”ejs”,”json”], 自动扩展文件后缀名，意味着我们 require 模块可以省略不写后缀名 alias: { Temp: path.resolve(__dirname, “src/templates/“) } 模块别名定义，直接 require(‘AppStore’) 即可,方便后续直接引用别名 其他功能path常用于字符串拼接路径。 const path = require(\"path\"); 有两个 API path.resolve() 将相对路径转换成绝对路径const aPath = path.resolve(\"__dirname\",\"js\",\"main.js\");// aPath = 当前目录下的 js 文件夹的 main.js 文件的路径 path.join() 对路径进行拼接const rPath = path.join(\"source\",\"js\",\"main.js\");// aPath = //source/js/main.js __dirname Node.js 中的全局变量，代表的是 项目的当前路径。常与 path 结合使用。 热更新上面我们已经提过了 webpack -w 命令，它可以实时的监控 代码的改变，从而自动进行打包，但是 有个缺点 在于它不能及时的刷新界面。 在我们 开启服务器后，是无法使用 此命令的，这个时候，如果你还想进行 自动打包，又想自动刷新界面，热更新 便是不二之选，另外 Webpack 只会热更新 发生改变的模块，不会重新加载整个页面，便可加快开发速度。 开启步骤： 修改 devServer 属性devServer: { hot: true,//热加载开启 inline: true,//文件改变时会自动刷新页面} 增加热更新插件const webpack = require(\"webpack\");//Other propertyplugins: [ new webpack.HotModuleReplacementPlugin()] 另外，只有修改 依赖的项目，才会进行实时更新。 源文件个人总结了很长时间的 Webpack 配置，希望能对你有帮助。 点击显/隐源文件 const path = require(\"path\"), webpack = require(\"webpack\"), htmlWebpackPlugin = require (\"html-webpack-plugin\"), ExtractTextPlugin = require (\"extract-text-webpack-plugin\"), marked = require(\"marked\"), renderer = new marked.Renderer(), CleanWebpackPlugin = require (\"clean-webpack-plugin\"), OpenBrowserPlugin = require (\"open-browser-webpack-plugin\"); const MyConfig = { entry: { app:\"./src/js/app.js\" }, output: { path: `${__dirname }/dist`, filename: \"js/[name].js\" // 上线时的公共路径 // publicPath: \"http://cdn.com/\", // 按需加载模块时输出的文件名称 // chunkFilename: 'js/[name].js' }, /* 生成调试用的 source-map */ devtool: \"eval-source-map\", devServer: { contentBase: \"./dist\", //本地服务器所加载 的页面所在的目录 historyApiFallback: true, //再找不到文件 的时候默认指向 index.html, inline: true,//当源文件改变时会自动刷新页面 hot: true,//热加载开启 port:8080// 设置默认监听端口 }, resolve:{ //自动扩展文件后缀名，意味着我们 require 模块可 以省略不写后缀名 extensions: [\".js\", \".html\", \".css\", \".txt\",\"less\",\"ejs\",\"json\"], //模块别名定义，直接 require('AppStore') 即可,方便后续直接引用别名 alias: { Temp: path.resolve(__dirname, \"src/templates/\") } }, module:{ rules:[ { test: /\\.(less|css)?$/ , use:ExtractTextPlugin.extract({ fallback: \"style-loader\", use:[ { loader: \"css-loader? modules\", options: { importLoaders: 1 } }, { loader:\"postcss-loa der\", options:{plugins: (loader) =&gt; [require (\"autoprefixer\")()] } }, {loader: \"less-loader\"} ] }), exclude: path.resolve (__dirname,\"./node_modules\") }, { test: /\\.js$/ , loader:\"babel-loader\", exclude: path.resolve (__dirname,\"./node_modules\"), include: path.resolve (__dirname, \"./src\"), options: {\"presets\": [\"latest\"] } }, { test:/\\.html$/ , loader:\"html-loader\", include:path.resolve(__dirname, \"./src/layer\"), exclude: path.resolve (__dirname,\"./node_modules\") }, { test:/\\.ejs$/ , loader:\"ejs-loader\", include:path.resolve(__dirname, \"./src/layer\"), exclude: path.resolve (__dirname,\"./node_modules\") }, { test: /\\.(png|jpg|jpeg|gif|svg| woff|woff2|ttf|eot|otf)$/i, loaders: [ \"file-loader\", \"url-loader?limit=8192\",{ loader: \"image-webpack-loader\", options: { gifsicle: { interlaced: false } , optipng: { optimizationLevel: 7 }, pngquant: { quality: \"65-90\", speed: 4 }, mozjpeg: { progressive: true, quality: 65 }, webp: { quality: 75 } } } ], exclude: path.resolve (__dirname,\"./node_modules\") } ] }, plugins: [ //打包前 先删除 dist 目录下的文件 new CleanWebpackPlugin( [\"dist\"], { root: __dirname,//指定插件根目录 位置 verbose: true, //开启在控制台输出 信息 dry: false //启用删除文件 } ), //生成 html new htmlWebpackPlugin({ filename: \"index.html\",//文件名 template: \"index.html\",//模板 inject: false,//js 的注入标签 //这个配置项为 true 表示自动把打包出来的文 件通过自动生成 script 标签添加到 html 中 title: \"参数 title\",//通过&lt;%= htmlWebpackPlugin.options.title %&gt; 引用 date: new Date()//通过&lt;%= htmlWebpackPlugin.options.date %&gt;引 用 //favicon: 'path/to/yourfile.ico' // excludeChunks: [''],//排除的块 // chunks: ['app','people']//选中的 块 /*minify:{ //压缩 removeComments: true, collapseWhitespace: true, removeRedundantAttributes: true, useShortDoctype: true, removeEmptyAttributes: true, removeStyleLinkTypeAttributes: true, keepClosingSlash: true, minifyJS: true, minifyCSS: true, minifyURLs: true, }*/ }), //防止 CSS 文件混乱，单独生成一个 css 文件 new ExtractTextPlugin(\"./css/[name] .min.css\"), //在每个生成的 chunk 顶部添加 banner new webpack.BannerPlugin (\"Anthor:Simon\"),//添加一个显示版权声明的插 件 new webpack.optimize.UglifyJsPlugin({ compress:{//额外的压缩选项 warnings:false } // mangle: { 排除不想要压缩的对象名称 // except: ['$super', '$', 'exports', 'require', 'module', '_'] // }, }),//压缩 js //定义全局变量 new webpack.DefinePlugin({ __DEV__: JSON.stringify(JSON.parse (process.env.DEBUG || \"false\")) }), //使用 ProvidePlugin 加载的模块在使用时将不再 需要 import 和 require 进行引入 //全局自动加载模块 new webpack.ProvidePlugin({ $: \"jquery\", jQuery: \"jquery\" }), //打开服务器后 会自动打开浏览器 new OpenBrowserPlugin({url: \"http://localhost:8080\"}), //排序输出,为组件分配 ID new webpack.optimize.OccurrenceOrderPlugin (), // 启用 HMR 热加载插件 new webpack.HotModuleReplacementPlugin (), // 打印日志信息时 webpack 默认使用模块的数 字 ID 指代模块，不便于 debug， // 这个插件可以将其替换为模块的真实路径 new webpack.NamedModulesPlugin() /*提取 Chunks 中的公共内容 new webpack.optimize.CommonsChunkPlugin ({ name: [\"vendor\", \"manifest\"], // vendor libs + extracted manifest minChunks: Infinity, }),*/ /*拷贝资源插件 适用于线上场景 new CopyWebpackPlugin([{ from: __dirname + '/src/public' }]),*/ ] }; module.exports = MyConfig; 结束语欢迎转载本站文章，请注明作者和出处 simonaking.com。 .post-toc-level-4{ display:none }.post-content ol li:first-line { color: #999; font-weight: bold; }","categories":[{"name":"前端","slug":"前端","permalink":"https://simonaking.com/blog/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://simonaking.com/blog/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Webpack","slug":"Webpack","permalink":"https://simonaking.com/blog/tags/Webpack/"}]},{"title":"链式向前星","date":"2017-11-22T14:24:41.000Z","path":"/chain-forward-star/","text":"这是一种神奇的数据结构。 来源听说是某个高中 Oi 菊苣发明，%%% 应用有的时候有的图可能比较稀疏而且点数较多，邻接矩阵存不下，所以就要用到邻接表。 邻接表用 vector 数组比较方便，但是 vector 比较慢。所以就有了链式向前星。 理解通过 Head 可以找到一个点的所有边,可以把 Head 理解为：链表的有实际含义的头节点 Head[N]永远保存最后一次输入的 N 点数组的下标值， Head[N]=idx; 意思是，保存 N 点的数组的下标值 而 Next 保存变化中的 Head，但不保存最后一次的 Head Edge[i].Next=Head[N]; Head[N]=idx++; 从而 Head 与 Next 数组实现链式向前星的整个过程， Head 相当于链表的有实际含义的头节点 Next 保存链表中的节点，但值得注意的是 Next 与 Head 都是通过保存下标值的方式实现的 相当于：索引式链表。 End 为终点，Value 为权值，先不提 而 Next 就相当于链表中的节点的位置，而没有头节点 Head ,是无法提取的。 保存下标值的方式很有趣，虽然开始理解起来有点怪。 int i=Head[S]; 此时 i 为最后一次保存 S 点数组的下标值，也就是最后一次输入的 S 点数据 Edge[i].End 便为最后一次输入 S 点的终点，Value 也是同理，而 S 作为出发点，不再多提 之后很关键，i=Edge[i].Next，要知道，每次的 Edge[i].Next 都是由 Head 变化而来 意思就是，i=Edge[i].Next,此后的 i 为倒数第二次输入 S 点数组的下标值！ i=Edge[Head[S]].Next;之后 i=Edge[Edge[Head[S]].Next;].Next; 从而反复循环，直到，下一条边为 0 时，便是最后一次输入的 S 点的数组的下标值 因为 最开始时，Edge[i].Next=Head[S]=0; 代码#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5;struct Node{ int End;//保存一个边的终点 int Next;//保存一个点（起点）的 除了最后一条（输入的顺序）之外的所有边的下标值 int Value;//保存一条边的权值 Node(){} Node(int a,int b,int c): End(a),Next(b),Value(c){}}Edge[maxn];bool Vis[maxn];int Head[maxn];//Head 数组 为边的索引int Idx;queue&lt;int&gt;Map;inline void AddEdge(int Start,int End,int Value){ Edge[Idx]=Node(End,Head[Start],Value); Head[Start]=Idx++;}inline void Init(){ Idx=1; memset(Edge,0,sizeof(Edge)); memset(Vis,false,sizeof(Vis)); int N,M,x,y,z; scanf(\"%d%d\",&amp;N,&amp;M); while(M--){ scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z); AddEdge(x,y,z); AddEdge(y,x,z); } int Start; scanf(\"%d\",&amp;Start); Vis[Start]=true; Map.push(Start);}inline void Traverse(){ while(!Map.empty()){ int Start=Map.front(); Map.pop(); for(int i=Head[Start];i;i=Edge[i].Next){ printf(\"%d-&gt;%d=%d\\n\",Start,Edge[i].End,Edge[i].Value); if(!Vis[Edge[i].End]){ Map.push(Edge[i].End); Vis[Edge[i].End]=true; } } }}int main(){ Init(); Traverse(); return 0;}/*输入样例5 51 2 32 3 43 4 54 5 65 6 71*/ 总结 优点：不会浪费数据空间; 缺点：无法直接判断两个点是否是邻接点 链式向前星是一个很不错的数据结构，利用数组索引特性，加上其他权值，存储了整个图。","categories":[{"name":"算法","slug":"算法","permalink":"https://simonaking.com/blog/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://simonaking.com/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Vim 修炼秘籍之命令篇","date":"2017-11-22T02:20:04.000Z","path":"/order-of-vim-cultivation-cheats/","text":"总结下 Vim 常用命令以及使用技巧。 移动命令h 左j 下 k 上 l 右space 右e 后单词尾w 后单词头b 前单词头^ 行首$ 行尾 { 上段} 下段H 屏幕上面M 屏幕中间L 屏幕下面gg 文件头G 文件尾zz 定位屏幕中间zt 定位屏幕顶部zb 定位屏幕底部mk 标记`k 转到标记 插入命令a 后字符A 行尾i 前字符I 行首s 当前字符S 当前行o 下一行O 上一行cc 当前行C 后字符至行尾c+op 查找/a 文章 n N?a 反向fa 当前行 ; ,Fa 反向ta 当前行的前一个字符 ; ,Ta 反向\\* 文章 n N\\# 反向 编辑% 括号匹配&lt;&lt; 缩进u 撤回p 粘贴P 粘贴至上一行yy 复制Y 复制rt 替换R 替换模式dd 剪切D 剪切至行尾J 连接下一行x 剪切当前字符X 剪切前一个字符zc 折叠zo 打开折叠v 选中字符V 选中当前行~ 切换当前字符大小写Vu 当前行小写VU 当前行大写 寄存器\"ayy 将当前数据复制到 a 的寄存器\"ap 将 a 的寄存器中的数据粘贴出来qa 寄存器a的开始记录op 操作~q 结束记录@a 使用寄存器\"_ 黑洞寄存器,说白了就是删除\"adiw \"aP 命令:w 保存文件:wq 退出编辑器，且保存文件:x 退出编辑器，且保存文件q! 放弃修改e! 放弃 修改后 载入文件 范围介词i Inside \"x\" =&gt; \"\"a Around \"x\" =&gt; f Forward x =&gt; ...o...t To x =&gt; ...ox...名词w Words Sentencep Paragraph b ()B {}0 lineHead[]''\"\"&lt;&gt; 技巧动词 介词 名词d/y i/a/f/t c~/b/B/w/\"/'动词 数词 名词2 d w数词 动词5 G4 jxp 交换两个字符yiw 拷贝一个单词 dk 删除当前行以及上一行dft 删除至 t 包括 t 必备. 重复上一次修改命令","categories":[{"name":"工具","slug":"工具","permalink":"https://simonaking.com/blog/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://simonaking.com/blog/tags/%E5%B7%A5%E5%85%B7/"},{"name":"Vim","slug":"Vim","permalink":"https://simonaking.com/blog/tags/Vim/"}]},{"title":"HDU1874-畅通工程续","date":"2017-11-22T01:30:59.000Z","path":"/hdu1874-problem/","text":"题目传送门 大一做的最短路模板题，很适合练手 我分别利用了 3 种数据结构+Dijkstra/Floyd 来解决，解题步骤具体如下： 邻接矩阵15ms #include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e2+5;const int INF = 0x3f3f3f3f;int Map[maxn][maxn];bool Vis[maxn];int Dis[maxn];int N,M,S,D;inline void Init(){ memset(Map,INF,sizeof(Map)); memset(Vis,false,sizeof(Vis)); memset(Dis,0,sizeof(Dis)); int x,y,z; while(M--){ scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z); Map[x][y]=Map[y][x]=min(Map[x][y],z); } scanf(\"%d%d\",&amp;S,&amp;D); for(int i=0;i&lt;N;++i){ Dis[i]=Map[S][i]; } Dis[S]=0; Vis[S]=true;}inline void Dijkstra(){ for(int l=0;l&lt;N;++l){ int Min=INF,k; for(int i=0;i&lt;N;++i){ if(!Vis[i]&amp;&amp;Dis[i]&lt;Min){ Min=Dis[i]; k=i; } } Vis[k]=true; if(Min!=INF){ for(int j=0;j&lt;N;++j){ if(!Vis[j]&amp;&amp;Dis[j]&gt;Dis[k]+Map[k][j]){ Dis[j]=Dis[k]+Map[k][j]; } } } } Dis[D]==INF?printf(\"-1n\"):printf(\"%dn\",Dis[D]);}int main(){ while(~scanf(\"%d%d\",&amp;N,&amp;M)){ Init(); Dijkstra(); } return 0;} 邻接表15ms #include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5;const int INF = 0x3f3f3f3f;struct Node{ int from,to,cost; Node(int a,int b,int c):from(a),to(b),cost(c){}};vector&lt;Node&gt;Edges;vector&lt;int&gt;G[maxn];int Dis[maxn];int N,M,S,T;typedef pair&lt;int,int&gt; Pair;priority_queue&lt;Pair,vector&lt;Pair&gt;,greater&lt;Pair&gt; &gt;Q;inline void AddEdge(int x,int y,int z){ Edges.push_back(Node(x,y,z)); G[x].push_back(Edges.size()-1);}inline void Init(){ Edges.clear(); memset(Dis,INF,sizeof(Dis)); for(int i=0;i&lt;N;G[i++].clear()); int x,y,z; while(M--){ scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z); AddEdge(x,y,z); AddEdge(y,x,z); } scanf(\"%d%d\",&amp;S,&amp;T); Dis[S]=0; Q.push(Pair(0,S));}inline void Dijkstra(){ int Now,Val,L; while(!Q.empty()){ Now=Q.top().second; Val=Q.top().first; Q.pop(); if(Dis[Now]&lt;Val){continue;} L=G[Now].size(); for(int i=0;i&lt;L;++i){ if(Dis[Edges[G[Now][i]].to]&gt;Dis[Now]+Edges[G[Now][i]].cost){ Dis[Edges[G[Now][i]].to]=Dis[Now]+Edges[G[Now][i]].cost; Q.push(Pair(Dis[Edges[G[Now][i]].to],Edges[G[Now][i]].to)); } } } Dis[T]==INF?printf(\"-1n\"):printf(\"%dn\",Dis[T]);}int main(){ while(~scanf(\"%d%d\",&amp;N,&amp;M)){ Init(); Dijkstra(); } return 0;} 链式向前星0ms #include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2017;const int INF = 0x3f3f3f3f;struct Node{ int End; int Value; int Front; Node(){} Node(int a,int b,int c):End(a),Front(b),Value(c){}}Edge[maxn];int Head[maxn];int Dis[maxn];int N,M,S,D,Idx;typedef pair&lt;int,int&gt;Pair;priority_queue&lt;Pair,vector&lt;Pair&gt;,greater&lt;Pair&gt; &gt;Q;inline void AddEdge(int S,int D,int V){ Edge[Idx]=Node(D,Head[S],V); Head[S]=Idx++;}inline void Init(){ Idx=0; memset(Head,-1,sizeof(Head)); memset(Dis,INF,sizeof(Dis)); int x,y,z; while(M--){ scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z); AddEdge(x,y,z); AddEdge(y,x,z); } scanf(\"%d%d\",&amp;S,&amp;D); Pair pNew; Dis[S]=0; pNew.first=0; pNew.second=S; Q.push(pNew);}inline void Dijkstra(){ int Now,Val; while(!Q.empty()){ Now=Q.top().second; Val=Q.top().first; Q.pop(); if(Dis[Now]&lt;Val)continue; for(int i=Head[Now];~i;i=Edge[i].Front){ if(Dis[Edge[i].End]&gt;Dis[Now]+Edge[i].Value){ Dis[Edge[i].End]=Dis[Now]+Edge[i].Value; Q.push(Pair(Dis[Edge[i].End],Edge[i].End)); } } } Dis[D]==INF?printf(\"-1n\"):printf(\"%dn\",Dis[D]);}int main(){ while(~scanf(\"%d%d\",&amp;N,&amp;M)){ Init(); Dijkstra(); } Floyd62ms #include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e2+5;const int INF = 0x3f3f3f3f;int Map[maxn][maxn];int N,M,S,D;inline void Init(){ int x,y,z; memset(Map,INF,sizeof(Map)); for(int i=0;i&lt;N;++i){ Map[i][i]=0; } while(M--){ scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z); Map[x][y]=Map[y][x]=min(Map[x][y],z); } scanf(\"%d%d\",&amp;S,&amp;D);}inline void Floyd(){ for(int k=0;k&lt;N;++k){ for(int i=0;i&lt;N;++i){ for(int j=0;j&lt;N;++j){ Map[i][j]=min(Map[i][j],Map[i][k]+Map[k][j]); } } } Map[S][D]==INF?printf(\"-1\\n\"):printf(\"%d\\n\",Map[S][D]);}int main(){ while(~scanf(\"%d%d\",&amp;N,&amp;M)){ Init(); Floyd(); } return 0;} 后记自从退 acm，很多东西都在遗忘…","categories":[{"name":"算法","slug":"算法","permalink":"https://simonaking.com/blog/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://simonaking.com/blog/tags/%E7%AE%97%E6%B3%95/"}]}]