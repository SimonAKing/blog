<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1,maximum-scale=2,viewport-fit=cover"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="renderer" content="webkit"><meta name="author" content="SimonAKing"><link rel="icon" type="image/x-icon" href="https://cdn.jsdelivr.net/gh/SimonAKing/images/blog/favicon.ico"><link rel="shortcut icon" type="image/x-icon" href="https://cdn.jsdelivr.net/gh/SimonAKing/images/blog/favicon.ico"><link rel="apple-touch-icon" href="https://cdn.jsdelivr.net/gh/SimonAKing/images/PWA/apple-touch-icon.png"><title>浅谈搭建平台-画布篇</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/SimonAKing/font/comic.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-roboto@1.1.13/index.min.css"><link id="style" rel="stylesheet" href="https://cdn.jsdelivr.net/gh/SimonAKing/blog@7d04115230169/css/style-eaf373873c.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/SimonAKing/blog@7d04115230169/css/post-04c1b3d7ed.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/SimonAKing/blog@7d04115230169/css/module/relatedPosts-1fcaaf0adb.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/SimonAKing/blog@7d04115230169/css/module/comment-2c4172461a.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/firacode@5.2.0/distr/fira_code.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/SimonAKing/blog@7d04115230169/css/highlight-d6d2f7ba38.css"><meta name="theme-color"><meta name="apple-mobile-web-app-status-bar-style"><meta name="msapplication-navbutton-color"><script>
	window.selectedColor = ''
	window.themeColor = localStorage.getItem("theme-color") || "#5275b0"
	window.changeColor = function(themeColor){
		document.documentElement.style.setProperty('--theme-color', themeColor);
		document.querySelector("meta[name=theme-color]").setAttribute("content", themeColor);
		document.querySelector("meta[name=apple-mobile-web-app-status-bar-style]").setAttribute("content", themeColor);
		document.querySelector("meta[name=msapplication-navbutton-color]").setAttribute("content", themeColor);
		localStorage.setItem('theme-color', themeColor)
	}
	changeColor(themeColor)

	window.isPhone = /Android|iOS|iPhone|iPad|iPod|Windows Phone|KFAPWI/i.test(navigator.userAgent) || (window.innerWidth < 1300)
	window.isHome = false
	window.isPost = true
	if(window.isPost){
		window.isReward = true
		window.isWeibo = false
	}
</script><link rel="manifest" href="https://simonaking.com/manifest.json"><meta name="mobile-web-app-capable" content="yes"><meta name="mobile-web-app-title" content="SimonAKing"><meta name="msapplication-starturl" content="https://simonaking.com"><meta name="application-name" content="SimonAKing"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="SimonAKing"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="prefetch" href="https://cdn.jsdelivr.net/"><link rel="dns-prefetch" href="https://api.github.com/"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-109696496-3"></script><script>
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'UA-109696496-3');
</script><link rel="canonical" href="https://simonaking.com/blog/canvas/"><link rel="alternate" type="application/atom+xml" title="SimonAKing" href="/blog/atom.xml"><meta property="og:title" content="浅谈搭建平台-画布篇 | SimonAKing"><meta property="og:site_name" content="SimonAKing"><meta property="og:type" content="article"><meta property="og:url" content="https://simonaking.com/blog/canvas/"><meta property="og:locale" content="zh-CN"><meta name="description" content="关于建站类，相信大家都能说出一些耳熟能详的产品，如早期的 Dreamweaver、获取上亿投资的Webflow 以及 国内的各个大厂的搭建平台等。搭建平台本身也是一款软件，本文将带你了解其中的奥秘。 - SimonAKing - SimonAKing"><meta name="keywords" content="No Code,Low Code,搭建平台,NCLC,建站工具,前端,NCLC,SimonAKing,Blog,博客"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/SimonAKing/blog/canvas/5daef6094f8145f292e4b926749fa7a7~tplv-k3u1fbpfcp-watermark.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/SimonAKing/blog/canvas/image-20221111122204604.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/SimonAKing/blog/canvas/d0b601663dc74908882be828686c02f9~tplv-k3u1fbpfcp-watermark.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/SimonAKing/blog/canvas/ca3fd4b7b7584881bef5a5c8c59db469~tplv-k3u1fbpfcp-watermark.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/SimonAKing/blog/canvas/ae0e9299ebcb454ebaaca05f5d4cf57c~tplv-k3u1fbpfcp-watermark.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/SimonAKing/blog/canvas/59ede7cb46e24db5a68db2a52c63230a~tplv-k3u1fbpfcp-watermark.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/SimonAKing/blog/canvas/image-20221111131525099.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/SimonAKing/blog/canvas/image-20221111131550407.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/SimonAKing/blog/canvas/8e933995b42a4daa8cc3e7ec96a09999~tplv-k3u1fbpfcp-watermark.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/SimonAKing/blog/canvas/a589d61f848641a8beb2d274d00c2752~tplv-k3u1fbpfcp-watermark.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/SimonAKing/blog/canvas/7a0ec6dbc58244df9c390936a9699711~tplv-k3u1fbpfcp-watermark.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/SimonAKing/blog/canvas/42163ac93b39492b81652c66f95c1bf5~tplv-k3u1fbpfcp-watermark.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/SimonAKing/blog/canvas/52eaffa330194093ad6a146759c159be~tplv-k3u1fbpfcp-watermark.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/SimonAKing/blog/canvas/55b37e2ebb024c019444f0d6218f8c53~tplv-k3u1fbpfcp-watermark.png"><meta property="article:published_time" content="2022-11-10T17:40:53.000Z"><meta property="article:modified_time" content="2025-05-02T08:30:48.517Z"><meta property="og:updated_time" content="2025-05-02T08:30:48.517Z"><meta property="article:author" content="SimonAKing"><meta property="article:tag" content="No Code,Low Code,搭建平台,NCLC,建站工具,前端,NCLC,SimonAKing,Blog,博客"><meta name="twitter:card" content="summary"><meta name="twitter:site" content="https:&#x2F;&#x2F;simonaking.com&#x2F;blog&#x2F;canvas&#x2F;"><meta name="twitter:creator" content="SimonAKing"><script type="application/ld+json">
{
    "@context": "http://schema.org",
    "url": "https://simonaking.com/blog/canvas/",
    "@type": "BlogPosting",
    "logo": "https://simonaking.com/images/PWA/192.png",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://simonaking.com/blog/canvas/"
    },
    "headline": "浅谈搭建平台-画布篇 | SimonAKing",
    "image": {
        "@type": "ImageObject",
        "url": "https://simonaking.com/images/PWA/192.png"
    },
    "datePublished": "2022-11-10T17:40:53.000Z",
    "dateModified": "2025-05-02T08:30:48.517Z",
    "author": {
        "@type": "Person",
        "name": "SimonAKing",
        "image": {
            "@type": "ImageObject",
            "url": "https://cdn.jsdelivr.net/gh/SimonAKing/images/blog/avatar.jpg"
        },
        "description": "STDIN | Think &gt;&gt; /dev/Mind"
    },
    "publisher": {
        "@type": "Organization",
        "name": "SimonAKing",
        "logo": {
            "@type": "ImageObject",
            "url": "https://simonaking.com/images/PWA/192.png"
        }
    },
    "keywords": "No Code,Low Code,搭建平台,NCLC,建站工具,前端,NCLC,SimonAKing,Blog,博客",
    "description": "关于建站类，相信大家都能说出一些耳熟能详的产品，如早期的 Dreamweaver、获取上亿投资的Webflow 以及 国内的各个大厂的搭建平台等。搭建平台本身也是一款软件，本文将带你了解其中的奥秘。 - SimonAKing - SimonAKing"
}
</script><!--[if lt IE 9]><style> .alert { padding: 15px; margin-bottom: 20px; border: 1px solid transparent; border-radius: 4px } .alert-danger { background-color: #f2dede; border-color: #ebccd1; color: #a94442; border-bottom: 1px solid #ebccd1 } .alert-link { color: #843534; font-weight: bold } .topframe { margin: 0; padding-left: 15px; padding-right: 15px; text-align: center; border-radius: 0; position: fixed; left: 0; right: 0; top: 0; z-index: 1000 } </style><div class="alert alert-danger topframe"> 你的浏览器实在<strong>太太太太太太旧了</strong>，放学别走，升级完浏览器再说！ <a target="_blank" class="alert-link" href="//browsehappy.com">立即升级</a></div><script src="https://cdn.bootcss.com/html5shiv/r29/html5.min.js"></script><script src="https://cdn.bootcss.com/respond.js/1.4.2/respond.min.js"></script><![endif]--></head><body itemscope itemtype="http://schema.org/WebPage"><aside id="menu" class="hide"><div class="inner flex-row-vertical"><div class="brand-wrap" itemprop="author" itemscope itemtype="http://schema.org/Person"><div class="brand fade"> <a class="avatar waves-effect waves-circle waves-light"><img src="https://cdn.jsdelivr.net/gh/SimonAKing/images/blog/avatar.jpg" title="avatar" alt="avatar" itemprop="image"></a><div class="introduce"><h5 class="nickname " id="name">SimonAKing</h5><div class="links-of-author fade"><span class="links-of-author-item" id="link-wechat"><a href="javascript:void(0)" rel="noopener noreferrer" title="Wechat"><i class="icon icon-lg icon-wechat"></i></a></span><span class="links-of-author-item"><a href="mailto:hi@simonaking.com" rel="noopener noreferrer" target="_blank" title="Email"><i class="icon icon-lg icon-email"></i></a></span><span class="links-of-author-item"><a href="https://x.com/simon_aking" rel="external nofollow noopener noreferrer" target="_blank" title="X"><i class="icon icon-lg icon-XTwitter"></i></a></span><span class="links-of-author-item"><a href="https://github.com/SimonAKing" rel="external nofollow noopener noreferrer" target="_blank" title="Github"><i class="icon icon-lg icon-github"></i></a></span></div><div class="statistics"><ul><li><a class="total-link" href="/blog/weibo/"><div class="count" id="weibo-count">∞</div><div class="type">微博</div></a></li><li><a class="total-link" href="/blog/archives/"><div class="count">32</div><div class="type">文章</div></a></li><li><a class="total-link" href="/gallery/"><div class="count" id="photo-count">∞</div><div class="type">相册</div></a></li></ul></div></div></div></div><div class="scroll-wrap flex-col"><ul class="nav fade"><li class="items waves-block waves-effect"><a href="/blog/"><i class="icon icon-lg icon-xiazai45"></i> <span style="font-size:1em">主 页</span><i class="icon icon-lg icon-chevronleft custom-caret-left"></i></a></li><li class="items waves-block waves-effect"><a href="/blog/archives/"><i class="icon icon-lg icon-guidangxiangmu"></i> <span style="font-size:1em">归 档</span><i class="icon icon-lg icon-chevronleft custom-caret-left"></i></a></li><li class="items waves-block waves-effect"><a href="/blog/tags/"><i class="icon icon-lg icon-biaoqian"></i> <span style="font-size:1em">标 签</span><i class="icon icon-lg icon-chevronleft custom-caret-left"></i></a></li><li class="items waves-block waves-effect"><a href="/blog/weibo/"><i class="icon icon-lg icon-biaoqing"></i> <span style="font-size:1em">微 博</span><i class="icon icon-lg icon-chevronleft custom-caret-left"></i></a></li><li class="items waves-block waves-effect"><a href="//simonaking.com/gallery/"><i class="icon icon-lg icon-xiangce"></i> <span style="font-size:1em">相 册</span><i class="icon icon-lg icon-chevronleft custom-caret-left"></i></a></li><li class="items waves-block waves-effect"><a href="//simonaking.com/about/"><i class="icon icon-lg icon-zhifeiji"></i> <span style="font-size:1em">关 于</span><i class="icon icon-lg icon-chevronleft custom-caret-left"></i></a></li><li class="items waves-block waves-effect"><a href="//simonaking.com/projects/"><i class="icon icon-lg icon-projects"></i> <span style="font-size:1em">项 目</span><i class="icon icon-lg icon-chevronleft custom-caret-left"></i></a></li><li class="items waves-block waves-effect"><a href="//thinking.simonaking.com/" target="_blank" rel="noopener"><i class="icon icon-lg icon--Idea"></i> <span style="font-size:1em">思 考</span><i class="icon icon-lg icon-chevronleft custom-caret-left"></i></a></li><li class="items waves-block waves-effect"><a href="//simonaking.com"><i class="icon icon-lg icon-icon--"></i> <span style="font-size:1em">导航</span><i class="icon icon-lg icon-chevronleft custom-caret-left"></i></a></li><div class="sliding-bar"></div></ul><div class="nav-tool"><a class="nav-tool-item exchange" data-title="简繁互换" href="javascript:translatePage();"><i class="fade icon icon-lg icon-zhuanhuan custom-exchange"></i></a><a class="nav-tool-item picker" data-title="调色板" id="color-picker-icon"><i class="fade icon icon-lg icon-color-palette-outlin custom-picker"></i></a><a class="nav-tool-item light" data-title="关灯" href="javascript:switchNightMode();"><i class="fade icon icon-lg icon-lightbulbo custom-lightbulb"></i></a></div></div></div></aside><main id="main" class="in_post"><header class="top-header in_post" id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="flex-row"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle"><i class="icon icon-lg icon-naviconround"></i></a><div class="flex-col"></div><div class="search-wrap" id="search-wrap"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back"><i class="icon icon-lg icon-chevronleft"></i></a> <input type="text" id="key" aria-label="search" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字"><a href="javascript:;" title="搜索" class="header-icon waves-effect waves-circle waves-light" id="search"><i class="icon icon-lg icon-search"></i></a></div></div><div class="header-title ellipsis">浅谈搭建平台-画布篇</div></header><header class="content-header post-header"><canvas class="flickering-grid-canvas"></canvas></header><div class="container body-wrap"><aside class="post-widget"><nav class="post-toc-wrap fade" id="post-toc"><ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#前言"><span class="post-toc-number">1.</span> <span class="post-toc-text">前言</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#正文"><span class="post-toc-number">2.</span> <span class="post-toc-text">正文</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#什么是搭建平台"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">什么是搭建平台</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#衍生概念"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">衍生概念</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#架构设计"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">架构设计</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#IOC-架构"><span class="post-toc-number">2.3.1.</span> <span class="post-toc-text">IOC 架构</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#编辑渲染分层"><span class="post-toc-number">2.3.2.</span> <span class="post-toc-text">编辑渲染分层</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#事件体系"><span class="post-toc-number">2.3.3.</span> <span class="post-toc-text">事件体系</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#规范设计"><span class="post-toc-number">2.3.4.</span> <span class="post-toc-text">规范设计</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#画布设计"><span class="post-toc-number">2.4.</span> <span class="post-toc-text">画布设计</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#添加组件"><span class="post-toc-number">2.4.1.</span> <span class="post-toc-text">添加组件</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#拖拽组件"><span class="post-toc-number">2.4.2.</span> <span class="post-toc-text">拖拽组件</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#选择组件"><span class="post-toc-number">2.4.3.</span> <span class="post-toc-text">选择组件</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#结束语"><span class="post-toc-number">3.</span> <span class="post-toc-text">结束语</span></a></li></ol></nav></aside><article id="post-浅谈搭建平台-画布篇" class="post-article article-type-post fade" itemscope itemtype="http://schema.org/Article"><div class="post-card"><h1 class="post-card-title" itemprop="name headline">&nbsp;</h1><script>
			window.addEventListener('DOMContentLoaded', function (){ var postTitle = document.querySelector('.post-card-title'); var typingbefore = '浅谈搭建平台-画布篇'; var _i = 0; function typetitle() { if (_i <= typingbefore.length) { postTitle.innerHTML = `${typingbefore.slice(0, _i++)}|`; setTimeout(typetitle, 120); } else { postTitle.innerHTML = typingbefore; } } typetitle(); })
		</script><div class="post-meta"><div class="post-category-phone"><ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/blog/categories/%E5%89%8D%E7%AB%AF/">前端</a></li></ul></div> <time itemprop="dateCreated datePublished" class="post-time" title="2022-11-11 01:40:53" datetime="2022-11-10T17:40:53.000Z">2022-11-11</time></div><link itemprop="mainEntityOfPage" href="https://simonaking.com/blog/canvas/" style="display:none"><div class="post-content" id="post-content" itemprop="articleBody"><p>搭建平台本身也是一款软件，它更注重于“复用与组合”，而非实际的业务逻辑。<a id="more"></a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>近些年搭建平台变得很是流行，它提供了一种全新的开发方式，同时大幅降低了使用者的门槛，解决了企业的两大痛点：开发效率与人员转型。</p><p>搭建平台由编辑器（画布+设置器）和生成器组成，本文将重点介绍画布，分为架构设计与画布设计两个章节来展开。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="什么是搭建平台"><a href="#什么是搭建平台" class="headerlink" title="什么是搭建平台"></a>什么是搭建平台</h3><p>在介绍搭建平台之前，有一个无法绕过的主题，那就是 NCLC（No Code &amp; Low Code）。NCLC 作为建站产品背后的核心概念，推动了一波又一波的技术浪潮。</p><p>近些年围绕 NCLC 踊跃出了不同形态的产品，如项目管理 Meego、低代码系统 Retool、在线文档 Notion 等，甚至还有人将 NCLC 细分为了 12 个发展赛道。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div> <img src="https://cdn.jsdelivr.net/gh/SimonAKing/images/loading/2-min.gif" alt="image" title data-original="https://cdn.jsdelivr.net/gh/SimonAKing/blog/canvas/5daef6094f8145f292e4b926749fa7a7~tplv-k3u1fbpfcp-watermark.png"></div><div class="image-caption">image</div></figure><p><em>图片来源：<a href="https://pinver.medium.com/decoding-the-no-code-low-code-startup-universe-and-its-players-4b5e0221d58b" target="_blank" rel="external nofollow noopener noreferrer">https://pinver.medium.com/decoding-the-no-code-low-code-startup-universe-and-its-players-4b5e0221d58b</a></em></p><p><br> 其中业界内发展最为迅猛、最有代表性的产品形态莫过于 建站类。</p><p>关于建站类，相信大家都能说出一些耳熟能详的产品，如早期的 Dreamweaver、获取上亿投资的 SaaS Webflow 以及 国内的各个大厂的搭建平台等。</p><p>搭建平台之所以如此流行，原因不外乎于解决了企业的两大痛点：开发效率与人员转型。</p><p><strong>开发效率：</strong></p><p>搭建平台本身也是一款软件，与常见的 IDE 相比，都是为提高生产力服务；不同的是，它更注重于“复用与组合”，而非实际的业务逻辑。通俗来说，用组件拖拽与配置 代替了 传统的编程开发。</p><p>想象一下，我们需要开发一款海报形态的活动页面，必不可少的需要堆图片、堆动效，如果走传统的编程可能会花费数天。而如果走搭建，只需生成一次物料，拖拽并配置物料 就搞定了。</p><p>简而言之，搭建平台提供了一种全新的开发方式。面向特定场景下，开发的复杂度可以很好地被掩盖。如 电商活动、营销宣传、中后台等。</p><p><strong>人员转型：</strong></p><p>在日新月异的市场中，数字化转型获得了很多企业的一致认可，其中 NCLC 作为人员数字化背后的核心概念，允许企业员工在没有编程经验的情况下构建应用。</p><p>在搭建平台的用户中，除了研发同学，更常见的用户是没有编程技能的运营同学，ta 们通过搭建的方式生成所需的活动页面，在没有研发参与的情况下，真正按照自己的想法去实现。</p><p>搭建平台大幅降低了使用者的门槛，避免浪费过多的开发资源，进一步提升了 企业中的流程效率。</p><p>相信大家对搭建平台已经有一定的了解了，那么搭建平台由哪些概念组成呢？</p><h3 id="衍生概念"><a href="#衍生概念" class="headerlink" title="衍生概念"></a>衍生概念</h3><p>在发展的过程中，搭建平台 衍生出了众多的概念，让人望而却步，但核心可以用一句话来概括：</p><p>搭建平台 = 编辑器（画布+设置器）+ 生成器，而这些实体的数据源是物料，实体间遵循的通信协议是 UIDL。</p><p>编辑器与生成器独立通过 UIDL 解耦，做到 搭建的页面类型 只与使用的物料相关。</p><ul><li>编辑器 只负责前端技术栈物料的渲染，生产出 UIDL 规范。</li><li>生成器 消费 UIDL，再根据约定好的模板项目，生产出页面。</li></ul><p>该设计属于典型的分层架构，将系统分成若干个水平层，每一层都有清晰的角色和分工，不需要知道其他层的细节，层与层之间通过接口 &amp; 协议通信。</p><p>因为篇幅原因，本文的重心是 画布，分为架构设计与画布设计 两个章节来展开，设置器、生成器 可期待后续系列。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div> <img src="https://cdn.jsdelivr.net/gh/SimonAKing/images/loading/1-min.gif" alt="image-20221111122204604" title data-original="https://cdn.jsdelivr.net/gh/SimonAKing/blog/canvas/image-20221111122204604.png"></div><div class="image-caption">image-20221111122204604</div></figure><h3 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h3><p>该 part 介绍了 搭建平台中 核心的架构设计。</p><h4 id="IOC-架构"><a href="#IOC-架构" class="headerlink" title="IOC 架构"></a>IOC 架构</h4><p>各个功能模块之间会以 IOC 架构进行依赖耦合，具体来说 每个模块都需定义使用规范，统一在入口进行模块之间的注入绑定。</p><p>这意味着模块之间的依赖关系由容器在运行期决定。该设计优势在于功能模块之间的依赖以规范为主，不关心具体的实现；并且功能模块之间可以独立迭代，利于后续扩展。</p><p>举个例子：</p><p>每一种类型的终端会有独立的物料区、生成器的模板，以及相同的画布功能模块，在使用 IOC 架构之后，功能模块会以 底层基座 加扩展模块的方式进行聚合，如 TV 端画布与 移动端画布的明显差别在于画布分辨率、组件的选中态（TV 端存在焦点的概念），而这些差别 与 画布是附加的关系。</p><p>如此设计的好处是当出现新的终端时，可以快速适配。</p><p>总的来说，IOC 架构是一种可模块和可扩展的设计方案，让整个系统更加可插件化。</p><p>延伸阅读：<a href="https://github.com/inversify/InversifyJS/blob/master/wiki/good_practices.md" target="_blank" rel="external nofollow noopener noreferrer">InversifyJS 的最佳实践</a>。</p><h4 id="编辑渲染分层"><a href="#编辑渲染分层" class="headerlink" title="编辑渲染分层"></a>编辑渲染分层</h4><p>用户搭建时需要在组件上渲染出各种交互态，这些状态不能直接与组件本身耦合。搭建平台会把画布进一步分为 渲染层与编辑层，彼此之间通过通信协议进行解耦。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div> <img src="https://cdn.jsdelivr.net/gh/SimonAKing/images/loading/1-min.gif" alt="image.png" title data-original="https://cdn.jsdelivr.net/gh/SimonAKing/blog/canvas/d0b601663dc74908882be828686c02f9~tplv-k3u1fbpfcp-watermark.png"></div><div class="image-caption">image.png</div></figure><p>编辑层本质上是画布中真实渲染的元素；渲染层则是在编辑层之上的一层蒙版，其中蒙版是由 与真实元素 相同大小定位的虚拟元素组成的。</p><p>当用户编辑页面时，会直接操作到编辑层的元素，而后续的交互 会在渲染层上进行。</p><p>举例：当用户选中组件时，被选中的组件位于编辑层；选中组件后会出现 8 个锚点，这些锚点是在渲染层中挂载的。</p><p>这种设计带来的优势非常明显：</p><ul><li><p>可提效页面预览</p><p>预览页面时只需移除掉 画布编辑器的蒙版即可，真正的秒级预览。</p></li><li><p>便于画布的交互体验</p><p>组件的提示线、锚点只在渲染层中产出，不会影响编辑层的真实组件；并且当拖拽组件时 只需增删相应的渲染层组件即可。</p></li><li><p>真正的解耦设计</p><p>可枚举出画布编辑的规范与画布渲染的规范，梳理每一个行为与其所需的输入信息，让每一个行为都有足够详细的描述，真正做到分层解耦。</p><ul><li>画布编辑规范主要用于梳理 画布上的编辑动作，大概形态如下：</li></ul><figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> ComponentAddAction {}</span><br><span class="line"><span class="keyword">interface</span> ComponentDragAction {}</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><ul><li>画布渲染规范用于梳理 画布上的渲染动作，大概形态如下：</li></ul><figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> ComponentFocusRenderer {}</span><br><span class="line"><span class="keyword">interface</span> ComponentMirrorRenderer {}</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure></li></ul><p>业界中更激进的做法是将编辑与渲染通过 iframe 分层，具体来说是 渲染层是一个独立的路由，内嵌到编辑器中，编辑层会在渲染层之上建立一个等大小的蒙版。用户在操作画布时，蒙版会首先捕获用户的操作，再通过 iframe 的同源协议进行交互行为的通信，渲染层接收消息后实时做到响应。</p><p>通过 iframe 实现编辑渲染分层的好处有：</p><ul><li><p>天然的沙盒化</p><p>因为 iframe 的天然隔离性，画布渲染器中的所有逻辑、样式不会影响编辑器本身。</p></li><li><p>利于多人编辑</p><p>单人编辑时使用 iframe 进行通信，而多人编辑时可将 iframe 通信切换成 WebSocket 通信，设计时有异曲同工之妙。</p></li></ul><p>需要注意的是，如果想保障 编辑层与渲染层 相应组件之间的定位、大小相同，需要在 <code>resize</code>、<code>scroll</code> 事件中进行渲染层的重新渲染。</p><p><em>下文以画布代称编辑层与渲染层，不再做区分。</em></p><h4 id="事件体系"><a href="#事件体系" class="headerlink" title="事件体系"></a>事件体系</h4><p>事件体系是进一步解耦的设计方案，编辑器中会建设一套完善的事件体系，对应着每个编辑动作、渲染动作、全局动作的生命周期或者具体的回调动作。</p><p>每个功能模块都可消费相应的事件。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div> <img src="https://cdn.jsdelivr.net/gh/SimonAKing/images/loading/1-min.gif" alt="image.png" title data-original="https://cdn.jsdelivr.net/gh/SimonAKing/blog/canvas/ca3fd4b7b7584881bef5a5c8c59db469~tplv-k3u1fbpfcp-watermark.png"></div><div class="image-caption">image.png</div></figure><p>如此设计的好处是利于扩展，当添加新 feature 时，可以很容易地通过挂载事件来做到。</p><p>针对事件体系，举两个典型案例：</p><ul><li>当 页面加载时 会触发 init 事件，平台上的不同功能模块消费该事件：侧边栏加载物料、画布渲染 Schema、物料管理 加载基础依赖等。</li><li>当 拖拽组件到画布时 会触发 dragEnd 事件，平台上的不同功能模块消费该事件：物料管理加载拖拽的物料，设置器解析渲染拖拽物料的设置规范、画布移除拖拽镜像等。</li></ul><h4 id="规范设计"><a href="#规范设计" class="headerlink" title="规范设计"></a>规范设计</h4><p>在平台实践时，切记两点：</p><ul><li>围绕落地场景来设计产品思路，不可盲目堆功能。</li><li>规范先行，规范是贯穿编辑器的核心概念。</li></ul><p>下文介绍两个重点规范：UIDL 规范 与 物料规范。</p><p> <strong>UIDL 规范</strong></p><blockquote><p>UIDL：用于描述 搭建页面时的所有与 UI 相关的可结构化信息。</p></blockquote><p>UIDL 最初是由 teleporthq 公司提出：</p><figure class="highlight routeros"><table><tbody><tr><td class="code"><pre><span class="line">All<span class="built_in"> user </span>interfaces serve the same purpose: allow <span class="keyword">for</span> an interaction between a human <span class="keyword">and</span> a machine.</span><br><span class="line">Functionally speaking, the vocabulary of human-machine interaction is well defined. <span class="literal">No</span> matter the medium <span class="keyword">or</span> the technology used behind it, a<span class="built_in"> user interface </span>will likely be built with a dozen atomic visual elements such as: titles, paragraphs, inputs, images, videos, links, buttons, etc., <span class="keyword">and</span> a couple of meaningful compositions of these elements such as lists, tables, forms <span class="keyword">and</span> menus.</span><br><span class="line">However, over time the number of channels has increased dramatically (web, mobile, tablets, tv, AR/VR) <span class="keyword">and</span> the number of technologies used <span class="keyword">for</span> each of those channels as well. This has resulted <span class="keyword">in</span> an increased human time cost of building a<span class="built_in"> user interface </span><span class="keyword">and</span> distributing it <span class="keyword">to</span> each channel <span class="keyword">while</span> providing <span class="literal">no</span> extra value <span class="keyword">for</span> the end user.</span><br><span class="line">This is why we have decided <span class="keyword">to</span> search <span class="keyword">for</span> a solution which would allow us <span class="keyword">to</span> focus more on the what <span class="keyword">and</span> worry less about the how.</span><br><span class="line">Like others before us, we decided <span class="keyword">to</span> work on a universal format that could describe all the possible scenarios <span class="keyword">for</span> a given<span class="built_in"> user </span>interface. This format allows us <span class="keyword">to</span>:</span><br><span class="line">generate the same<span class="built_in"> user interface </span>with various tools <span class="keyword">and</span> frameworks</span><br><span class="line">transition <span class="keyword">from</span> one code output <span class="keyword">to</span> another without effort</span><br><span class="line"><span class="builtin-name">enable</span> efficient <span class="keyword">and</span> advanced programmatic manipulation</span><br><span class="line">We have named our universal format <span class="string">"User Interface Definition Language"</span> (UIDL). It is represented by a human-readable JSON document, a format supported natively by many programming languages.</span><br></pre></td></tr></tbody></table></figure><p><em>摘录自：<a href="https://docs.teleporthq.io/guides/what-is-this.html#uidl" target="_blank" rel="external nofollow noopener noreferrer">https://docs.teleporthq.io/guides/what-is-this.html#uidl</a></em></p><p>一般而言，UIDL 可由四部分组成：</p><ul><li>UIDL 元信息</li><li>项目元信息</li><li>页面 Schema 规范</li><li>使用的物料以及物料的配置</li></ul><figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> ComponentProps {</span><br><span class="line">  id: <span class="built_in">string</span></span><br><span class="line">  [key: <span class="built_in">string</span>]: <span class="built_in">any</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Schema {</span><br><span class="line">  id: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">type</span>: MaterialId</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  children: Schema[]</span><br><span class="line">  props: ComponentProp</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> UIDL {</span><br><span class="line">  meta: {</span><br><span class="line">    version: <span class="built_in">string</span> <span class="comment">// UIDL 元信息</span></span><br><span class="line">  }</span><br><span class="line">  project: {</span><br><span class="line">    <span class="comment">// 项目元信息</span></span><br><span class="line">    id: <span class="built_in">string</span></span><br><span class="line">    title: <span class="built_in">string</span></span><br><span class="line">    version: <span class="built_in">string</span></span><br><span class="line">    author: User</span><br><span class="line">    url: <span class="built_in">string</span></span><br><span class="line">  }</span><br><span class="line">  schema: Schema <span class="comment">// 页面 Schema 规范</span></span><br><span class="line">  materials: {</span><br><span class="line">    <span class="comment">// 使用的物料及其配置</span></span><br><span class="line">    components: <span class="built_in">Array</span>&lt;Component&gt;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p> <strong>物料规范</strong></p><blockquote><p>物料：用于描述 搭建页面时所需的组件等一系列可丰富页面功能、样式的实体。</p></blockquote><p>一个物料有多种属性，每一个属性都可成为分类的条件。</p><ul><li>终端划分：移动端 Web、小程序、TV 端…</li><li>形态划分：组件、插件、动作</li><li>功能划分：基础组件、容器组件、玩法组件…</li></ul><p>其中<strong>终端、业务线</strong> 是物料外在的属性，<strong>形态、功能</strong> 是物料内在的属性。</p><p>我们在确定一个具体物料时，会首先通过物料的外在属性过滤出当前页面上可用的物料，然后再通过物料的内在属性 明确应该使用的物料，所以在设计物料标识时也应尽可能的体现出关键的属性。</p><hr><h3 id="画布设计"><a href="#画布设计" class="headerlink" title="画布设计"></a>画布设计</h3><p>该 part 介绍了画布中的核心难点 以及 对应的实现方案。</p><p>为了让大家更好地理解文章脉络，我们举一个页面生产的案例：</p><p>有个男人叫小帅（请自行脑补），他接到了某活动的需求，需要产出一个宣传页面，页面的大概样子如下：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div> <img src="https://cdn.jsdelivr.net/gh/SimonAKing/images/loading/4-min.gif" alt="image.png" title data-original="https://cdn.jsdelivr.net/gh/SimonAKing/blog/canvas/ae0e9299ebcb454ebaaca05f5d4cf57c~tplv-k3u1fbpfcp-watermark.png"></div><div class="image-caption">image.png</div></figure><p>于是他开始打开某搭建平台，首先从物料区拖拽了三个组件：图片、文本、按钮，并按照设计格式放置好。</p><p>然后他开始进行各个组件的配置，图片组件上传设计图，文本组件配置介绍文案，按钮组件配置跳转链接。</p><p>配置完成后，他开始了活动发布，等待发布完成后，得到了一个可投放的页面链接，到此 任务完成。</p><p><em>来自一个真实的案例：</em></p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div> <img src="https://cdn.jsdelivr.net/gh/SimonAKing/images/loading/1-min.gif" alt="image" title data-original="https://cdn.jsdelivr.net/gh/SimonAKing/blog/canvas/59ede7cb46e24db5a68db2a52c63230a~tplv-k3u1fbpfcp-watermark.png"></div><div class="image-caption">image</div></figure><p>根据小帅的操作过程，我们不难得到以下关键流程：</p><p>生成页面 = (1)添加组件 - (2)拖拽组件 - (3)选择组件 - (3)配置组件（设置器）- (4)活动发布（生成器）。</p><p><em>因为文章篇幅，设置器、生成器 本文暂不展开，可期待后续系列。</em></p><p>其中前三个核心环节均是在画布中完成的，那么这些核心环节的背后发生了什么呢？</p><h4 id="添加组件"><a href="#添加组件" class="headerlink" title="添加组件"></a>添加组件</h4><p>添加组件的核心 有两点：</p><ol><li>组件的产物加载到搭建平台</li><li>生成组件的 Schema Node，并在拖拽结束时 插入到 UIDL（下一章节）</li></ol><p> <strong>Schema 生成</strong></p><p>当添加组件时，第一步是生成 组件的 Schema Node，为后续 UIDL 服务，生成时会解析当前组件设置器的规范，伪代码如下：</p><figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line">genSchema(component: ComponentMaterial): Schema {</span><br><span class="line">    <span class="keyword">const</span> children: Schema[] = []</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 应该由 设置器中的 props 填充</span></span><br><span class="line">    <span class="keyword">const</span> props = {}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 应该由 设置器中的默认样式填充</span></span><br><span class="line">    <span class="keyword">const</span> styles: React.CSSProperties = SchemaService.defaultStyles</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> {</span><br><span class="line">      id: <span class="keyword">this</span>.genComponentId(),</span><br><span class="line">      <span class="keyword">type</span>: component.id,</span><br><span class="line">      name: component.name,</span><br><span class="line"></span><br><span class="line">      props,</span><br><span class="line">      children,</span><br><span class="line">      styles</span><br><span class="line">    }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><p> <strong>加载物料</strong></p><p>用户第一次进入搭建平台时，是不可能直接加载所有物料资源的，物料一般是在使用时加载，这是因为物料是可扩展，加载所有物料 会导致搭建体验下降。</p><p>所以编辑器需要一种异步的物料加载方式，有利于渲染单页面资源 最优化。</p><p> <strong>打包规范</strong></p><p>很明显，物料的加载方式是需要与打包类型 紧密配合的。</p><p>在 Web 的模块化发展中，出现了四种使用较广泛的类型：AMD、CJS、UMD、ESM，其中 UMD 是在 AMD、CJS 上层的兼容方案，就不展开了。</p><p>下面简单梳理了下各种模块化的优劣势与适用场景。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div> <img src="https://cdn.jsdelivr.net/gh/SimonAKing/images/loading/1-min.gif" alt="image-20221111131525099" title data-original="https://cdn.jsdelivr.net/gh/SimonAKing/blog/canvas/image-20221111131525099.png"></div><div class="image-caption">image-20221111131525099</div></figure><p>现代前端模块化的发展趋势逐渐以 ESM 为主流，相比 AMD、CJS 有标准化组织支持，所以物料打包规范建议以 ESM 为目标。</p><p> <strong>加载物料</strong></p><p>随着前端模块化的发展，模块加载方式也出现了一些更加成熟的解决方案，梳理如下：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div> <img src="https://cdn.jsdelivr.net/gh/SimonAKing/images/loading/1-min.gif" alt="image-20221111131550407" title data-original="https://cdn.jsdelivr.net/gh/SimonAKing/blog/canvas/image-20221111131550407.png"></div><div class="image-caption">image-20221111131550407</div></figure><p>综合来说，使用 systemJS 加载模块是个更好的选择，对现代打包工具有较好的支持，有一套规范可以实现复杂的依赖引用，而且还支持各种模块的规范。</p><p> <strong>依赖分析</strong></p><p>除了加载物料本身还远远不够，物料在实现时会依赖很多通用的基础库、框架，如 按钮组件在 Web 端会依赖 React，具体依赖大概可分为以下三种类型：</p><ul><li><strong>基础框架、库</strong>：React、React-DOM 等</li><li><strong>特定组件下所需的 框架、库</strong>：如 xg-player</li><li><strong>依赖的其他组件</strong>：如 按钮列表组件 需要 按钮组件</li></ul><p>这三种类型的依赖，如果每一个物料都打包的话，无疑会造成很大的物料体积冗余，从而进一步影响拖拽体验，所以需要根据不同类型做不同的打包优化处理。</p><ul><li><strong>基础框架、库</strong>：会作为公共依赖存在，物料打包时不会打包进该产物，该产物会直接内置在 搭建平台侧。注意 这些公共依赖 需要在物料侧统一版本。</li><li><strong>特定组件下所需的 框架</strong>：会一起打包进物料，不进行处理。</li><li><strong>依赖的其他组件</strong>：物料打包时，会检查当前物料依赖的其他物料，并声明在物料信息的某一字段中（如 <strong>dependencies</strong>），物料在加载时 会先加载 依赖所需的物料。注意 物料加载方式是深度优先的，会存在多层依赖的场景。</li></ul><p> <strong>沙箱化</strong></p><p>每个物料作为单独的可执行单元，运行在同一 runtime 中，为了避免互相相互影响，沙箱化机制是必不可少的，我们可以参考以下微前端的常见沙箱化手段。</p><p>根据 Web 的技术特性，沙箱可分为逻辑隔离与样式隔离。</p><p> <strong>逻辑隔离</strong></p><p>逻辑隔离常见的方案有 Eval、Function 方案，其中 Eval 的安全性、性能与 Function 相比差距较大。</p><p>业界中常见的微前端框架 逻辑隔离是 通过代理 全局对象 实现，大概的逻辑如下：</p><figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> varBox = {};</span><br><span class="line"><span class="keyword">const</span> fakeWindow = <span class="keyword">new</span> Proxy(<span class="built_in">window</span>, {</span><br><span class="line">    <span class="keyword">get</span>(target, key) {</span><br><span class="line">        <span class="comment">// 敏感调用检查</span></span><br><span class="line">        <span class="keyword">return</span> varBox[key] || <span class="built_in">window</span>[key]</span><br><span class="line">    },</span><br><span class="line">    <span class="keyword">set</span>(target, key, value) {</span><br><span class="line">        <span class="comment">// 敏感调用检查</span></span><br><span class="line">        varBox[key] = value;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">})</span><br><span class="line"><span class="keyword">const</span> fn = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'window'</span>, code);</span><br><span class="line">fn(fakeWindow);</span><br></pre></td></tr></tbody></table></figure><p> <strong>样式隔离</strong></p><p>样式隔离根据开发的层面也有不同的解决方案。</p><p>在开发层，可以尝试使用 style-components 或者 css-module 方案，打包出具有唯一样式的组件。</p><p>在构建层可以使用 Shadow Dom 包一层 或者在所有样式外 加一层组件类名。</p><figure class="highlight reasonml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> elementRef = document.query<span class="constructor">Select('#<span class="params">sub</span>-<span class="params">app</span>')</span>;</span><br><span class="line"><span class="keyword">let</span> shadow = elementRef.attach<span class="constructor">Shadow({<span class="params">mode</span>: '<span class="params">open</span>'})</span>;</span><br></pre></td></tr></tbody></table></figure><p> <strong>结束语</strong></p><p>到此，添加组件已完成，回顾一下：</p><ol><li>组件的 UIDL 已经生成完毕</li><li>组件的资源已经被加载到了搭建平台。</li></ol><hr><h4 id="拖拽组件"><a href="#拖拽组件" class="headerlink" title="拖拽组件"></a>拖拽组件</h4><p>拖拽组件属于画布中的核心难点，该 part 将尽可能覆盖拖拽背后的技术难点。</p><p> <strong>拖拽库</strong></p><p>在介绍拖拽之前，必不可少要做的是 拖拽事件的监听与拖拽信息的收集，业界中有很多库都做了或多或少的事情，如 Github 的 <a href="https://github.com/topics/draggable" target="_blank" rel="external nofollow noopener noreferrer">draggable topic</a>。那么拖拽库又做了什么呢？</p><p>组件在拖拽时，会根据时间周期分为三个阶段，每个阶段都应该提供不同的信息供外部消费：</p><ul><li><p>拖拽开始 - 注册事件：MouseDown</p><ul><li>是否已拖拽，需提供 拖拽的判定距离，不能太小不然会误判。</li><li>触发拖拽开始的回调</li></ul></li><li><p>拖拽中 - 注册事件：MouseMove、Scroll</p><ul><li>拖拽的方向</li><li>拖拽的距离</li><li>拖拽的位置</li><li>触发拖拽中的回调</li><li>拖拽到边界时容器应随之滚动<ul><li>应只针对于非固定布局的元素</li></ul></li><li>拖拽时应显示拖拽中的光标</li></ul></li><li><p>拖拽结束 - 注册时间：MouseUp</p><ul><li>拖拽的位置</li><li>触发拖拽结束的回调</li></ul></li></ul><p>在拖拽组件时 预期可提供不同阶段的回调函数，再结合该引擎使用，做到底层隔离，聚焦业务逻辑。</p><p>你可能好奇 为什么要使用 <strong>MouseDown + MouseMove + MouseUp 模拟拖拽事件</strong>，而不使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/drag_event" target="_blank" rel="external nofollow noopener noreferrer">DOM 原生的 Drag 事件</a>？</p><p>画布组件拖拽中需要实时拿到当前的位置、拖拽方向，即需要注册 MouseMove 事件，如此一来不如使用以上三个 Mouse 事件模拟更加方便。</p><p> <strong>镜像组件</strong></p><p>组件从拖拽开始到拖拽结束 会有一个拖拽中的镜像组件，可以从以下两点提升搭建的体验。</p><p>这样做的好处是：镜像组件能前置加载组件资源 ，拖拽时也能给用户实时的反馈。</p><p>实现伪代码如下：</p><figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> componentMap = {}</span><br><span class="line"><span class="keyword">let</span> mirror = { move: xxx, destory:xxx }</span><br><span class="line"></span><br><span class="line"><span class="comment">// 鼠标摁下 加载物料，生成镜像</span></span><br><span class="line">onMouseDown = <span class="function">(<span class="params">e</span>) =&gt;</span> {</span><br><span class="line">    <span class="keyword">const</span> schema = genSchema(e)</span><br><span class="line">    <span class="keyword">const</span> schema = loadComponent(schema)</span><br><span class="line">    mirror = renderMirror(schema)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据拖拽的位置移动镜像</span></span><br><span class="line">onMouseMove = <span class="function">(<span class="params">e</span>) =&gt;</span> {</span><br><span class="line">    mirror.move(e)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拖拽结束销毁镜像</span></span><br><span class="line">onMouseUp = <span class="function">(<span class="params">e</span>) =&gt;</span> {</span><br><span class="line">    mirror.destory()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载组件资源</span></span><br><span class="line">loadComponent = <span class="function">(<span class="params">schema</span>) =&gt;</span> {</span><br><span class="line">    <span class="keyword">if</span>(componentMap[schema.type]) <span class="keyword">return</span></span><br><span class="line">    componentMap[schema.type] = systemjs.loadModule(schema.url)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据已经获取的组件资源 渲染镜像</span></span><br><span class="line">renderMirror = <span class="function">(<span class="params">schema</span>) =&gt;</span> {</span><br><span class="line">    <span class="keyword">const</span> mirrorEl = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(<span class="keyword">this</span>.mirrorEl)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> Mirror = componentMap[schema.type]</span><br><span class="line">    ReactDOM.render(&lt;Mirror /&gt;, <span class="keyword">this</span>.mirrorEl)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>在鼠标点击时加载物料资源 或者 复用已缓存的物料资源</li><li><p>在拖拽开始时渲染相应的组件</p></li><li><p>拖拽中 实时同步位置，拖拽结束卸载组件</p></li></ul><p> <strong>组件锚点</strong></p><blockquote><p>组件锚点 属于 拖拽组件中绕不开的一个概念。</p></blockquote><p>用知名绘图工具 <a href="https://app.diagrams.net/" target="_blank" rel="external nofollow noopener noreferrer">draw.io</a> 举例，选中组件后，会在组件周围出现 8 个锚点。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div> <img src="https://cdn.jsdelivr.net/gh/SimonAKing/images/loading/2-min.gif" alt="image" title data-original="https://cdn.jsdelivr.net/gh/SimonAKing/blog/canvas/8e933995b42a4daa8cc3e7ec96a09999~tplv-k3u1fbpfcp-watermark.png"></div><div class="image-caption">image</div></figure><p>组件在拖拽时 可根据其锚点进行 参考线的显示，并且在选中组件时 也可拖拽锚点进行组件的缩放。</p><p>组件锚点 一般分为 4 个、6 个、8 个，常见为 8 个，以组件左上角（X*Y）二维坐标举例：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div> <img src="https://cdn.jsdelivr.net/gh/SimonAKing/images/loading/4-min.gif" alt="image.png" title data-original="https://cdn.jsdelivr.net/gh/SimonAKing/blog/canvas/a589d61f848641a8beb2d274d00c2752~tplv-k3u1fbpfcp-watermark.png"></div><div class="image-caption">image.png</div></figure><p>实现逻辑是生成 8 个相应位置的锚点，再贴在原生节点上，具体实现如下：</p><figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pointList = [<span class="string">'t'</span>, <span class="string">'r'</span>, <span class="string">'b'</span>, <span class="string">'l'</span>, <span class="string">'lt'</span>, <span class="string">'rt'</span>, <span class="string">'lb'</span>, <span class="string">'rb'</span>]</span><br><span class="line"><span class="keyword">const</span> selectedComponent <span class="comment">// 选中的组件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pointStyle = {</span><br><span class="line">    width: <span class="number">5</span>px;</span><br><span class="line">    height: <span class="number">5</span>px;</span><br><span class="line">    border-radius: <span class="number">5</span>px;</span><br><span class="line">    cursor: point.split(<span class="string">''</span>).reverse().map(<span class="function"><span class="params">m</span> =&gt;</span> <span class="keyword">this</span>.directionKey[m]).join(<span class="string">''</span>) + <span class="string">'-resize'</span>,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> genPointStyle = <span class="function"><span class="params">point</span> =&gt;</span> {</span><br><span class="line">    <span class="keyword">let</span> { left, top } = selectComponent.style</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(point === <span class="string">'lt'</span>) {</span><br><span class="line">        <span class="keyword">return</span> ({...pointStyle,left,top})</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他点的处理逻辑...</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"> {pointList.map(<span class="function"><span class="params">p</span> =&gt;</span> ( &lt;div key={p} style={getPointStyle(p)}/&gt; ))}</span><br></pre></td></tr></tbody></table></figure><p> <strong>锚点拖拽</strong></p><p>锚点在拖拽时可以随意缩放组件本身的大小，从而 达到快捷设置组件尺寸的目的。</p><p><strong>重点来了，组件本身的位置大小，在 2D 坐标系中由四个属性即可描述完整：Width、Height、Left、Top，简称为 Rect，该概念贯穿全文</strong>。</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div> <img src="https://cdn.jsdelivr.net/gh/SimonAKing/images/loading/1-min.gif" alt="image.png" title data-original="https://cdn.jsdelivr.net/gh/SimonAKing/blog/canvas/7a0ec6dbc58244df9c390936a9699711~tplv-k3u1fbpfcp-watermark.png"></div><div class="image-caption">image.png</div></figure><p>并且需要注意的是，组件的 8 个锚点在拖拽时 都是以 <strong>对点（左&lt;-&gt;右）</strong> 为固定的，所以拖拽不同的锚点，达到的效果是不相同的。</p><ul><li>左上锚点：可更改组件的 Width、Height、Left、Top</li><li>中上锚点：可更改组件的 Height、Top</li><li>右上锚点：可更改组件的 Width、Height、Top</li><li>左中锚点：可更改组件的 Width、Left</li><li>右中锚点：可更改组件的 Width</li><li>左下锚点：可更改组件的 Width、Height、Left</li><li>中下锚点：可更改组件的 Height</li><li>右下锚点：可更改组件的 Width、Height</li></ul><p>举例说明：假设鼠标摁下的端点坐标为 (x1,y1)，鼠标移动时取任一时间切片的坐标为(x2,y2)，锚点拖拽具体的实现逻辑如下：：</p><ol><li>在鼠标点击时 记录点击的坐标(x1,y1)</li><li>在鼠标移动时，拿到鼠标移动时的坐标(x2,y2)</li><li>由两个坐标 相减的绝对值 得到拖拽的距离</li><li>根据以上的规则 与 拖拽的距离，重新设置 组件的 Width、Height、Left、Top</li></ol><p>伪代码如下：</p><figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> component <span class="comment">// 当前拖拽的组件</span></span><br><span class="line"><span class="keyword">let</span> startPoint <span class="comment">// 起点</span></span><br><span class="line"><span class="keyword">const</span> onMouseDown = <span class="function"><span class="params">e</span> =&gt;</span> { startPoint = <span class="keyword">new</span> Point(e) }</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> onMouseMove = <span class="function">(<span class="params">e,point</span>) =&gt;</span> {</span><br><span class="line">    <span class="keyword">const</span> distanceX = e.x - startPoint.x</span><br><span class="line">    <span class="keyword">const</span> distanceY = e.y - startPoint.y</span><br><span class="line">    <span class="keyword">if</span>(point === <span class="string">'LT'</span>) {</span><br><span class="line">        component.height -= distanceY</span><br><span class="line">        component.width -= distanceX</span><br><span class="line">        component.left += distanceX</span><br><span class="line">        component.top += distanceY</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 其他点处理...</span></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p> <strong>智能吸附</strong></p><p>智能吸附属于组件拖拽时的辅助功能，提升页面的搭建效率。</p><p>智能吸附一般可分为三种：位置吸附、距离吸附与尺寸吸附。</p><p> <strong>位置吸附</strong></p><p>位置吸附在很多编辑场景中都能见得到，如设计工具、搭建平台、绘图工具等。</p><p>主要原理是，用户在拖拽某一组件时，如果<strong>检测到 拖拽中的组件位置 与 画布中其他组件的位置 小于吸附的阈值，则会智能吸附</strong>，从而使得 用户搭建页面更加准确。</p><p>吸附的阈值一般为 1~5 px 常见为 3 px，如果阈值太大 则卡顿感会很明显。</p><p>智能吸附的原理很简单，当检测到 拖拽中组件与其他组件的 不同锚点 X 坐标或 Y 坐标之间的差绝对值小于阈值时，就会将拖拽中组件的 Rect 中的 Left/Top 直接设置为 被吸附组件的锚点坐标。</p><p>并且当吸附后组件之间会显示参考线，参考线一般根据锚点位置分为 2 种类型 6 条参考线，分别是：</p><ul><li>X 轴参考线 - Left、Height 是变量，Width 一般为 较小值，Top 一般等于吸附位置的 Top</li><li>Y 轴参考线：Top、Width 是变量，Height 一般为 较小值，Left 一般等于吸附位置的 Left</li></ul><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div> <img src="https://cdn.jsdelivr.net/gh/SimonAKing/images/loading/3-min.gif" alt="image.png" title data-original="https://cdn.jsdelivr.net/gh/SimonAKing/blog/canvas/42163ac93b39492b81652c66f95c1bf5~tplv-k3u1fbpfcp-watermark.png"></div><div class="image-caption">image.png</div></figure><p>参考线的显示与锚点显示的大概逻辑相同，也是通过已知的定位大小 与 较高的图层 渲染在画布上。</p><p>伪代码如下：</p><figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> draggingComponent <span class="comment">// 拖拽中的组件</span></span><br><span class="line"><span class="keyword">let</span> allComponents <span class="comment">// 画布中的所有组件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 垂直参考线样式 width: 1px;height: 100%; z-index: 9e3; display:none</span></span><br><span class="line"><span class="keyword">let</span> verticalLine</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> onMouseDown = <span class="function"><span class="params">e</span> =&gt;</span> {</span><br><span class="line">    draggingComponent = getComponentByMousePosition(e)</span><br><span class="line">    allComponents = getAllComponents() <span class="comment">// 得到画布中的所有组件</span></span><br><span class="line"></span><br><span class="line">    注册鼠标移动、鼠标抬起事件</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Diff = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isNearly = <span class="function">(<span class="params">a,b</span>) =&gt;</span> <span class="built_in">Math</span>.abs(a-b) &lt; Diff</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> onMouseMove = <span class="function">(<span class="params">e</span>) =&gt;</span> {</span><br><span class="line">    allComponent.forEach(<span class="function"><span class="params">c</span> =&gt;</span> {</span><br><span class="line">        <span class="keyword">const</span> {left,top} = c.getBoundingClientRect()</span><br><span class="line">        <span class="keyword">if</span>(isNearly(e.left,left)){</span><br><span class="line">            draggingComponent.style.left = left</span><br><span class="line"></span><br><span class="line">            verticalLine.style.left = left</span><br><span class="line">            verticalLine.style.display = <span class="string">'block'</span></span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 同理针对 top、top + top/2 、其他点...</span></span><br><span class="line"></span><br><span class="line">    })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p> <strong>距离吸附</strong></p><p>很多设计工具除了 位置吸附外，也提供了距离吸附。</p><p>用户在拖拽组件时，画布会实时检测 <strong>组件之间是否已存在 一定误差范围内的相同边距，如果存在 则设置组件的位置，已达到 边距与已存在的边距一致</strong>。</p><p>该功能在排版 边距相同的组件时会很有效。</p><p>功能要点如下：</p><ul><li><p>因为搭建页面时，画布的组件只能分为两种：拖拽中的组件 与 静态放置的组件。 静态放置的相邻组件之间是可以计算出边距的，所以编辑器中可存在一个代表 包含了画布上所有相邻组件的边距状态。</p></li><li><p>当拖拽组件时，会拿到拖拽组件与相邻组件之间的边距，如果该边距 命中了 已知的边距大小，则进行组件之间的边距渲染。</p></li><li><p>为了防止 边距吸附引起的噪音过大，组件之间的边距计算，需组件在拖拽组件视图内，如下：</p><p><img src="./浅谈搭建平台-画布篇/8099aca92bf14907ad3f24fc3c6216a6~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p><ul><li>垂直视图内判定：以下条件需全部满足<ul><li>拖拽组件的 Right &gt;= 兄弟组件的 Left</li><li>拖拽组件的 Left &lt;= 兄弟组件的 Right</li></ul></li><li>水平视图内判定：<ul><li>拖拽组件的 Bottom &gt;= 兄弟组件的 Top</li><li>拖拽组件的 Top &lt;= 兄弟组件的 Bottom</li></ul></li></ul></li><li><p>组件在拖拽时，参考边距由：父组件、没有与拖拽组件相交的兄弟组件、参考线组成。</p><ul><li>垂直参考距离：下侧组件的 Top - 相邻上侧组件的 Bottom</li><li>水平参考距离：右侧组件的 Left - 相邻左侧组件的 Right</li><li>拖拽中已知的距离：<ul><li>上侧距离：拖拽组件的 Top - 相邻上侧组件的 Bottom</li><li>下侧距离：相邻下侧组件的 Top - 拖拽组件的 Bottom</li><li>左侧距离：拖拽组件的 Left - 相邻左侧组件的 Right</li><li>右侧距离：拖拽组件的 Right - 相邻右侧组件的 Left</li></ul></li></ul></li><li><p>在计算时会将父组件模拟成四个组件，具体逻辑如下：</p></li></ul><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div> <img src="https://cdn.jsdelivr.net/gh/SimonAKing/images/loading/3-min.gif" alt="image.png" title data-original="https://cdn.jsdelivr.net/gh/SimonAKing/blog/canvas/52eaffa330194093ad6a146759c159be~tplv-k3u1fbpfcp-watermark.png"></div><div class="image-caption">image.png</div></figure><p>基于以上要点，梳理逻辑如下：</p><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div> <img src="https://cdn.jsdelivr.net/gh/SimonAKing/images/loading/3-min.gif" alt="image.png" title data-original="https://cdn.jsdelivr.net/gh/SimonAKing/blog/canvas/55b37e2ebb024c019444f0d6218f8c53~tplv-k3u1fbpfcp-watermark.png"></div><div class="image-caption">image.png</div></figure><p>最后渲染的流程等价于 画布上显示各种 高亮提示，因为已经得到了具体的 rect 信息，实现手段很多样 就不展开了，比如悬浮一个 div。</p><p> <strong>尺寸吸附</strong></p><p>当锚点拖拽时，也可提供 缩放组件时的尺寸吸附。</p><p><strong>当缩放组件的高宽存在一定误差内相同的组件高宽时，就会自动设置。</strong></p><p>达到智能吸附的效果，便于设置相同大小的组件。</p><p>功能要点如下：</p><ol><li>画布缩放时存在 8 种类型，需要根据不同类型与变化的值 计算出 当前缩放的边。<ol><li>如拖拽 topLeft 锚点时，只有 Height 发生了变化，那么就寻找存在一定误差的 Height。</li><li>并且 Height 的吸附提示 只显示在 Left 侧。</li></ol></li><li>参考的组件为所有兄弟组件，如果存在多个一定误差内的组件，则取最小误差的，并且把所有最小误差的组件都渲染出 吸附提示。</li><li>吸附提示较简单，分为高度提示 与 宽度提示。</li></ol><p> <strong>组件插入</strong></p><p>组件插入时，需要根据对应的布局类型与图层关系，将 组件 对应的 Schema Node 信息插入到 UIDL 中，而画布会根据 UIDL 响应式进行渲染。</p><p>通俗理解，画布等价于 UIDL 树结构动态渲染的工程，即 canvas = render(UIDL)，伪代码如下：</p><figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Props = {</span><br><span class="line">  id: ComponentId</span><br><span class="line">  key?: <span class="built_in">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> DynamicComponent: React.FC&lt;Props&gt; = <span class="function">(<span class="params">{ id }</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">const</span> [schema, version] = useSchema(id)</span><br><span class="line">  <span class="keyword">const</span> moduleMap = useSelector(<span class="function">(<span class="params">state: RootState</span>) =&gt;</span> state.material.moduleMap)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> { children = [], <span class="keyword">type</span>, props, name } = schema</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> Module = moduleMap[<span class="keyword">type</span>]</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Module key={id} {...props}&gt;</span><br><span class="line">      {children.map(<span class="function"><span class="params">child</span> =&gt;</span> (</span><br><span class="line">        &lt;DynamicComponent</span><br><span class="line">          key={child.id}</span><br><span class="line">          id={child.id}</span><br><span class="line">        /&gt;</span><br><span class="line">      ))}</span><br><span class="line">    &lt;<span class="regexp">/Module&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">}</span></span><br></pre></td></tr></tbody></table></figure><p>在插入完成后，还可发起 事件通知，进行后置的操作，如：选中组件、销毁镜像、设置器更新等。</p><p> <strong>插入提示</strong></p><p>组件在拖拽时会实时计算鼠标下的 DOM 节点是否为画布中的组件，如果是画布组件需给出可插入提示，从而提升搭建体验。</p><p>实时计算 DOM 节点，可通过 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/elementsFromPoint" target="_blank" rel="external nofollow noopener noreferrer">document.elementsFromPoint</a> 方法，该方法会返回鼠标下的所有 DOM 节点，后续可深度遍历 查找出具有特征标识的 画布组件。</p><p>根据组件插入的方式 可知，插入动作分为 插入目标组件中 与 插入目标组件周围，这两种插入动作的提示重心是完全不同的。</p><ul><li><p><strong>插入目标组件中</strong>，提示重心在于目标组件可包含。</p></li><li><p><strong>插入目标组件周围</strong>，提示重心在于插入的位置。</p></li></ul><p>关于提示的实现，可通过增加上层绝对定位的 DOM 节点，这里不具体展开了。</p><p> <strong>结束语</strong></p><p>至此，组件已经成功被插入到画布中，回顾一下：</p><ul><li>使用 or 自研 拖拽库，作为底层能力，不同阶段的信息供外部消费。</li><li>在拖拽时有 镜像组件、多种智能吸附的效果 来保障搭建的效率与体验。</li><li>组件插入时，利用 UIDL 响应式渲染的特性，在画布中呈现最新的组件。</li></ul><hr><h4 id="选择组件"><a href="#选择组件" class="headerlink" title="选择组件"></a>选择组件</h4><p>该 part 将重点介绍 组件选择后的核心机制，与可交互的快捷功能。</p><p> <strong>事件分发</strong></p><p>在组件选择后，有一个无法绕过的主题，那就是事件分发。</p><p>由于画布中的组件是动态加载来的，如果想为组件绑定事件，需要在组件开发时进行内部的 props 消费，如把 onClick 透传到组件根节点上，但针对组件产物 进行事件绑定，这显然是不合理的。</p><p>所以如果想绑定事件，只能从 DOM 层出发，解放方案有二：</p><ul><li><p>组件节点声明 组件的关键信息，并且在 Wapper 中为每个组件绑定事件。</p><ul><li>优势：<ul><li>事件触发更准确</li></ul></li><li>劣势：<ul><li>需要绑定 组件个数 * N 个事件</li></ul></li></ul></li><li><p>绑定全局的事件，再根据点击的位置找到相应的元素，进行分发。</p><ul><li>优势：<ul><li>节省内存</li></ul></li><li>劣势：<ul><li>需要一套完善的组件查找机制</li></ul></li></ul></li></ul><p>为了实现的复杂度，选择方案一即可。</p><p>回归到事件分发的本身，事件分发是为了绑定画布组件的事件出现，编辑器可以提供一个 EventProvider ，该功能希望能做到不侵入原有组件、不影响组件功能、样式，并且还可为组件绑定各种事件。</p><p>可借助 display:contents 可以实现该功能，如果大家对该属性感兴趣，也可以看下 iCSS 前端趣闻 的一篇文章：<a href="https://mp.weixin.qq.com/s/DhkQNO8Hv1zZP9Fu7uSw-g" target="_blank" rel="external nofollow noopener noreferrer">冷知识！使用 display: contents 实现幽灵节点？</a></p><p>具体逻辑如下：</p><figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withEventProvider</span>&lt;<span class="title">P</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  Component: React.ComponentType&lt;P&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">React</span>.<span class="title">ComponentType</span>&lt;<span class="title">P</span>&gt; </span>{</span><br><span class="line">  <span class="keyword">const</span> Wrapped: React.ComponentType&lt;P&gt; = <span class="function"><span class="params">props</span> =&gt;</span> {</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div</span><br><span class="line">        style={{ display: <span class="string">'contents'</span> }}</span><br><span class="line">        onClick={<span class="function"><span class="params">e</span> =&gt;</span> {</span><br><span class="line">          <span class="built_in">console</span>.log(e, props)</span><br><span class="line">        }}&gt;</span><br><span class="line">        &lt;Component {...props} /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  }</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  const name = Component.displayName ?? Component.name ?? 'Unknown'</span></span><br><span class="line"><span class="regexp">  Wrapped.displayName = `withEventProvider(${name})`</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  return Wrapped</span></span><br><span class="line"><span class="regexp">}</span></span><br></pre></td></tr></tbody></table></figure><p> <strong>快捷操作</strong></p><p>用户在选中组件后可进行以下快捷操作，希望提高搭建效率。</p><p> <strong>删除组件</strong></p><blockquote><p>用户在选中组件之后，可以使用快捷键或者右键菜单进行删除组件。</p></blockquote><p>具体逻辑为：删除目标组件在 Schema 中的相应节点，删除之后画布重新渲染即可。</p><p> <strong>复制粘贴</strong></p><blockquote><p>用户在选中组件之后，可以使用快捷键或者右键菜单进行进行复制组件。</p><p>预期操作途径：选中组件 X -&gt; Ctrl C -&gt; 选中画布、组件 Y -&gt; Ctrl V</p></blockquote><p>需要注意的点如下：</p><ul><li>在画布状态中需维护 已复制的组件 schema，并且复制的组件状态只是单个变量，非数组。</li><li>当 X、Y 组件是同一组件时，需设置两个组件偏移量，不然很容易出现重叠的情况。</li><li>插入组件时 应重置 复制组件的 Left、Top ，不然会出现偏移不符合目标容器的情况。</li></ul><p>具体逻辑类似于组件插入。</p><p> <strong>剪切组件</strong></p><blockquote><p>用户在选中组件之后，可以使用快捷键或者右键菜单进行进行剪切组件。</p></blockquote><p>剪切操作本质上是 复制粘贴操作 与 删除操作的组合，在用户复制组件后 需将复制的组件从画布中删除，剪切操作与复制操作中使用的是同一画布状态。</p><p> <strong>文本编辑</strong></p><p>在很多搭建平台、设计工具中，文本内容可以进行双击编辑，使用起来符合直觉。</p><p>组件在开发时可为编辑的文本 wrapper 增加声明属性，如 data-edit=”propKey”</p><figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Text: React.FC&lt;Props&gt; = <span class="function">(<span class="params">{ id, styles = {}, content = '请输入文字' }</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div id={id} className={s.text} style={styles} data-edit=<span class="string">'content'</span>&gt;</span><br><span class="line">      {content}</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">}</span></span><br></pre></td></tr></tbody></table></figure><p>组件在挂载到画布之后，会为所有声明了 data-edit 的 DOM 节点设置 contentEditable。</p><p>用户在选中某一组件后，会判断当前位置是否存在 可编辑的文本，如存在 会在失去组件焦点后 同步设置组件的文本，已达到更新输入后的内容。</p><p> <strong>组件旋转</strong></p><p>组件旋转功能常见于设计工具或 自由度较高的建站平台中，活动页搭建平台中使用的场景较少。</p><p>旋转功能的具体原理简单来说是，拿到 鼠标点击时坐标与鼠标移动时坐标 针对组件中心点 各自对应的角度，将其相减就是旋转的角度。</p><p> <strong>组件多选</strong></p><p>用户可通过拖拽鼠标完成多个组件的选择，实现针对多个组件的同时操作，提升效率。</p><p> <strong>选择区域</strong></p><p>用户在画布上拖拽鼠标时 需实时高亮已选择的区域，该功能属于组件多选的基本能力。</p><p>假设鼠标摁下的端点坐标为 (x1,y1)，鼠标移动时取任一时间切片的坐标为(x2,y2)，从视频中可以分析出以下三点：</p><ul><li>选择区域 是以 (x1,y1) 为不动点</li><li>区域的宽 是 x2 与 x1 之间的距离，区域的高是 y2 与 y1 之间的距离</li><li>区域的左上坐标为 (min(x1,x2),min(y1,y2))</li></ul><p>具体设计思路如下：</p><figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> startPoint = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> area = {</span><br><span class="line">    width: <span class="number">0</span>,</span><br><span class="line">    height: <span class="number">0</span>,</span><br><span class="line">    x: <span class="number">0</span>,</span><br><span class="line">    y: <span class="number">0</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> onMouseDown = <span class="function"><span class="params">e</span> =&gt;</span> {</span><br><span class="line">    <span class="comment">// 记录端点</span></span><br><span class="line">    startPoint = <span class="keyword">new</span> Point(e)</span><br><span class="line"></span><br><span class="line">    注册鼠标移动、鼠标抬起事件</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> onMouseMove = <span class="function"><span class="params">e</span> =&gt;</span> {</span><br><span class="line">    area.width = <span class="built_in">Math</span>.abs(e.x - startPoint.x)</span><br><span class="line">    area.height = <span class="built_in">Math</span>.abs(e.y - startPoint.y)</span><br><span class="line">    area.x = <span class="built_in">Math</span>.min(e.x, startPoint.x)</span><br><span class="line">    area.y = <span class="built_in">Math</span>.min(e.y, startPoint.y)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">&lt;Area style={area} /&gt;</span><br></pre></td></tr></tbody></table></figure><p>当鼠标抬起后 <strong>选择区域会缩小成 区域中组件组合形成的最小矩形</strong>。</p><p>分析要点如下：</p><ul><li>选择轮廓区域中的组件 需被完全包含</li><li>选择轮廓区域的宽高 由边界组件的位置限定</li><li>选择轮廓区域的位置 等于边界组件的位置</li></ul><p>具体设计思路如下：</p><figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 得到画布中的所有组件</span></span><br><span class="line"><span class="keyword">const</span> components = getAllComponentInCanvas()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到选择区域中的组件</span></span><br><span class="line"><span class="keyword">const</span> componentsInArea = components.filter(<span class="function"><span class="params">c</span> =&gt;</span> isInArea(c,area))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到多个组件之间的边界</span></span><br><span class="line"><span class="keyword">type</span> Boundary = {left:<span class="built_in">number</span>,right:<span class="built_in">number</span>,top:<span class="built_in">number</span>,bottom:<span class="built_in">number</span>}</span><br><span class="line"><span class="keyword">const</span> boundary:Boundary = getComponentsBoundary(componentsInArea)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span>  outlineArea = { width: boundary.right - boundary.left , height: ...,x:boundary.left,y: boundary.bottom }</span><br><span class="line"></span><br><span class="line">&lt;Area style={outlineArea} /&gt;</span><br></pre></td></tr></tbody></table></figure><p> <strong>同时操作</strong></p><p>在选择多个组件后，用户可同时对选择的组件进行 移动 &amp; 拉伸操作。</p><p>常见的设计工具中为了提升移动性能，减少终端算力，会在拖拽开始前 生成选择轮廓的 DOM 节点，再把选择的多个组件插入其中，这样多个组件拖拽时 实质上是在拖拽最外层的 选择轮廓节点。在拖拽完成后，会隐藏 外层轮廓节点，再为每个组件重新计算最终的移动位置。</p><p>不过对于搭建平台来说，因为多选的组件个数不会太多，同时一起移动 也不会太多负向影响。</p><p>具体移动的逻辑可参考镜像组件，会为选择的每个组件都生成镜像组件再移动。</p><p>需要注意的是 移动时的智能吸附 以及 组件插入 是根据选择轮廓的外层位置来判定的，可理解为 组件多选后 同时移动不再根据单个组件判定 而是根据整体轮廓来判定。</p><p>同时拉伸与移动同理，都是根据单个组件拉伸的规则，同时操作在多个组件上。</p><p> <strong>结束语</strong></p><p>至此，我们可以在选择组件后进行操作了，回顾一下：</p><ul><li>使用事件分发机制，感知到当前用户操作的组件。</li><li>通过快捷操作，文本编辑、组件旋转、增删组件的方式 提升搭建的效率。</li><li>可选择多个组件进行同时的移动编辑。</li></ul><hr><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>本文根据一个常见的搭建页面案例，梳理了搭建平台的核心实体-画布的技术难点。</p><p>当然对于一个成熟的编辑器而言，除了画布外，还有 设置器 与 生成器，不过碍于篇幅，敬请期待后续文章。</p><p>欢迎转载本站文章，请注明作者和出处 <a href="http://simonaking.com">SimonAKing</a>。</p></div><div class="recommended_posts"><div class="recommended_wrap"><h2 class="recommended_title">相关文章</h2><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"> <a href="/blog/history-of-front-end-architecture/" rel="bookmark">前端架构发展史</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"> <a href="/blog/7-code-smells-in-react-components/" rel="bookmark">React 的 7 种代码异味[译]</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"> <a href="/blog/simplified-chinese-and-traditional-chinese-switching/" rel="bookmark">网站必备之简繁切换</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"> <a href="/blog/learning-less-seeing-this-is-enough/" rel="bookmark">学习 Less-看这篇就够了</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"> <a href="/blog/webpack-flight-manual/" rel="bookmark">Webpack 飞行手册</a></div></li></ul></div></div><blockquote class="post-copyright"><div class="content"> <span class="post-time">最后更新：<time datetime="2025-05-02T08:30:48.517Z">2025-05-02 16:30:48</time></span> 原文链接：<a href="/blog/canvas/" target="_blank" rel="external">https://simonaking.com/blog/canvas/</a></div><footer><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/NCLC/" rel="tag">NCLC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li></ul><div> <img itemprop="image" lass="copyimg" src="https://cdn.jsdelivr.net/gh/SimonAKing/images/blog/avatar.jpg" alt="SimonAKing"> <a itemprop="author" itemscope itemtype="http://schema.org/Person" href="/blog">SimonAKing</a></div></footer></blockquote></div><section class="comments" id="comments"><div id="disqus_thread"></div></section></article></div></main><div class="mask" id="mask"></div><a href="javascript:;" id="gotop" class="fade-scale waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevronup"></span></a><div class="search-panel in_post" id="search-panel"><ul class="search-result" id="search-result"></ul></div><template id="search-tpl"><li class="item waves-block waves-effect" onclick="location.href='{path}'" data-path="{path}"><div class="title ellipsis" title="{title}">{title}</div></li></template><div id="color-picker" class="page-modal"><a class="close" href="javascript:;"><i class="icon icon-close2"></i></a><br><h4><i class="icon icon-quote-left"></i> <span>RGB调色实验室 🎨</span><i class="icon icon-quote-right"></i></h4><div id="color-picker-container"></div></div><div id="wechat" class="page-modal wechat-wrap"><a class="close" href="javascript:;"><i class="icon icon-close2"></i></a><br><h4 class="wechat-title"> <span style="font-size: 18px">欢迎添加我的微信，进群交流、学习<br><i class="icon icon-quote-left"></i> simonaking<i class="icon icon-quote-right"></i></span></h4> <img id="wechat_img" src="https://cdn.jsdelivr.net/gh/SimonAKing/images/blog/wx.png" alt="欢迎您的关注！" style="margin-top: 5%"></div><script src="https://simonaking.com/registerSW.js?v=7d04115230169"></script><script src="https://cdn.jsdelivr.net/gh/SimonAKing/js/log.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/src/js/waves.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/headroom.js@0.12.0/dist/headroom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@jaames/iro@5.2.3/dist/iro.min.js"></script><script src="https://cdn.jsdelivr.net/gh/SimonAKing/blog@7d04115230169/js/particles-585dd6bbf8.js"></script><script src="https://cdn.jsdelivr.net/gh/SimonAKing/blog@7d04115230169/js/main-c5641580d9.js"></script><script src="https://cdn.jsdelivr.net/gh/SimonAKing/blog@7d04115230169/js/script-66d90ba09e.js"></script><script src="https://cdn.jsdelivr.net/gh/SimonAKing/blog@7d04115230169/js/module/hover-effect-e72a114ce3.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.1.0/instantpage.min.js"></script><script src="https://cdn.jsdelivr.net/gh/SimonAKing/blog@7d04115230169/js/module/post-6d3f729af5.js"></script><script defer src="https://cdn.jsdelivr.net/gh/SimonAKing/blog@7d04115230169/js/module/comment-5cad405b01.js"></script><script defer src="https://cdn.jsdelivr.net/gh/SimonAKing/js/translate-ff7607fcb8.js"></script></body></html>